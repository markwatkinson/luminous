<COMMENT>#!/usr/bin/perl -w</COMMENT>
<COMMENT>#</COMMENT>
<COMMENT># sclc -- source code line counter (actually it counts more than just lines)</COMMENT>
<COMMENT>#</COMMENT>
<COMMENT># Created 06/09/95 by Brad Appleton &lt;bradapp@enteract.com&gt;</COMMENT>
<COMMENT># Patched for Matlab and ZPL 11/01/04 by Bill Mann &lt;wfmann@alum.mit.edu&gt;</COMMENT>
<COMMENT># Patched for FORTRAN 11/03/04 by Bill Mann &lt;wfmann@alum.mit.edu&gt;</COMMENT>
<COMMENT># Added approximate token counting  1/20/05  Bill Mann</COMMENT>
<COMMENT># Added my impression of Chapel  1/20/05  Bill Mann</COMMENT>
<COMMENT># Handles Fortran OpenMP directives  9/14/05  Lorin Hochstein &lt;lorin@cs.umd.edu&gt;</COMMENT>
<COMMENT># See &lt;http://code.google.com/p/sclc/&gt; for remaining changes to this source.</COMMENT>
<COMMENT>#</COMMENT>
<COMMENT>#-------------------------------------------------------------------------</COMMENT>
<COMMENT># COPYING</COMMENT>
<COMMENT># =======</COMMENT>
<COMMENT># This file/program is free software; you can redistribute it and/or</COMMENT>
<COMMENT># modify it under the same terms as Perl itself. Please refer to the</COMMENT>
<COMMENT># license that came with your Perl distribution for more details.</COMMENT>
<COMMENT>#</COMMENT>
<COMMENT># DISCLAIMER</COMMENT>
<COMMENT># ===========</COMMENT>
<COMMENT># This software is distributed in the hope that it will be useful, but</COMMENT>
<COMMENT># is provided "AS IS" WITHOUT WARRANTY OF ANY KIND, either expressed or</COMMENT>
<COMMENT># implied, INCLUDING, without limitation, the implied warranties of</COMMENT>
<COMMENT># MERCHANTABILITY and FITNESS FOR A PARTICULAR PURPOSE.</COMMENT>
<COMMENT>#</COMMENT>
<COMMENT># The ENTIRE RISK as to the quality and performance of the software</COMMENT>
<COMMENT># IS WITH YOU (the holder of the software).  Should the software prove</COMMENT>
<COMMENT># defective, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR</COMMENT>
<COMMENT># CORRECTION.</COMMENT>
<COMMENT>#</COMMENT>
<COMMENT># IN NO EVENT WILL ANY COPYRIGHT HOLDER OR ANY OTHER PARTY WHO MAY CREATE,</COMMENT>
<COMMENT># MODIFY, OR DISTRIBUTE THE SOFTWARE BE LIABLE OR RESPONSIBLE TO YOU OR TO</COMMENT>
<COMMENT># ANY OTHER ENTITY FOR ANY KIND OF DAMAGES (no matter how awful - not even</COMMENT>
<COMMENT># if they arise from known or unknown flaws in the software).</COMMENT>
<COMMENT>##########################################################################</COMMENT>

<KEYWORD>package</KEYWORD> Sclc<OPERATOR>;</OPERATOR>

<KEYWORD>use</KEYWORD> strict<OPERATOR>;</OPERATOR>
<KEYWORD>use</KEYWORD> Config<OPERATOR>;</OPERATOR>
<KEYWORD>use</KEYWORD> <OBJ>File</OBJ><OPERATOR>::</OPERATOR><OO>Basename</OO> <DELIMITER>qw(</DELIMITER><STRING>&amp;basename</STRING> <STRING>&amp;dirname</STRING><DELIMITER>)</DELIMITER><OPERATOR>;</OPERATOR>
<KEYWORD>use</KEYWORD> <OBJ>Data</OBJ><OPERATOR>::</OPERATOR><OO>Dumper</OO><OPERATOR>;</OPERATOR>
<KEYWORD>use</KEYWORD> Cwd<OPERATOR>;</OPERATOR>

<COMMENT>## Get basename and dirname of program path</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>$Is_WinDos</VARIABLE>     <OPERATOR>=</OPERATOR> ( (<FUNCTION>uc</FUNCTION> <VARIABLE>$Config</VARIABLE>{<STRING>'osname'</STRING>}) <OPERATOR>=~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>(?:MSDOS|MSWIN|WIN32)</REGEX><DELIMITER>/</DELIMITER> )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>$Path_Sep</VARIABLE>      <OPERATOR>=</OPERATOR> ( <VARIABLE>$Is_WinDos</VARIABLE> <OPERATOR>?</OPERATOR> <STRING>"<ESC>\\</ESC>"</STRING> <OPERATOR>:</OPERATOR> <STRING>"/"</STRING> )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>$PathList_Sep</VARIABLE>  <OPERATOR>=</OPERATOR> ( <VARIABLE>$Is_WinDos</VARIABLE> <OPERATOR>?</OPERATOR> <STRING>";"</STRING> <OPERATOR>:</OPERATOR> <STRING>":"</STRING> )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> (<VARIABLE>$NAME</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$EXECDIR</VARIABLE>) <OPERATOR>=</OPERATOR> (basename(<VARIABLE>$0</VARIABLE>)<OPERATOR>,</OPERATOR> dirname(<VARIABLE>$0</VARIABLE>) <OPERATOR>||</OPERATOR> <STRING>"."</STRING>)<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>@Languages</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'Ada'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'Assembly'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'Awk'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'C'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'C++'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'Chapel'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'Eiffel'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'FORTRAN'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'Java'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'Lisp'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'Matlab'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'Mathematica'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'Pascal'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'Perl'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'PHP'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'Tcl'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'ZPL'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'shell'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'make'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'XML'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'HTML'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CSS'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'JSP'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'SQL'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'Python'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CSharp'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'Template'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'JavaScript'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'Jess'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'FlashConfig'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'FlashParameter'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'Text'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'IDL'</STRING>
  )<OPERATOR>;</OPERATOR>

<DOCCOMMENT>=head1 NAME</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>sclc -- Source-code line counter</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=head1 SYNOPSIS</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT> sclc [-delim-ignore] [-counts SPEC] [-sections SPEC] [-language [EXT=]LANG]</DOCCOMMENT>
<DOCCOMMENT>      [-name REGEXP] [-except REGEXP] [-recurse] [-filelist] [-ignore]</DOCCOMMENT>
<DOCCOMMENT>      [-diff] [-fromversion SELECTOR] [-toversion SELECTOR] [-pred]</DOCCOMMENT>
<DOCCOMMENT>      [-prefix REGEXP] [-separate REGEXP] [-vcstring STRING] [-output FILE]</DOCCOMMENT>
<DOCCOMMENT>      [-xml_output FILE] [tm3_output FILE] [-default_exclude]</DOCCOMMENT>
<DOCCOMMENT>      [-excludedir REGEXP] [-mapping FILE] [FILE ...]</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=head1 OPTIONS AND ARGUMENTS</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=over 6</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item B&lt;-help&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Print this help message and exit.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item B&lt;-language&gt; [I&lt;EXT&gt;=]I&lt;LANG&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Assume that any file with a suffix of "I&lt;EXT&gt;" is a C&lt;LANG&gt; source file</DOCCOMMENT>
<DOCCOMMENT>(note that you must supply any leading '.'). If the "I&lt;EXT&gt;" begins</DOCCOMMENT>
<DOCCOMMENT>with a slash ('/'), then the name that follows it is considered to</DOCCOMMENT>
<DOCCOMMENT>be the name of an interpreter that is invoked using "#!I&lt;path&gt;/I&lt;EXT&gt;"</DOCCOMMENT>
<DOCCOMMENT>as the first line of the script (and if the language can't be determined</DOCCOMMENT>
<DOCCOMMENT>from the extension, then the first line of the file will be used). If</DOCCOMMENT>
<DOCCOMMENT>"I&lt;EXT&gt;=" is omitted then C&lt;LANG&gt; will be the default language for any files</DOCCOMMENT>
<DOCCOMMENT>whose language cannot be determined.  C&lt;LANG&gt; must be one of the following:</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=over 3</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item S&lt;&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Ada,</DOCCOMMENT>
<DOCCOMMENT>Assembly,</DOCCOMMENT>
<DOCCOMMENT>Awk,</DOCCOMMENT>
<DOCCOMMENT>C,</DOCCOMMENT>
<DOCCOMMENT>C++,</DOCCOMMENT>
<DOCCOMMENT>Chapel,</DOCCOMMENT>
<DOCCOMMENT>CSharp,</DOCCOMMENT>
<DOCCOMMENT>CSS,</DOCCOMMENT>
<DOCCOMMENT>Eiffel,</DOCCOMMENT>
<DOCCOMMENT>FlashConfig,</DOCCOMMENT>
<DOCCOMMENT>FlashParameter,</DOCCOMMENT>
<DOCCOMMENT>FORTRAN,</DOCCOMMENT>
<DOCCOMMENT>HTML,</DOCCOMMENT>
<DOCCOMMENT>Java,</DOCCOMMENT>
<DOCCOMMENT>JavaScript,</DOCCOMMENT>
<DOCCOMMENT>Jess,</DOCCOMMENT>
<DOCCOMMENT>JSP,</DOCCOMMENT>
<DOCCOMMENT>Lisp,</DOCCOMMENT>
<DOCCOMMENT>make,</DOCCOMMENT>
<DOCCOMMENT>Matlab,</DOCCOMMENT>
<DOCCOMMENT>Pascal,</DOCCOMMENT>
<DOCCOMMENT>Perl,</DOCCOMMENT>
<DOCCOMMENT>PHP,</DOCCOMMENT>
<DOCCOMMENT>Python,</DOCCOMMENT>
<DOCCOMMENT>shell,</DOCCOMMENT>
<DOCCOMMENT>SQL,</DOCCOMMENT>
<DOCCOMMENT>Tcl,</DOCCOMMENT>
<DOCCOMMENT>Template,</DOCCOMMENT>
<DOCCOMMENT>XML,</DOCCOMMENT>
<DOCCOMMENT>ZPL,</DOCCOMMENT>
<DOCCOMMENT>Text,</DOCCOMMENT>
<DOCCOMMENT>IDL</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=back</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Language names may I&lt;not&gt; be abbreviated. This option may be specified</DOCCOMMENT>
<DOCCOMMENT>multiple times.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item B&lt;-delim-ignore&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Ignore all statement delimiters. This means that lines containing</DOCCOMMENT>
<DOCCOMMENT>nothing but statement delimiters/terminators are *not* considered</DOCCOMMENT>
<DOCCOMMENT>lines of code. For C/C++ this would have the effect of ignoring</DOCCOMMENT>
<DOCCOMMENT>lines containing nothing but ';', '{', and '}'.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item B&lt;-diff&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Treat the input as output from B&lt;diff(1)&gt; and report counts for both</DOCCOMMENT>
<DOCCOMMENT>inserted and deleted source. Note that the B&lt;-diff&gt; option is implied</DOCCOMMENT>
<DOCCOMMENT>by any of B&lt;-pred&gt;, B&lt;-fromversion&gt; or B&lt;-toversion&gt;.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item B&lt;-ignore&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Don't bother with files whose language can't be determined.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item B&lt;-filelist&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Assume that the source files to read are listed in the contents of</DOCCOMMENT>
<DOCCOMMENT>the files given on the command line (filelist is read from standard</DOCCOMMENT>
<DOCCOMMENT>input if no files are given). This is useful if you wish to use the</DOCCOMMENT>
<DOCCOMMENT>output of commands Like B&lt;find(1)&gt; as input to this command.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item B&lt;-name&gt; I&lt;REGEXP&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Only look at files whose filename (not including the directory path)</DOCCOMMENT>
<DOCCOMMENT>completely match the given perl-style regular expression. Does not</DOCCOMMENT>
<DOCCOMMENT>apply to directories when B&lt;-recurse&gt; is used. May be specified</DOCCOMMENT>
<DOCCOMMENT>multiple times (for a description of Perl's regular expression</DOCCOMMENT>
<DOCCOMMENT>syntax, invoke C&lt;man perlre&gt; or C&lt;perldoc perlre&gt;).</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item B&lt;-except&gt; I&lt;REGEXP&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Don't look at files whose filename (not including the directory path)</DOCCOMMENT>
<DOCCOMMENT>completely match the given perl-style regular expression (even if</DOCCOMMENT>
<DOCCOMMENT>it would be matched by a B&lt;-name&gt; expression). Does not apply to</DOCCOMMENT>
<DOCCOMMENT>directories when B&lt;-recurse&gt; is used. May be specified multiple</DOCCOMMENT>
<DOCCOMMENT>times  (for a description of Perl's regular expression</DOCCOMMENT>
<DOCCOMMENT>syntax, invoke C&lt;man perlre&gt; or C&lt;perldoc perlre&gt;).</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item B&lt;-prefix&gt; I&lt;REGEXP&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Ignore/strip the leading portion of each line that matches the given</DOCCOMMENT>
<DOCCOMMENT>perl-style regular expression. Do I&lt;not&gt; use a leading '^' unless you</DOCCOMMENT>
<DOCCOMMENT>mean to match the caret character itself (for a description of Perl's</DOCCOMMENT>
<DOCCOMMENT>regular expression syntax, invoke C&lt;man perlre&gt; or C&lt;perldoc perlre&gt;)</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item B&lt;-recurse&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>For every "source" file that is actually a directory, read all</DOCCOMMENT>
<DOCCOMMENT>source files in the directory.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item B&lt;-fromversion&gt; I&lt;SELECTOR&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>When used with B&lt;-diff&gt;, assumes that I&lt;SELECTOR&gt; is a valid ClearCase</DOCCOMMENT>
<DOCCOMMENT>version selector and uses it in conjunction with B&lt;cdiff&gt; as the</DOCCOMMENT>
<DOCCOMMENT>"from" version of each file specified. Only one of C&lt;-fromversion&gt;</DOCCOMMENT>
<DOCCOMMENT>and C&lt;-pred&gt; may be specified!</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item B&lt;-toversion&gt; I&lt;SELECTOR&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>When used with B&lt;-diff&gt;, assumes that I&lt;SELECTOR&gt; is a valid ClearCase</DOCCOMMENT>
<DOCCOMMENT>version selector and uses it in conjunction with B&lt;cdiff&gt; as the</DOCCOMMENT>
<DOCCOMMENT>"to" version of each file specified.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item B&lt;-pred&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>When used with B&lt;-diff&gt;, assumes that each file is an element in a</DOCCOMMENT>
<DOCCOMMENT>ClearCase VOB and uses it in conjunction with B&lt;cdiff&gt; as the "from"</DOCCOMMENT>
<DOCCOMMENT>version of each file specified (note that the predecessor version</DOCCOMMENT>
<DOCCOMMENT>is chosen relative to the "to" version of the file). Only one of</DOCCOMMENT>
<DOCCOMMENT>B&lt;-pred&gt; and B&lt;-fromversion&gt; may be specified!</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item B&lt;-separate&gt; I&lt;REGEXP&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Assume that whenever a source line is encountered that completely</DOCCOMMENT>
<DOCCOMMENT>matches the given perl-style regular expression, it indicates the</DOCCOMMENT>
<DOCCOMMENT>end of the current source context. Useful if you are trying to</DOCCOMMENT>
<DOCCOMMENT>count lines from the output of a command like B&lt;diff(1)&gt; and you</DOCCOMMENT>
<DOCCOMMENT>dont want a comment or quote in one changed section to be treated</DOCCOMMENT>
<DOCCOMMENT>as if it continued into the next block of modifications. May be</DOCCOMMENT>
<DOCCOMMENT>specified multiple times (for a description of Perl's regular expression</DOCCOMMENT>
<DOCCOMMENT>syntax, invoke C&lt;man perlre&gt; or C&lt;perldoc perlre&gt;).</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item B&lt;-counts&gt; I&lt;SPEC&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Specify which counts/columns to display in the output. I&lt;SPEC&gt;</DOCCOMMENT>
<DOCCOMMENT>may contain any of the following (separated by '+'):</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>   "Lines"  : print the total # of lines</DOCCOMMENT>
<DOCCOMMENT>   "Blank"  : print the total # of blank-lines</DOCCOMMENT>
<DOCCOMMENT>   "Cmnts"  : print the total # of comments</DOCCOMMENT>
<DOCCOMMENT>   "NCSL"   : print the total # of non-comment source lines</DOCCOMMENT>
<DOCCOMMENT>   "KPtoks" : print the total # of keyword pseudo-tokens</DOCCOMMENT>
<DOCCOMMENT>   "SPtoks" : print the total # of symbol pseudo-tokens</DOCCOMMENT>
<DOCCOMMENT>   "CPtoks" : print the total # of constant pseudo-tokens</DOCCOMMENT>
<DOCCOMMENT>   "GPtoks" : print the total # of grouping pseudo-tokens</DOCCOMMENT>
<DOCCOMMENT>   "OPtoks" : print the total # of operator pseudo-tokens</DOCCOMMENT>
<DOCCOMMENT>   "TPtoks" : print the total # of total pseudo-tokens</DOCCOMMENT>
<DOCCOMMENT>   "All"    : print all of the above totals</DOCCOMMENT>
<DOCCOMMENT>   "AESL"   : print the total # of assembly-equivalent source lines</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>The above keywords may be abbreviated to a unique prefix if desired.</DOCCOMMENT>
<DOCCOMMENT>If the B&lt;-counts&gt; option is I&lt;not&gt; specified, then</DOCCOMMENT>
<DOCCOMMENT>C&lt;Lines+Blank+Cmnts+NCSL+TPtoks&gt; is implied.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item B&lt;-sections&gt; I&lt;SPEC&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Specify the sections in the output. I&lt;SPEC&gt; may contain any</DOCCOMMENT>
<DOCCOMMENT>of the following (separated by '+'):</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>   "Header"     : the column labels and separator bar</DOCCOMMENT>
<DOCCOMMENT>   "Files"      : the counts for each input file</DOCCOMMENT>
<DOCCOMMENT>   "LangTotals" : the totals for each language encountered.</DOCCOMMENT>
<DOCCOMMENT>   "Totals"     : the totals for all files.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>The above keywords may be abbreviated to a unique prefix</DOCCOMMENT>
<DOCCOMMENT>if desired. If the B&lt;-sections&gt; option is I&lt;NOT&gt; specified,</DOCCOMMENT>
<DOCCOMMENT>then C&lt;Header+Files+LangTotals+Totals&gt; is implied.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item B&lt;-vcstring&gt; I&lt;STRING&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Specify that I&lt;STRING&gt; is the delimiter used by your version control</DOCCOMMENT>
<DOCCOMMENT>system and that the file suffix should be determined by only</DOCCOMMENT>
<DOCCOMMENT>considering the portion of the file path that precedes the first</DOCCOMMENT>
<DOCCOMMENT>occurrence of I&lt;STRING&gt;.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item B&lt;-output&gt; I&lt;FILE&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Redirect output to the named file (should have the same effect as</DOCCOMMENT>
<DOCCOMMENT>redirecting STDOUT on the cmdline using "&gt; I&lt;FILE&gt;").</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item B&lt;-xml_output&gt; I&lt;FILE&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Writes the results in XML format to the specified FILE.  Output will still be shown on the screen in addition to being in the XML file.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item B&lt;-tm3_output&gt; I&lt;FILE&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Writes the results in TM3 format to the specified FILE.  Output will still be shown on the screen in addition to being in the TM3 file.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item B&lt;-default_exclude&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Excludes a default set of files and directories using a set of regular expressions. Tries to filter out files that are commonly ignored by Ant.  Can be used with -excludedir, -name, and -except.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item B&lt;-excludedir&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Excludes files from being evaluated if their full path or file name matches the REGEXP. When used with -default_exclude it will exclude all the default plus any REGEXP given by exclude options. Each regex string needs to have its own excludedir option. There is no limit on the number of excludedirs.  Can be used with -name and -except.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item B&lt;-mapping&gt; I&lt;FILE&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Specify a mapping file to override sclc's default rules for mapping file names to programming languages. Each line of the mapping file</DOCCOMMENT>
<DOCCOMMENT>contains a regular expression and the programming language that should be associated if a file name matches the regular expression. </DOCCOMMENT>
<DOCCOMMENT>An example of the contents of a mapping file:</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>   Makefile.*   make</DOCCOMMENT>
<DOCCOMMENT>   .*\.h        FORTRAN</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=item I&lt;FILE&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Name of an input file (or a directory, if the -recurse option is specified).</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=back</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Option names are case insensitive and only a unique prefix is required.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=head1 DESCRIPTION</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>B&lt;sclc&gt; will count the number of lines, blank-lines, comments,</DOCCOMMENT>
<DOCCOMMENT>non-comment source lines (NCSL), pseudo-tokens of various types, total</DOCCOMMENT>
<DOCCOMMENT>pseudo-tokens, and optionally, assembly equivalent source lines (AESL)</DOCCOMMENT>
<DOCCOMMENT>in the given input files (which are assumed to be free of syntax</DOCCOMMENT>
<DOCCOMMENT>errors). The output format will look something like the following:</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>  &lt;header with column titles and separator line&gt;</DOCCOMMENT>
<DOCCOMMENT>  &lt;count1&gt; &lt;count2&gt; ... &lt;filename&gt;  (&lt;language&gt;)</DOCCOMMENT>
<DOCCOMMENT>    ...      ...           ...         ...</DOCCOMMENT>
<DOCCOMMENT>  &lt;total1&gt; &lt;total2&gt; ... ----- &lt;language&gt; -----  (# files)</DOCCOMMENT>
<DOCCOMMENT>    ...      ...           ...         ...</DOCCOMMENT>
<DOCCOMMENT>  &lt;total1&gt; &lt;total2&gt; ... ***** TOTAL *****  (# files)</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>The B&lt;-counts&gt; and B&lt;-sections&gt; options may be used to control which counts</DOCCOMMENT>
<DOCCOMMENT>and/or sections to print. The counts are always printed in an order such that:</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>     lines --&gt; blank-lines --&gt; comments --&gt; NCSL --&gt; &lt;xPtoks&gt;... --&gt; AESL</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>where "X --&gt; Y" means that the count of Xs always precedes the count of Ys.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>The B&lt;-recurse&gt; option can be used to specify that all files in a given directory tree should be</DOCCOMMENT>
<DOCCOMMENT>processed.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>The B&lt;-xml_output&gt; option will create a file containing the size data in XML format. </DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>The B&lt;-tm3_output&gt; option will create a file containing the size data in TM3 format. For format details, see:</DOCCOMMENT>
<DOCCOMMENT>E&lt;lt&gt;http://www.cs.umd.edu/hcil/treemap/doc4.1/create_TM3_file.htmlE&lt;gt&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>If the B&lt;-diff&gt; option is given than two lines are printed for each set of</DOCCOMMENT>
<DOCCOMMENT>counts: one for deleted lines and one for inserted lines (and the C&lt;DELETED&gt;</DOCCOMMENT>
<DOCCOMMENT>or C&lt;INSERTED&gt; keyword will appear on each output-line). If B&lt;-pred&gt; or</DOCCOMMENT>
<DOCCOMMENT>B&lt;-fromversion&gt; or B&lt;-toversion&gt; is given then B&lt;-diff&gt; is implied and B&lt;cdiff&gt;</DOCCOMMENT>
<DOCCOMMENT>command is invoked with the B&lt;-blank_ignore&gt; option to compare file versions.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=head1 EXAMPLES</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=head2 Basic Invocation</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>The most simple invocation of B&lt;sclc&gt; involves specifying the filenames explicitly on</DOCCOMMENT>
<DOCCOMMENT>the command line:</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>  $ sclc dir.c dir.h</DOCCOMMENT>
<DOCCOMMENT>   Lines  Blank  Cmnts   NCSL ... TPtoks</DOCCOMMENT>
<DOCCOMMENT>  ====== ====== ====== ====== ... ======  =============================</DOCCOMMENT>
<DOCCOMMENT>     215     26     14    158       1395  dir.c  (C)</DOCCOMMENT>
<DOCCOMMENT>      41      8     16     24        160  dir.h  (C)</DOCCOMMENT>
<DOCCOMMENT>     256     34     30    182       1555  ----- C -----  (2 files)</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Note that in Windows, you will probably invoke perl and pass SCLC as the program name as follows:</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>  C:\&gt; perl sclc dir.c dir.h</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=head2 Controlling column output</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>There are options to control which columns you do/do not want to see.</DOCCOMMENT>
<DOCCOMMENT>The C&lt;NCSL&gt; column is for "non-comment source lines". The C&lt;TPtoks&gt;</DOCCOMMENT>
<DOCCOMMENT>column gives the total number of psuedo-tokens of all types.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>The optional C&lt;AESL&gt; column is for "assembly equivalent source lines"</DOCCOMMENT>
<DOCCOMMENT>(it calculates this using assembly-equivalence factors published by</DOCCOMMENT>
<DOCCOMMENT>Software Productivity Research).</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>If all you care about is NCSL, you could simply invoke it as:</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>  $ sclc -counts ncsl dir.[ch]</DOCCOMMENT>
<DOCCOMMENT>   NCSL  </DOCCOMMENT>
<DOCCOMMENT>  =====  ==============================================================</DOCCOMMENT>
<DOCCOMMENT>    158  dir.c  (C)</DOCCOMMENT>
<DOCCOMMENT>     24  dir.h  (C)</DOCCOMMENT>
<DOCCOMMENT>    182  ----- C -----  (2 files)</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Note the use of a regular expression to specify both dir.c and dir.h.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>If you don't want the header columns, and want to see the overall totals</DOCCOMMENT>
<DOCCOMMENT>instead of the totals per programming language, then you could</DOCCOMMENT>
<DOCCOMMENT>simply say:</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>  $ sclc -counts ncsl -sections file+totals *.[ch]</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>    158  dir.c  (C)</DOCCOMMENT>
<DOCCOMMENT>     24  dir.h  (C)</DOCCOMMENT>
<DOCCOMMENT>    182  ***** TOTAL *****  (2 files)</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=head2 Recursing through subdirectories</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>In many cases, it is more convenient to direct SCLC to recurse over all subdirectories</DOCCOMMENT>
<DOCCOMMENT>of a given directory.  Use the B&lt;-recurse&gt; option to enable recursive searching. If using </DOCCOMMENT>
<DOCCOMMENT>a configuration management system such as Subversion, it is useful to also specify </DOCCOMMENT>
<DOCCOMMENT>the B&lt;-default_exclude&gt; option to avoid processing .svn subdirectories:</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>   $ sclc -recurse -default_exclude src</DOCCOMMENT>
<DOCCOMMENT>    Lines  Blank  Cmnts   NCSL TPtoks</DOCCOMMENT>
<DOCCOMMENT>   ====== ====== ====== ====== ====== ============================================</DOCCOMMENT>
<DOCCOMMENT>     2300    200    870   1284   6910 src\sclc.pl  (Perl)</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=head2 Obtaining output in XML format</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Specifying the B&lt;-xml_output&gt; option with a file name instructs SCLC to produce a file in XML output containing</DOCCOMMENT>
<DOCCOMMENT>the size data, in addition to printing it out to the console:</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>   $ sclc -recurse -default_exclude -xml_output size.xml src</DOCCOMMENT>
<DOCCOMMENT>    Lines  Blank  Cmnts   NCSL TPtoks</DOCCOMMENT>
<DOCCOMMENT>   ====== ====== ====== ====== ====== ============================================</DOCCOMMENT>
<DOCCOMMENT>     2300    200    870   1284   6910 src\sclc.pl  (Perl)</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>The command line output is the same as before, but now there is a file called size.xml containing the following:</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>   &lt;?xml version="1.0"?&gt;</DOCCOMMENT>
<DOCCOMMENT>   &lt;sclc&gt;</DOCCOMMENT>
<DOCCOMMENT>      &lt;file tool="SCLC" fileType="Perl" </DOCCOMMENT>
<DOCCOMMENT>            fileName="C:/svn-csdl/sclc/src/sclc.pl" </DOCCOMMENT>
<DOCCOMMENT>            blankLines="200" commentLines="870" sourceLines="1284" tptoks="6910" totalLines="2300"/&gt;</DOCCOMMENT>
<DOCCOMMENT>   &lt;/sclc&gt;</DOCCOMMENT>
<DOCCOMMENT>   </DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Specifying the B&lt;-tm3_output&gt; option with a file name instructs SCLC to produce a file in TM3 output containing</DOCCOMMENT>
<DOCCOMMENT>the size data, in addition to printing it out to the console:</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>   $ sclc -recurse -default_exclude -tm3_output size.tm3 src</DOCCOMMENT>
<DOCCOMMENT>    Lines  Blank  Cmnts   NCSL TPtoks</DOCCOMMENT>
<DOCCOMMENT>   ====== ====== ====== ====== ====== ============================================</DOCCOMMENT>
<DOCCOMMENT>     2300    200    870   1284   6910 src\sclc.pl  (Perl)</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>The command line output is the same as before, but now there is a file called size.tm3 containing the following:</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>    Language    Lines   Blank   Comments    SLOC    Tokens</DOCCOMMENT>
<DOCCOMMENT>    STRING      INTEGER INTEGER INTEGER     INTEGER INTEGER</DOCCOMMENT>
<DOCCOMMENT>    Perl        2300    200     870         1284    6910        src     sclc.pl</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=head2 Comparing versions using CDIFF</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>SCLC can be used in conjunction with a tool called cdiff to compare versions</DOCCOMMENT>
<DOCCOMMENT>of file stored in the ClearCase configuration management system. </DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>If you want to know the number of lines of code that have changed</DOCCOMMENT>
<DOCCOMMENT>between versions of files, you can use the B&lt;-pred&gt; option, or a</DOCCOMMENT>
<DOCCOMMENT>combination of the B&lt;-fromversion&gt; and B&lt;-toversion&gt; options. If</DOCCOMMENT>
<DOCCOMMENT>you simply want to know the number of new and changed lines of code</DOCCOMMENT>
<DOCCOMMENT>between a set of files and their immediate predecessors, use the B&lt;-pred&gt;</DOCCOMMENT>
<DOCCOMMENT>option:</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>  $ sclc -pred *.[ch]</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>  Lines  Blank  Cmnts   NCSL   AESL     </DOCCOMMENT>
<DOCCOMMENT>  =====  =====  =====  =====   ====  ===============================</DOCCOMMENT>
<DOCCOMMENT>      3      1      0      2    5.0  dir.c DELETED  (C)</DOCCOMMENT>
<DOCCOMMENT>      5      1      0      4   10.0  dir.c INSERTED  (C)</DOCCOMMENT>
<DOCCOMMENT>      1      0      0      1    2.5  dir.h DELETED  (C)</DOCCOMMENT>
<DOCCOMMENT>      2      0      0      2    5.0  dir.h INSERTED  (C)</DOCCOMMENT>
<DOCCOMMENT>      4      1      0      3    7.5  ----- C DELETED -----  (2 files)</DOCCOMMENT>
<DOCCOMMENT>      7      1      0      6   15.0  ----- C INSERTED -----  (2 files)</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Again, if you want to limit the output to include only the NCSL counts for</DOCCOMMENT>
<DOCCOMMENT>the individual files and their totals, add the B&lt;-counts&gt; and B&lt;-sections&gt;</DOCCOMMENT>
<DOCCOMMENT>options into the fold:</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>  $ sclc -pred -counts ncsl -sections file+totals *.[ch]</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>      2  dir.c DELETED  (C)</DOCCOMMENT>
<DOCCOMMENT>      4  dir.c INSERTED  (C)</DOCCOMMENT>
<DOCCOMMENT>      1  dir.h DELETED  (C)</DOCCOMMENT>
<DOCCOMMENT>      2  dir.h INSERTED  (C)</DOCCOMMENT>
<DOCCOMMENT>      3  ***** TOTAL DELETED *****  (2 files)</DOCCOMMENT>
<DOCCOMMENT>      6  ***** TOTAL INSERTED *****  (2 files)</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>If you want to count the difference in source lines between specific</DOCCOMMENT>
<DOCCOMMENT>versions (not just the predecessor) you may use the B&lt;-fromversion&gt;</DOCCOMMENT>
<DOCCOMMENT>option to specify the base ("from") version to use for all comparisons.</DOCCOMMENT>
<DOCCOMMENT>If the base version is not explicitly specified, it defaults to whatever</DOCCOMMENT>
<DOCCOMMENT>version is selected in the users view. Similarly, the B&lt;-toversion&gt;</DOCCOMMENT>
<DOCCOMMENT>option may be used to specify the target ("to") version to use for all</DOCCOMMENT>
<DOCCOMMENT>comparisons. If the target version is not specified, then (like the base</DOCCOMMENT>
<DOCCOMMENT>version) it defaults to whatever version is selected in the users view.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>So if I want to count the changed lines of code between what is in my</DOCCOMMENT>
<DOCCOMMENT>view and what was on the C&lt;REL1.0.0&gt; label, I would do the following:</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>  $ sclc -fromver REL1.0.0 *.[ch]</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>And if I wanted to count the changed lines of code between files on</DOCCOMMENT>
<DOCCOMMENT>my C&lt;/main/rel1/mychanges&gt; branch and the REL1.0.0 baseline label they</DOCCOMMENT>
<DOCCOMMENT>where branched off from, I would use:</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>  $ sclc -fromver REL1.0.0 -tover .../mychanges/LATEST *.[ch]</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>If I wanted to see the difference in lines of code for files on to</DOCCOMMENT>
<DOCCOMMENT>different labels I would do something like:</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>  $ sclc -fromver REL1.0.0 -tover REL2.0.0 *.[ch]</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>If I wanted to do the same as the above, but my view was already selecting</DOCCOMMENT>
<DOCCOMMENT>everything in the REL1.0.0 baseline, then I could simply do:</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>  $ sclc -tover REL2.0.0 *.[ch]</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Hopefully, this "tutorial" should have provided you with a good set of</DOCCOMMENT>
<DOCCOMMENT>cookbook examples for using B&lt;sclc&gt;. if you ever want to see this manual</DOCCOMMENT>
<DOCCOMMENT>page, you need only invoke B&lt;sclc&gt; using the B&lt;-help&gt; option:</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>  $ sclc -help</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=head1 MPI AND OPENMP TOKEN COUNTING</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>MPI and OpenMP token counting is automatically done for C/C++ and FORTRAN files.  It is not displayed on the screen and the results can only be seen if the option B&lt;-xml_output&gt; is used.  In the XML, the name of the token will be an attribute and the value of the attribute will be the number occurrences of that token (Example: MPI_Init="1").</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=head1 KNOWN ISSUES</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Please note that files with line breaks that are \r (carriage return) used by Mac classic may not work properly.  Converting these to Windows or Unix type line breaks will fix the problem.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=head1 HOME PAGE</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>This University of Hawaii Edition of SCLC is maintained at: E&lt;lt&gt;http://sclc.googlecode.com/E&lt;gt&gt;.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=head1 SEE ALSO</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>cdiff -- B&lt;sclc&gt; uses B&lt;cdiff&gt; to compare versions of files. The home page for cdiff (and</DOCCOMMENT>
<DOCCOMMENT>the original version of SCLC) is at: E&lt;lt&gt;http://www.cmcrossroads.com/bradapp/clearperl/sclc-cdiff.htmlE&lt;gt&gt;.</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=head1 AUTHORS</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>Original author: Brad Appleton  E&lt;lt&gt;bradapp@computer.orgE&lt;gt&gt;</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>University of Hawaii Edition enhancements by: </DOCCOMMENT>
<DOCCOMMENT>Cedric Zhang  E&lt;lt&gt;qzhang@hawaii.eduE&lt;gt&gt;,</DOCCOMMENT>
<DOCCOMMENT>Julie Sakuda  E&lt;lt&gt;jsakuda@hawaii.eduE&lt;gt&gt;, </DOCCOMMENT>
<DOCCOMMENT>Mike Paulding  E&lt;lt&gt;mpauldin@hawaii.eduE&lt;gt&gt;, and </DOCCOMMENT>
<DOCCOMMENT>Philip Johnson  E&lt;lt&gt;johnson@hawaii.eduE&lt;gt&gt;,</DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT></DOCCOMMENT>
<DOCCOMMENT>=cut</DOCCOMMENT>

<COMMENT>## Globals (yuck!)</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>%OPTS</VARIABLE>   <OPERATOR>=</OPERATOR> ()<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%CNTS</VARIABLE>   <OPERATOR>=</OPERATOR> ()<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%Totals</VARIABLE> <OPERATOR>=</OPERATOR> ()<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%SECS</VARIABLE>   <OPERATOR>=</OPERATOR> ()<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>$ERRORS</VARIABLE> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%KIND</VARIABLE>   <OPERATOR>=</OPERATOR> ()<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>$DEFAULT_LANG</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>""</STRING><OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>$LANG_NAME</VARIABLE>    <OPERATOR>=</OPERATOR> <STRING>""</STRING><OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>$LANG_REF</VARIABLE>     <OPERATOR>=</OPERATOR> <STRING>""</STRING><OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%LANG_RULES</VARIABLE>   <OPERATOR>=</OPERATOR> ()<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>$NumSources</VARIABLE>   <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%NumSources</VARIABLE>   <OPERATOR>=</OPERATOR> ()<OPERATOR>;</OPERATOR>

<COMMENT>## Count names</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>@Count_Names</VARIABLE> <OPERATOR>=</OPERATOR>
  <DELIMITER>qw(</DELIMITER><STRING>Lines</STRING> <STRING>Blank</STRING> <STRING>Cmnts</STRING> <STRING>NCSL</STRING> <STRING>KPtoks</STRING> <STRING>SPtoks</STRING> <STRING>CPtoks</STRING> <STRING>GPtoks</STRING> <STRING>OPtoks</STRING> <STRING>TPtoks</STRING> <STRING>AESL</STRING><DELIMITER>)</DELIMITER><OPERATOR>;</OPERATOR>

<COMMENT>## J. Sakuda added for XML::Simple migration</COMMENT>
<COMMENT>## Holds mappings of file elements and their attributes</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>@fileElementArray</VARIABLE> <OPERATOR>=</OPERATOR> ()<OPERATOR>;</OPERATOR>

<COMMENT>## J. Sakuda added for modified ExcludeFile function</COMMENT>
<COMMENT>## Default excludes based on Ant's exclude regex set</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>@EXCLUDES</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'<ESC>\S</ESC>*[<ESC>\\</ESC><ESC>\|</ESC>/].svn[<ESC>\\</ESC><ESC>\|</ESC>/]<ESC>\S</ESC>*'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\S</ESC>*[<ESC>\\</ESC><ESC>\|</ESC>/].git[<ESC>\\</ESC><ESC>\|</ESC>/]<ESC>\S</ESC>*'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\S</ESC>*CVS<ESC>\S</ESC>*'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\w</ESC>*.cvsignore'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\w</ESC>*.DS_Store'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\w</ESC>*~'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\w</ESC>*#<ESC>\w</ESC>*#'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\w</ESC>*.#<ESC>\w</ESC>*'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\w</ESC>*%<ESC>\w</ESC>*%'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\w</ESC>*SCCS<ESC>\w</ESC>*'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\w</ESC>*vssver.scc'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\w</ESC>*._<ESC>\w</ESC>*$'</STRING>)<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## DESIGN:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## [ Okay listen up and listen good. Here is the strategy we use ... ]</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## Basically, foreach language we "know" we only care about the following:</COMMENT>
<COMMENT>##   - comments (ones that are delimited and ones that continue to end-of-line)</COMMENT>
<COMMENT>##   - quotations</COMMENT>
<COMMENT>##   - statement-terminators</COMMENT>
<COMMENT>##   - block-statement terminators</COMMENT>
<COMMENT>##   - pseudo-tokens</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## Therefore for each language, we need to know which characters to pay</COMMENT>
<COMMENT>## attention to if we are inside a comment, quotations, or neither. Hence</COMMENT>
<COMMENT>## we will use two arrays for each language:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>##   1) An array of substitutions to perform any necessary preprocessing</COMMENT>
<COMMENT>##      for this particular language. We need this to do things like</COMMENT>
<COMMENT>##      editing potentially confusing constructs (like replacing the keyword</COMMENT>
<COMMENT>##      'end' with a single token that is the same regardless of case, or</COMMENT>
<COMMENT>##      to deal with things like substitutions and variable names in perl).</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>##   2) An associative with the following keys:</COMMENT>
<COMMENT>##         $Array{'AESL'} -- Assembly Equivalent multiplier for determining</COMMENT>
<COMMENT>##                           AESL from NCSL. These values are obtained from</COMMENT>
<COMMENT>##                           the Programming Language Tables at Capers Jones'</COMMENT>
<COMMENT>##                           Software Productivity Research, Inc. from the</COMMENT>
<COMMENT>##                           URL http://www.spr.com/library/langtbl.htm</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>##         $Array{'START_STATE'} -- A regular expression that will match</COMMENT>
<COMMENT>##            only the tokens I am interested in if I am not inside a</COMMENT>
<COMMENT>##            comment or a quotation.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>##         $Array{'CMMNT_STATE'} -- A regular expression that will match</COMMENT>
<COMMENT>##            only the tokens I am interested in if I am inside a comment</COMMENT>
<COMMENT>##            whose end is delimited by something other than a newline</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>##         $Array{'CMMNT_NESTING'} -- true or false, depending on whether</COMMENT>
<COMMENT>##            or not comments are allowed to nest.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>##         $Array{'&lt;token&gt;QUOTE_STATE'} -- A regular expression that will</COMMENT>
<COMMENT>##            match only the tokens I am interested in if I am inside a</COMMENT>
<COMMENT>##            quoted context whose beginning was denoted by &lt;token&gt;.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>##         $Array{END_&lt;token&gt;} -- The string/character that corresponds to the</COMMENT>
<COMMENT>##            end of a quoted context whose beginning was denoted by &lt;token&gt;.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>##         $Array{&lt;token&gt;} -- This should be one of the following predefined</COMMENT>
<COMMENT>##            constants:</COMMENT>
<COMMENT>##</COMMENT>
<KEYWORD>my</KEYWORD> (<VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>    <COMMENT>## A comment that continues until end-of-line</COMMENT>
    <VARIABLE>$BeginCmnt</VARIABLE><OPERATOR>,</OPERATOR>  <COMMENT>## Beginning of a delimited comment</COMMENT>
    <VARIABLE>$EndCmnt</VARIABLE><OPERATOR>,</OPERATOR>    <COMMENT>## End of a delimited comment</COMMENT>
    <VARIABLE>$BeginQuote</VARIABLE>) <COMMENT>## The beginning of a quoted/literal context</COMMENT>
  <OPERATOR>=</OPERATOR> (<NUMERIC>1</NUMERIC><OPERATOR>,</OPERATOR> <NUMERIC>2</NUMERIC><OPERATOR>,</OPERATOR> <NUMERIC>3</NUMERIC><OPERATOR>,</OPERATOR> <NUMERIC>4</NUMERIC>)<OPERATOR>;</OPERATOR>
<COMMENT>##</COMMENT>
<COMMENT>##            For each &lt;token&gt; that we will ever match, $Array{&lt;token&gt;}</COMMENT>
<COMMENT>##            will yield the token type (its semantic meaning).</COMMENT>
<COMMENT>##</COMMENT>

<COMMENT>## Need the following array for when the LANG_DEFNS array has to correspond</COMMENT>
<COMMENT>## to more than one language with a different AESL multiplier for each. The</COMMENT>
<COMMENT>## Index should be the LANG_NAME.</COMMENT>
<COMMENT>##</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>%AssemblyEquivalence</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'C++'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>6.0</NUMERIC>)<OPERATOR>;</OPERATOR>

<COMMENT>## We use these defaults if no value is specified for a particular language.</COMMENT>
<COMMENT>## Be wary of changing these defaults, but feel free to override them.</COMMENT>
<COMMENT>## For reference, all ASCII operators: [~`!\@#\$%^&amp;*_\-+=|\\\\:\'"&lt;&gt;.?/]</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>%DEFAULT_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'KEYWORD'</STRING><OPERATOR>,</OPERATOR> <STRING>'0'</STRING><OPERATOR>,</OPERATOR> <COMMENT># no keywords specified</COMMENT>
    <STRING>'SYMBOL'</STRING><OPERATOR>,</OPERATOR> <STRING>'[a-zA-Z]<ESC>\w</ESC>*'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'NUMBER'</STRING><OPERATOR>,</OPERATOR> <STRING>'(?=<ESC>\.</ESC>?<ESC>\d</ESC>)[<ESC>\d</ESC>_]*(?:<ESC>\.</ESC>[<ESC>\d</ESC>_]*)?(?:[a-zA-Z][-+]?<ESC>\d</ESC>)?<ESC>\w</ESC>*'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'GROUPER'</STRING><OPERATOR>,</OPERATOR> <STRING>'[(){}[<ESC>\]</ESC>,;]'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'OPERATOR'</STRING><OPERATOR>,</OPERATOR> <STRING>'(.)<ESC>\1</ESC>*=?'</STRING><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<COMMENT>##</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>

<DOCCOMMENT>### BEGIN LANGUAGE DEFINITIONS ###</DOCCOMMENT>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## Assembly language definitions</COMMENT>
<COMMENT>##   <COMMENT_NOTE>NOTE:</COMMENT_NOTE> these are pretty generic and may not work for all assembly languages</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>@ASSEMBLY_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'s/^<ESC>\s</ESC>*<ESC>\*</ESC>/;/'</STRING>)<OPERATOR>;</OPERATOR>  <COMMENT>## Treat '*' at beginning as a comment</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>%ASSEMBLY_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>1.0</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>";"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>""</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_NESTING'</STRING><OPERATOR>,</OPERATOR> <STRING>""</STRING><OPERATOR>,</OPERATOR>
    <STRING>';'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'ASSEMBLY'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@ASSEMBLY_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>ASSEMBLY_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## C/C++ language definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>%C_KEYWORDS</VARIABLE><OPERATOR>;</OPERATOR>
<VARIABLE>@C_KEYWORDS</VARIABLE>{            <COMMENT># standard C</COMMENT>
    <DELIMITER>qw(</DELIMITER><STRING>define</STRING> <STRING>defined</STRING> <STRING>error</STRING> <STRING>ifdef</STRING> <STRING>if</STRING> <STRING>elif</STRING> <STRING>else</STRING> <STRING>endif</STRING> <STRING>include</STRING> <STRING>undef</STRING>
      <STRING>auto</STRING> <STRING>break</STRING> <STRING>case</STRING> <STRING>char</STRING> <STRING>const</STRING> <STRING>continue</STRING>
      <STRING>default</STRING> <STRING>do</STRING> <STRING>double</STRING> <STRING>else</STRING> <STRING>enum</STRING> <STRING>extern</STRING>
      <STRING>float</STRING> <STRING>for</STRING> <STRING>goto</STRING> <STRING>if</STRING> <STRING>int</STRING> <STRING>long</STRING> <STRING>register</STRING> <STRING>return</STRING>
      <STRING>short</STRING> <STRING>signed</STRING> <STRING>sizeof</STRING> <STRING>static</STRING> <STRING>struct</STRING> <STRING>switch</STRING>
      <STRING>typedef</STRING> <STRING>union</STRING> <STRING>unsigned</STRING> <STRING>void</STRING> <STRING>volatile</STRING> <STRING>while</STRING><DELIMITER>)</DELIMITER>} <OPERATOR>=</OPERATOR> <KEYWORD>undef</KEYWORD><OPERATOR>;</OPERATOR>
<VARIABLE>@C_KEYWORDS</VARIABLE>{            <COMMENT># C++ extensions</COMMENT>
    <DELIMITER>qw(</DELIMITER><STRING>asm</STRING> <STRING>bool</STRING> <STRING>catch</STRING> <STRING>class</STRING> <STRING>const_cast</STRING>
      <STRING>delete</STRING> <STRING>dynamic_cast</STRING> <STRING>explicit</STRING>
      <STRING>false</STRING> <STRING>friend</STRING> <STRING>inline</STRING> <STRING>mutable</STRING>
      <STRING>namespace</STRING> <STRING>new</STRING> <STRING>operator</STRING> <STRING>private</STRING>
      <STRING>protected</STRING> <STRING>public</STRING> <STRING>reinterpret_cast</STRING>
      <STRING>static_cast</STRING> <STRING>template</STRING> <STRING>this</STRING> <STRING>throw</STRING>
      <STRING>true</STRING> <STRING>try</STRING> <STRING>typeid</STRING> <STRING>typename</STRING> <STRING>using</STRING>
      <STRING>virtual</STRING> <STRING>wchar_t</STRING><DELIMITER>)</DELIMITER>} <OPERATOR>=</OPERATOR> <KEYWORD>undef</KEYWORD><OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>@C_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'s/[{};]/ /g  if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%C_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>2.5</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'/[*/]|["<ESC>\'</ESC>]'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\*</ESC>/'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_NESTING'</STRING><OPERATOR>,</OPERATOR> <STRING>""</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC><ESC>\\</ESC>.|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'//'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'/*'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'*/'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EndCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'KEYWORD'</STRING><OPERATOR>,</OPERATOR> <STRING>'exists $C_KEYWORDS{$1}'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'SYMBOL'</STRING><OPERATOR>,</OPERATOR> <STRING>'[<ESC>\$</ESC>_a-zA-Z][<ESC>\$</ESC><ESC>\w</ESC>]*'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'OPERATOR'</STRING><OPERATOR>,</OPERATOR> <STRING>'-&gt;|(.)<ESC>\1</ESC>*=?'</STRING><OPERATOR>,</OPERATOR> <COMMENT># add -&gt;</COMMENT>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'C'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@C_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>C_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## Java language definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>%JAVA_KEYWORDS</VARIABLE><OPERATOR>;</OPERATOR>
<VARIABLE>@JAVA_KEYWORDS</VARIABLE>{
    <DELIMITER>qw(</DELIMITER><STRING>abstract</STRING> <STRING>boolean</STRING> <STRING>break</STRING> <STRING>byte</STRING> <STRING>case</STRING>
      <STRING>catch</STRING> <STRING>char</STRING> <STRING>class</STRING> <STRING>const</STRING> <STRING>continue</STRING>
      <STRING>default</STRING> <STRING>do</STRING> <STRING>double</STRING> <STRING>else</STRING> <STRING>extends</STRING>
      <STRING>false</STRING> <STRING>final</STRING> <STRING>finally</STRING> <STRING>float</STRING> <STRING>for</STRING>
      <STRING>goto</STRING> <STRING>if</STRING> <STRING>implements</STRING> <STRING>import</STRING> <STRING>instanceof</STRING>
      <STRING>int</STRING> <STRING>interface</STRING> <STRING>long</STRING> <STRING>native</STRING> <STRING>new</STRING> <STRING>null</STRING>
      <STRING>package</STRING> <STRING>private</STRING> <STRING>protected</STRING> <STRING>public</STRING>
      <STRING>return</STRING> <STRING>short</STRING> <STRING>static</STRING> <STRING>super</STRING> <STRING>switch</STRING>
      <STRING>synchronized</STRING> <STRING>this</STRING> <STRING>throw</STRING> <STRING>throws</STRING>
      <STRING>transient</STRING> <STRING>true</STRING> <STRING>try</STRING> <STRING>void</STRING> <STRING>volatile</STRING> <STRING>while</STRING><DELIMITER>)</DELIMITER>} <OPERATOR>=</OPERATOR> <KEYWORD>undef</KEYWORD><OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>@JAVA_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'s/[{};]/ /g  if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%JAVA_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>6</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'/[*/]|["<ESC>\'</ESC>]'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC>*/'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_NESTING'</STRING><OPERATOR>,</OPERATOR> <STRING>""</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC><ESC>\\</ESC>.|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'//'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'/*'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'*/'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EndCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'KEYWORD'</STRING><OPERATOR>,</OPERATOR> <STRING>'exists $JAVA_KEYWORDS{$1}'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'SYMBOL'</STRING><OPERATOR>,</OPERATOR> <STRING>'[<ESC>\$</ESC>_a-zA-Z][<ESC>\$</ESC><ESC>\w</ESC>]*'</STRING><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'JAVA'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@JAVA_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>JAVA_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## PHP language definitions</COMMENT>
<COMMENT>## I don't know PHP, so I will define it like Java and hope it works.</COMMENT>

<KEYWORD>my</KEYWORD> <VARIABLE>%PHP_KEYWORDS</VARIABLE><OPERATOR>;</OPERATOR>
<VARIABLE>@PHP_KEYWORDS</VARIABLE>{
    <DELIMITER>qw(</DELIMITER><STRING>abstract</STRING> <STRING>boolean</STRING> <STRING>break</STRING> <STRING>byte</STRING> <STRING>case</STRING>
      <STRING>catch</STRING> <STRING>char</STRING> <STRING>class</STRING> <STRING>const</STRING> <STRING>continue</STRING>
      <STRING>default</STRING> <STRING>do</STRING> <STRING>double</STRING> <STRING>else</STRING> <STRING>extends</STRING>
      <STRING>false</STRING> <STRING>final</STRING> <STRING>finally</STRING> <STRING>float</STRING> <STRING>for</STRING>
      <STRING>goto</STRING> <STRING>if</STRING> <STRING>implements</STRING> <STRING>import</STRING> <STRING>instanceof</STRING>
      <STRING>int</STRING> <STRING>interface</STRING> <STRING>long</STRING> <STRING>native</STRING> <STRING>new</STRING> <STRING>null</STRING>
      <STRING>package</STRING> <STRING>private</STRING> <STRING>protected</STRING> <STRING>public</STRING>
      <STRING>return</STRING> <STRING>short</STRING> <STRING>static</STRING> <STRING>super</STRING> <STRING>switch</STRING>
      <STRING>synchronized</STRING> <STRING>this</STRING> <STRING>throw</STRING> <STRING>throws</STRING>
      <STRING>transient</STRING> <STRING>true</STRING> <STRING>try</STRING> <STRING>void</STRING> <STRING>volatile</STRING> <STRING>while</STRING><DELIMITER>)</DELIMITER>} <OPERATOR>=</OPERATOR> <KEYWORD>undef</KEYWORD><OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>@PHP_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'s/[{};]/ /g  if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%PHP_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>6</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'/[*/]|["<ESC>\'</ESC>]'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC>*/'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_NESTING'</STRING><OPERATOR>,</OPERATOR> <STRING>""</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC><ESC>\\</ESC>.|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'//'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'/*'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'*/'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EndCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'KEYWORD'</STRING><OPERATOR>,</OPERATOR> <STRING>'exists $PHP_KEYWORDS{$1}'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'SYMBOL'</STRING><OPERATOR>,</OPERATOR> <STRING>'[<ESC>\$</ESC>_a-zA-Z][<ESC>\$</ESC><ESC>\w</ESC>]*'</STRING><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'PHP'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@PHP_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>PHP_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## Shell language definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>%SHELL_KEYWORDS</VARIABLE><OPERATOR>;</OPERATOR>
<VARIABLE>@SHELL_KEYWORDS</VARIABLE>{
    <DELIMITER>qw(</DELIMITER><STRING>alias</STRING> <STRING>case</STRING> <STRING>in</STRING> <STRING>esac</STRING> <STRING>do</STRING> <STRING>done</STRING> <STRING>od</STRING>
      <STRING>eval</STRING> <STRING>exec</STRING> <STRING>exit</STRING> <STRING>export</STRING>
      <STRING>for</STRING> <STRING>function</STRING> <STRING>return</STRING>
      <STRING>if</STRING> <STRING>test</STRING> <STRING>then</STRING> <STRING>else</STRING> <STRING>fi</STRING>
      <STRING>set</STRING> <STRING>unset</STRING> <STRING>shift</STRING> <STRING>shopt</STRING> <STRING>trap</STRING> <STRING>umask</STRING>
      <STRING>while</STRING> <STRING>break</STRING> <STRING>continue</STRING>
      <STRING>until</STRING> <STRING>wait</STRING><DELIMITER>)</DELIMITER>} <OPERATOR>=</OPERATOR> <KEYWORD>undef</KEYWORD><OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>@SHELL_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'s/(^|<ESC>\s</ESC>+)#/<ESC>\001</ESC>/g'</STRING><OPERATOR>,</OPERATOR>   <COMMENT>## denote '#' comments with \001</COMMENT>
    <STRING>'s/<ESC>\\</ESC><ESC>\\</ESC>./__/g'</STRING><OPERATOR>,</OPERATOR>        <COMMENT>## remove escaped characters</COMMENT>
    <STRING>'s/[(){}[<ESC>\]</ESC>;]/ /g  if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%SHELL_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING>         <OPERATOR>=&gt;</OPERATOR> <NUMERIC>15.0</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING>  <OPERATOR>=&gt;</OPERATOR><STRING>"[<ESC>\001</ESC>`<ESC>\"</ESC>']"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>'<ESC>\\</ESC><ESC>\\</ESC>.|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING>        <OPERATOR>=&gt;</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING>        <OPERATOR>=&gt;</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"`QUOTE_STATE"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|`"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_`"</STRING>        <OPERATOR>=&gt;</OPERATOR> <STRING>"`"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"<ESC>\001</ESC>"</STRING>         <OPERATOR>=&gt;</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING>            <OPERATOR>=&gt;</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING>            <OPERATOR>=&gt;</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'`'</STRING>            <OPERATOR>=&gt;</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'KEYWORD'</STRING>      <OPERATOR>=&gt;</OPERATOR> <STRING>'exists $SHELL_KEYWORDS{$1}'</STRING><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'SHELL'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@SHELL_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>SHELL_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## Make language definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>@MAKE_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'s/^<ESC>\s</ESC>*#/<ESC>\001</ESC>/g'</STRING><OPERATOR>,</OPERATOR>    <COMMENT>## denote '#' comments with \001</COMMENT>
    <STRING>'s/[(){};]/ /g  if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%MAKE_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>15.0</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR><STRING>"[<ESC>\001</ESC>`<ESC>\"</ESC>']"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC><ESC>\\</ESC>.|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"`QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|`"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_`"</STRING><OPERATOR>,</OPERATOR> <STRING>"`"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"<ESC>\001</ESC>"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'`'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'MAKE'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@MAKE_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>MAKE_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## Awk language definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>@AWK_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'s/(^|<ESC>\s</ESC>+)#/<ESC>\001</ESC>/g'</STRING><OPERATOR>,</OPERATOR>   <COMMENT>## denote '#' comments with \001</COMMENT>
    <STRING>'s/<ESC>\\</ESC><ESC>\\</ESC>./__/g'</STRING><OPERATOR>,</OPERATOR>        <COMMENT>## remove escaped characters</COMMENT>
    <STRING>'s/[{};]/ /g  if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%AWK_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>15.0</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR><STRING>"[<ESC>\001</ESC><ESC>\"</ESC>']"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC><ESC>\\</ESC>.|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"<ESC>\001</ESC>"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'AWK'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@AWK_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>AWK_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## Tcl language definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>@TCL_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'s/(^|<ESC>\s</ESC>+)#/<ESC>\001</ESC>/g'</STRING><OPERATOR>,</OPERATOR>   <COMMENT>## denote '#' comments with \001</COMMENT>
    <STRING>'s/<ESC>\\</ESC><ESC>\\</ESC>./__/g'</STRING><OPERATOR>,</OPERATOR>        <COMMENT>## remove escaped characters</COMMENT>
    <STRING>'s/[[<ESC>\]</ESC>{};]/ /g  if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%TCL_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>5.0</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR><STRING>"[<ESC>\001</ESC>`<ESC>\"</ESC>']"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC><ESC>\\</ESC>.|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"`QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|`"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_`"</STRING><OPERATOR>,</OPERATOR> <STRING>"`"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"<ESC>\001</ESC>"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'`'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'TCL'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@TCL_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>TCL_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## Perl language definitions</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>##    <COMMENT_NOTE>NOTE:</COMMENT_NOTE> I tried to put in some substitutions and definitions to treat</COMMENT>
<COMMENT>##          stuff between quotes (double and single) and between slashes</COMMENT>
<COMMENT>##          (for matches *and* substitutions) as literals, but it is too</COMMENT>
<COMMENT>##          complex to get it all right.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>##    [A second try, by Bill Mann.]</COMMENT>
<COMMENT>##    This works best if the perl source follows some rules:</COMMENT>
<COMMENT>##       Put at least one space between code and comments</COMMENT>
<COMMENT>##       Backslash-quote #,',",` when used in regexp,q,qq,qx,qw,&lt;&lt;</COMMENT>
<COMMENT>##</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>@PERL_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'s/<ESC>\\</ESC><ESC>\\</ESC>./__/g;'</STRING><OPERATOR>,</OPERATOR>       <COMMENT>## remove escaped characters</COMMENT>
    <STRING>'s/<ESC>\$</ESC>[<ESC>\'</ESC>"`#]/<ESC>\$</ESC>_/g;'</STRING><OPERATOR>,</OPERATOR>  <COMMENT>## avoid special symbol problems</COMMENT>
    <STRING>'s/(^|<ESC>\s</ESC>+)#/<ESC>\001</ESC>/g'</STRING><OPERATOR>,</OPERATOR>   <COMMENT>## denote '#' comments with \001</COMMENT>
    <STRING>'s/^=cut/<ESC>\003</ESC>/g'</STRING><OPERATOR>,</OPERATOR>      <COMMENT>## end pod comments with \003</COMMENT>
    <STRING>'s/^=[a-z]+/<ESC>\002</ESC>/g'</STRING><OPERATOR>,</OPERATOR>   <COMMENT>##   and start them with \002</COMMENT>
    <STRING>'s/[{};]/ /g  if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%PERL_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>15.0</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>"['<ESC>\"</ESC>`]|[<ESC>\001</ESC><ESC>\002</ESC>]"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>"^<ESC>\003</ESC>"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_NESTING'</STRING><OPERATOR>,</OPERATOR> <STRING>""</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"`QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"`"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_`"</STRING><OPERATOR>,</OPERATOR> <STRING>"`"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'`'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"<ESC>\001</ESC>"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"<ESC>\002</ESC>"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"<ESC>\003</ESC>"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EndCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'KEYWORD'</STRING><OPERATOR>,</OPERATOR> <STRING>'$1 =~ /^[a-z]/'</STRING><OPERATOR>,</OPERATOR> <COMMENT># any symbol in lowercase</COMMENT>
    <STRING>'SYMBOL'</STRING><OPERATOR>,</OPERATOR> <STRING>'(?i)[$@%][^<ESC>\s</ESC>a-z]|[$@%&amp;]?[a-z_]<ESC>\w</ESC>*'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'OPERATOR'</STRING><OPERATOR>,</OPERATOR> <STRING>'&lt;=&gt;|-&gt;|=&gt;|=~|!~|<ESC>\?</ESC>:|(.)<ESC>\1</ESC>*=?'</STRING><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'PERL'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@PERL_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>PERL_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## Ada language definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>@ADA_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>"s/';'//g"</STRING><OPERATOR>,</OPERATOR>  <COMMENT>## the only single-quote we need to worry about</COMMENT>
    <STRING>'s/<ESC>\b</ESC>(?:begin|end|is)<ESC>\b</ESC>|;/ /gi  if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%ADA_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>6.5</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR><STRING>"[<ESC>\"</ESC>]|--"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>""</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_NESTING'</STRING><OPERATOR>,</OPERATOR> <STRING>""</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'""|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"--"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'ADA'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@ADA_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>ADA_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## Eiffel language definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>@EIFFEL_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'s/<ESC>\b</ESC>(?:end|is)<ESC>\b</ESC>|;/ /gi  if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%EIFFEL_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>15.0</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR><STRING>"[<ESC>\"</ESC>']|--"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>""</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_NESTING'</STRING><OPERATOR>,</OPERATOR> <STRING>""</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'%"|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>'%[%"]|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"--"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'EIFFEL'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@EIFFEL_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>EIFFEL_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## Pascal language definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>@PASCAL_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'s/<ESC>\b</ESC>(?:begin|end)<ESC>\b</ESC>|;/ /gi  if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%PASCAL_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>3.5</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR><STRING>"[']|{|<ESC>\\</ESC>(<ESC>\\</ESC>*"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'}|<ESC>\*</ESC><ESC>\)</ESC>'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_NESTING'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>1</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"''|'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'(*'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'*)'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EndCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'{'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'}'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EndCmnt</VARIABLE><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'PASCAL'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@PASCAL_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>PASCAL_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## Lisp language definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>%LISP_KEYWORDS</VARIABLE><OPERATOR>;</OPERATOR>
<VARIABLE>@LISP_KEYWORDS</VARIABLE>{
    <DELIMITER>qw(</DELIMITER><STRING>and</STRING> <STRING>append</STRING> <STRING>boundp</STRING> <STRING>car</STRING> <STRING>catch</STRING>
      <STRING>cdr</STRING> <STRING>concat</STRING> <STRING>cond</STRING> <STRING>cons</STRING> <STRING>defun</STRING> <STRING>defvar</STRING>
      <STRING>eq</STRING> <STRING>equal</STRING> <STRING>error</STRING> <STRING>eval</STRING> <STRING>fboundp</STRING> <STRING>get</STRING>
      <STRING>if</STRING> <STRING>lambda</STRING> <STRING>let</STRING> <STRING>list</STRING> <STRING>load</STRING> <STRING>map</STRING> <STRING>mapcar</STRING>
      <STRING>member</STRING> <STRING>memq</STRING> <STRING>nconc</STRING> <STRING>nil</STRING> <STRING>not</STRING> <STRING>or</STRING>
      <STRING>prin1</STRING> <STRING>princ</STRING> <STRING>prog</STRING> <STRING>progn</STRING> <STRING>put</STRING> <STRING>quote</STRING>
      <STRING>reverse</STRING> <STRING>set</STRING> <STRING>setq</STRING> <STRING>t</STRING> <STRING>throw</STRING> <STRING>unless</STRING>
      <STRING>when</STRING> <STRING>while</STRING> <STRING>zerop</STRING><DELIMITER>)</DELIMITER>} <OPERATOR>=</OPERATOR> <KEYWORD>undef</KEYWORD><OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>@LISP_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'s/[()]/ /g  if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%LISP_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>5.0</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>"[;<ESC>\"</ESC>]"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>""</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_NESTING'</STRING><OPERATOR>,</OPERATOR> <STRING>""</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC><ESC>\\</ESC>.|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>";"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'KEYWORD'</STRING><OPERATOR>,</OPERATOR> <STRING>'exists $LISP_KEYWORDS{$1}'</STRING><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'LISP'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@LISP_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>LISP_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## Matlab/Octave language definitions</COMMENT>
<COMMENT>## Problems are block_comments %{ %}, ... comments, and the transpose op '</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>%MATLAB_KEYWORDS</VARIABLE><OPERATOR>;</OPERATOR>
<VARIABLE>@MATLAB_KEYWORDS</VARIABLE>{
    <DELIMITER>qw(</DELIMITER><STRING>break</STRING> <STRING>case</STRING> <STRING>catch</STRING> <STRING>continue</STRING> <STRING>else</STRING> <STRING>elseif</STRING> <STRING>end</STRING>
      <STRING>false</STRING> <STRING>find</STRING> <STRING>for</STRING> <STRING>function</STRING> <STRING>global</STRING> <STRING>if</STRING> <STRING>otherwise</STRING>
      <STRING>persistent</STRING> <STRING>return</STRING> <STRING>switch</STRING> <STRING>true</STRING> <STRING>try</STRING> <STRING>while</STRING><DELIMITER>)</DELIMITER>} <OPERATOR>=</OPERATOR> <KEYWORD>undef</KEYWORD><OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>@MATLAB_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'s/^<ESC>\s</ESC>*%([{}])<ESC>\s</ESC>*$/<ESC>\001</ESC>$1/'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'s/(<ESC>\.</ESC><ESC>\.</ESC><ESC>\.</ESC><ESC>\s</ESC>*)<ESC>\S</ESC>/$1%/'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'s/(<ESC>\G</ESC>|[^.<ESC>\w</ESC><ESC>\)</ESC><ESC>\}</ESC><ESC>\]</ESC><ESC>\'</ESC>])<ESC>\'</ESC>(.*?)<ESC>\'</ESC>/$1<ESC>\002</ESC>$2<ESC>\002</ESC>/g'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'s/<ESC>\b</ESC>end<ESC>\b</ESC>|;/ /g  if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%MATLAB_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>15</NUMERIC><OPERATOR>,</OPERATOR> <COMMENT># who knows ...</COMMENT>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>"%|<ESC>\001</ESC>[{}]|<ESC>\002</ESC>"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\001</ESC>[{}]"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_NESTING'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>1</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>"<ESC>\002</ESC>QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\002</ESC><ESC>\002</ESC>|<ESC>\002</ESC>"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_<ESC>\002</ESC>"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\002</ESC>"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'%'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"<ESC>\001</ESC>{"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"<ESC>\001</ESC>}"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EndCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"<ESC>\002</ESC>"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'KEYWORD'</STRING><OPERATOR>,</OPERATOR> <STRING>'exists $MATLAB_KEYWORDS{$1}'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'OPERATOR'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\.</ESC>[<ESC>\'</ESC>*<ESC>\\</ESC><ESC>\\</ESC>^/]|(.)<ESC>\1</ESC>*=?'</STRING><OPERATOR>,</OPERATOR> <COMMENT># add dot operators</COMMENT>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'MATLAB'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@MATLAB_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>MATLAB_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## ZPL language definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>%ZPL_KEYWORDS</VARIABLE><OPERATOR>;</OPERATOR>
<VARIABLE>@ZPL_KEYWORDS</VARIABLE>{
    <DELIMITER>qw(</DELIMITER><STRING>array</STRING> <STRING>at</STRING> <STRING>band</STRING> <STRING>begin</STRING> <STRING>block</STRING> <STRING>boolean</STRING>
      <STRING>bor</STRING> <STRING>bread</STRING> <STRING>bwrite</STRING> <STRING>bxor</STRING> <STRING>by</STRING> <STRING>char</STRING>
      <STRING>complex</STRING> <STRING>config</STRING> <STRING>const</STRING> <STRING>constant</STRING> <STRING>continue</STRING>
      <STRING>cyclic</STRING> <STRING>dcomplex</STRING> <STRING>direction</STRING> <STRING>distribution</STRING>
      <STRING>do</STRING> <STRING>double</STRING> <STRING>downto</STRING> <STRING>else</STRING> <STRING>elsif</STRING> <STRING>end</STRING> <STRING>exit</STRING>
      <STRING>extern</STRING> <STRING>file</STRING> <STRING>float</STRING> <STRING>for</STRING> <STRING>free</STRING> <STRING>generic</STRING>
      <STRING>genericensemble</STRING> <STRING>grid</STRING> <STRING>halt</STRING> <STRING>if</STRING> <STRING>in</STRING> <STRING>inout</STRING>
      <STRING>integer</STRING> <STRING>interleave</STRING> <STRING>irregular</STRING> <STRING>longint</STRING>
      <STRING>max</STRING> <STRING>min</STRING> <STRING>multiblock</STRING> <STRING>nondist</STRING> <STRING>of</STRING> <STRING>opaque</STRING>
      <STRING>out</STRING> <STRING>procedure</STRING> <STRING>program</STRING> <STRING>prototype</STRING> <STRING>qcomplex</STRING>
      <STRING>quad</STRING> <STRING>read</STRING> <STRING>record</STRING> <STRING>reflect</STRING> <STRING>region</STRING> <STRING>repeat</STRING>
      <STRING>return</STRING> <STRING>sbyte</STRING> <STRING>scaledby</STRING> <STRING>scan</STRING> <STRING>shortint</STRING>
      <STRING>static</STRING> <STRING>string</STRING> <STRING>swith</STRING> <STRING>swithout</STRING> <STRING>then</STRING> <STRING>to</STRING>
      <STRING>type</STRING> <STRING>ubyte</STRING> <STRING>uinteger</STRING> <STRING>ulongint</STRING> <STRING>union</STRING> <STRING>until</STRING>
      <STRING>ushortint</STRING> <STRING>var</STRING> <STRING>while</STRING> <STRING>with</STRING> <STRING>without</STRING> <STRING>wrap</STRING>
      <STRING>write</STRING> <STRING>writeln</STRING><DELIMITER>)</DELIMITER>} <OPERATOR>=</OPERATOR> <KEYWORD>undef</KEYWORD><OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>@ZPL_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'s/<ESC>\b</ESC>(?:begin|end)<ESC>\b</ESC>|;/ /g  if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%ZPL_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>15</NUMERIC><OPERATOR>,</OPERATOR>    <COMMENT># who knows ...</COMMENT>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'/<ESC>\*</ESC>|--|["<ESC>\'</ESC>]'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\*</ESC>/'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_NESTING'</STRING><OPERATOR>,</OPERATOR> <STRING>""</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC><ESC>\\</ESC>.|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'--'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'/*'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'*/'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EndCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'KEYWORD'</STRING><OPERATOR>,</OPERATOR> <STRING>'exists $ZPL_KEYWORDS{$1}'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'SYMBOL'</STRING><OPERATOR>,</OPERATOR> <STRING>'[_a-zA-Z]<ESC>\w</ESC>*'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'OPERATOR'</STRING><OPERATOR>,</OPERATOR> <STRING>'@<ESC>\^</ESC>|(.)<ESC>\1</ESC>?=?'</STRING><OPERATOR>,</OPERATOR> <COMMENT># add @^, break up |||</COMMENT>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'ZPL'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@ZPL_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>ZPL_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## FORTRAN language definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>%FORTRAN_KEYWORDS</VARIABLE><OPERATOR>;</OPERATOR>
<VARIABLE>@FORTRAN_KEYWORDS</VARIABLE>{
    <DELIMITER>qw(</DELIMITER><STRING>allocatable</STRING> <STRING>allocate</STRING> <STRING>assign</STRING> <STRING>automatic</STRING>
      <STRING>backspace</STRING> <STRING>block</STRING> <STRING>byte</STRING> <STRING>call</STRING> <STRING>case</STRING> <STRING>character</STRING>
      <STRING>close</STRING> <STRING>common</STRING> <STRING>complex</STRING> <STRING>contains</STRING> <STRING>continue</STRING> <STRING>cycle</STRING>
      <STRING>data</STRING> <STRING>deallocate</STRING> <STRING>dimension</STRING> <STRING>do</STRING> <STRING>dowhile</STRING> <STRING>double</STRING>
      <STRING>else</STRING> <STRING>elseif</STRING> <STRING>elsewhere</STRING> <STRING>end</STRING> <STRING>enddo</STRING> <STRING>endif</STRING> <STRING>endselect</STRING>
      <STRING>endtype</STRING> <STRING>entry</STRING> <STRING>equivalence</STRING> <STRING>exit</STRING> <STRING>external</STRING>
      <STRING>forall</STRING> <STRING>format</STRING> <STRING>function</STRING> <STRING>go</STRING> <STRING>goto</STRING> <STRING>if</STRING> <STRING>implicit</STRING>
      <STRING>integer</STRING> <STRING>intent</STRING> <STRING>interface</STRING> <STRING>intrinsic</STRING> <STRING>logical</STRING>
      <STRING>module</STRING> <STRING>namelist</STRING> <STRING>nullify</STRING> <STRING>open</STRING> <STRING>optional</STRING>
      <STRING>parameter</STRING> <STRING>pause</STRING> <STRING>pointer</STRING> <STRING>precision</STRING> <STRING>print</STRING>
      <STRING>private</STRING> <STRING>procedure</STRING> <STRING>program</STRING> <STRING>protected</STRING> <STRING>public</STRING>
      <STRING>read</STRING> <STRING>real</STRING> <STRING>record</STRING> <STRING>return</STRING> <STRING>rewind</STRING>
      <STRING>save</STRING> <STRING>select</STRING> <STRING>sequence</STRING> <STRING>static</STRING> <STRING>stop</STRING> <STRING>subroutine</STRING>
      <STRING>target</STRING> <STRING>to</STRING> <STRING>type</STRING> <STRING>use</STRING> <STRING>value</STRING> <STRING>virtual</STRING> <STRING>volatile</STRING>
      <STRING>wait</STRING> <STRING>where</STRING> <STRING>while</STRING> <STRING>write</STRING><DELIMITER>)</DELIMITER>} <OPERATOR>=</OPERATOR> <KEYWORD>undef</KEYWORD><OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>@FORTRAN_EVALS</VARIABLE> <OPERATOR>=</OPERATOR>
  (<STRING>'s/^[c<ESC>\\</ESC>*]/!/gi'</STRING><OPERATOR>,</OPERATOR> <COMMENT>## denote 'c ...' comments with !</COMMENT>
    <STRING>'s/!<ESC>\$</ESC>OMP/<ESC>\$</ESC>OMP/gi'</STRING><OPERATOR>,</OPERATOR> <COMMENT>## Remove ! from OpenMP directive so it looks like code</COMMENT>
    <STRING>'s/^<ESC>\s</ESC>*end[^!<ESC>\n</ESC>]*/ /gi  if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%FORTRAN_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>5</NUMERIC><OPERATOR>,</OPERATOR> <COMMENT># who knows ...</COMMENT>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>"!|[<ESC>\"</ESC>']"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>""</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_NESTING'</STRING><OPERATOR>,</OPERATOR> <STRING>""</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC><ESC>\\</ESC>.|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'!'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'/*'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'*/'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EndCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'KEYWORD'</STRING><OPERATOR>,</OPERATOR> <STRING>'exists $FORTRAN_KEYWORDS{$1}'</STRING><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'FORTRAN'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@FORTRAN_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>FORTRAN_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## Chapel language definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>%CHAPEL_KEYWORDS</VARIABLE><OPERATOR>;</OPERATOR>
<VARIABLE>@CHAPEL_KEYWORDS</VARIABLE>{
    <DELIMITER>qw(</DELIMITER><STRING>allocate</STRING> <STRING>and</STRING> <STRING>array</STRING> <STRING>atomic</STRING> <STRING>boolean</STRING> <STRING>break</STRING> <STRING>call</STRING>
      <STRING>class</STRING> <STRING>cobegin</STRING> <STRING>complex</STRING> <STRING>config</STRING> <STRING>const</STRING> <STRING>constructor</STRING>
      <STRING>continue</STRING> <STRING>distribute</STRING> <STRING>do</STRING> <STRING>domain</STRING> <STRING>enum</STRING>
      <STRING>except</STRING> <STRING>expect</STRING> <STRING>false</STRING> <STRING>float</STRING> <STRING>for</STRING> <STRING>forall</STRING> <STRING>function</STRING>
      <STRING>goto</STRING> <STRING>if</STRING> <STRING>implements</STRING> <STRING>in</STRING> <STRING>index</STRING> <STRING>inout</STRING> <STRING>integer</STRING>
      <STRING>invariant</STRING> <STRING>iterator</STRING> <STRING>let</STRING> <STRING>like</STRING> <STRING>local</STRING> <STRING>Locales</STRING>
      <STRING>max</STRING> <STRING>min</STRING> <STRING>module</STRING> <STRING>nil</STRING> <STRING>not</STRING> <STRING>of</STRING> <STRING>on</STRING> <STRING>or</STRING> <STRING>otherwise</STRING>
      <STRING>out</STRING> <STRING>parameter</STRING> <STRING>private</STRING> <STRING>public</STRING>
      <STRING>release</STRING> <STRING>repeat</STRING> <STRING>return</STRING> <STRING>select</STRING> <STRING>seq</STRING> <STRING>subtype</STRING>
      <STRING>to</STRING> <STRING>true</STRING> <STRING>type</STRING> <STRING>typeselect</STRING> <STRING>union</STRING> <STRING>until</STRING>
      <STRING>unordered</STRING> <STRING>var</STRING> <STRING>view</STRING> <STRING>when</STRING> <STRING>where</STRING>
      <STRING>while</STRING> <STRING>with</STRING> <STRING>yield</STRING><DELIMITER>)</DELIMITER>} <OPERATOR>=</OPERATOR> <KEYWORD>undef</KEYWORD><OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>@CHAPEL_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'s/[{};]/ /g  if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%CHAPEL_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>15</NUMERIC><OPERATOR>,</OPERATOR> <COMMENT># who knows ...</COMMENT>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'/<ESC>\*</ESC>|--|//|["<ESC>\'</ESC>]'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'/<ESC>\*</ESC>|<ESC>\*</ESC>/'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_NESTING'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>1</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC><ESC>\\</ESC>.|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'--'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'//'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'/*'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'*/'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EndCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'KEYWORD'</STRING><OPERATOR>,</OPERATOR> <STRING>'exists $CHAPEL_KEYWORDS{$1}'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'SYMBOL'</STRING><OPERATOR>,</OPERATOR> <STRING>'[<ESC>\$</ESC>_a-zA-Z][?<ESC>\$</ESC><ESC>\w</ESC>]*'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'NUMBER'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\.</ESC>?<ESC>\d</ESC>[.<ESC>\w</ESC>]*'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'GROUPER'</STRING><OPERATOR>,</OPERATOR> <STRING>'[(){}[<ESC>\]</ESC>,;]'</STRING><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'CHAPEL'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@CHAPEL_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>CHAPEL_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## XML language definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>@XML_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'s/[{};]/ /g  if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%XML_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>22</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'&lt;!--|["<ESC>\'</ESC>]'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>"--&gt;"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_NESTING'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>1</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC><ESC>\\</ESC>.|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"&lt;!--"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"--&gt;"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EndCmnt</VARIABLE><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'XML'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@XML_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>XML_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## HTML language definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>@HTML_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'s/[{};]/ /g  if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%HTML_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>22</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'&lt;!--|["<ESC>\'</ESC>]'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>"--&gt;"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_NESTING'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>1</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC><ESC>\\</ESC>.|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"&lt;!--"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"--&gt;"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EndCmnt</VARIABLE><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'HTML'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@HTML_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>HTML_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## JSP language definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>@JSP_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'s/[{};]/ /g  if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%JSP_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>22</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'&lt;%--|["<ESC>\'</ESC>]'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>"--%&gt;"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_NESTING'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>1</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC><ESC>\\</ESC>.|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"&lt;%--"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"--%&gt;"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EndCmnt</VARIABLE><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'JSP'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@JSP_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>JSP_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## SQL language definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>@SQL_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'s/[{};]/ /g  if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%SQL_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>22</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'--|["<ESC>\'</ESC>]'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>"--"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_NESTING'</STRING><OPERATOR>,</OPERATOR> <STRING>""</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC><ESC>\\</ESC>.|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'--'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'SQL'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@SQL_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>SQL_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## Python language definitions</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## Lorin Hochstein trying his best to figure this out.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## Note: DocStrings will be considered as source lines.</COMMENT>
<COMMENT>## It is difficult to get it to detect them correctly.</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>%PYTHON_KEYWORDS</VARIABLE><OPERATOR>;</OPERATOR>
<VARIABLE>@PYTHON_KEYWORDS</VARIABLE>{
    <DELIMITER>qw(</DELIMITER><STRING>and</STRING>       <STRING>del</STRING>      <STRING>for</STRING>     <STRING>is</STRING>     <STRING>raise</STRING>
      <STRING>assert</STRING>    <STRING>elif</STRING>     <STRING>from</STRING>    <STRING>lambda</STRING> <STRING>return</STRING>
      <STRING>break</STRING>     <STRING>else</STRING>     <STRING>global</STRING>  <STRING>not</STRING>    <STRING>try</STRING>
      <STRING>class</STRING>     <STRING>except</STRING>   <STRING>if</STRING>      <STRING>or</STRING>     <STRING>while</STRING>
      <STRING>continue</STRING>  <STRING>exec</STRING>     <STRING>import</STRING>  <STRING>pass</STRING>   <STRING>yield</STRING>
      <STRING>def</STRING>       <STRING>finally</STRING>  <STRING>in</STRING>      <STRING>print</STRING><DELIMITER>)</DELIMITER>} <OPERATOR>=</OPERATOR> <KEYWORD>undef</KEYWORD><OPERATOR>;</OPERATOR>

<COMMENT># copied verbatim from SHELL_EVALS</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>@PYTHON_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'s/(^|<ESC>\s</ESC>+)#/<ESC>\001</ESC>/g'</STRING><OPERATOR>,</OPERATOR>   <COMMENT>## denote '#' comments with \001</COMMENT>
    <STRING>'s/<ESC>\\</ESC><ESC>\\</ESC>./__/g'</STRING><OPERATOR>,</OPERATOR>        <COMMENT>## remove escaped characters</COMMENT>
  )<OPERATOR>;</OPERATOR>

<COMMENT># copied verbatim from SHELL_DEFNS</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>%PYTHON_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>15.0</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR><STRING>"[<ESC>\001</ESC>`<ESC>\"</ESC>']"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC><ESC>\\</ESC>.|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"`QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|`"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_`"</STRING><OPERATOR>,</OPERATOR> <STRING>"`"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'''QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|'''"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'''"</STRING><OPERATOR>,</OPERATOR> <STRING>"'''"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"""QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC>.|"""'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"""'</STRING><OPERATOR>,</OPERATOR> <STRING>'"""'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"<ESC>\001</ESC>"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"'''"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'"""'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'`'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'KEYWORD'</STRING><OPERATOR>,</OPERATOR> <STRING>'exists $PYTHON_KEYWORDS{$1}'</STRING><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>

<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'PYTHON'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@PYTHON_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>PYTHON_DEFNS</CONSTANT>]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## C# language definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>%CSHARP_KEYWORDS</VARIABLE><OPERATOR>;</OPERATOR>
<VARIABLE>@CSHARP_KEYWORDS</VARIABLE>{
    <DELIMITER>qw(</DELIMITER><STRING>abstract</STRING> <STRING>as</STRING> <STRING>base</STRING> <STRING>bool</STRING> <STRING>break</STRING> <STRING>byte</STRING>
      <STRING>case</STRING> <STRING>catch</STRING> <STRING>char</STRING> <STRING>checked</STRING> <STRING>class</STRING> <STRING>const</STRING>
      <STRING>continue</STRING> <STRING>decimal</STRING> <STRING>default</STRING> <STRING>delegate</STRING>
      <STRING>do</STRING> <STRING>double</STRING> <STRING>else</STRING> <STRING>enum</STRING> <STRING>event</STRING> <STRING>explicit</STRING>
      <STRING>extern</STRING> <STRING>false</STRING> <STRING>finally</STRING> <STRING>fixed</STRING> <STRING>float</STRING> <STRING>for</STRING>
      <STRING>foreach</STRING> <STRING>goto</STRING> <STRING>if</STRING> <STRING>implicit</STRING> <STRING>in</STRING> <STRING>int</STRING>
      <STRING>interface</STRING> <STRING>internal</STRING> <STRING>is</STRING> <STRING>lock</STRING> <STRING>long</STRING>
      <STRING>namespace</STRING> <STRING>new</STRING> <STRING>null</STRING> <STRING>object</STRING> <STRING>operator</STRING>
      <STRING>out</STRING> <STRING>override</STRING> <STRING>params</STRING> <STRING>private</STRING> <STRING>protected</STRING>
      <STRING>public</STRING> <STRING>readonly</STRING> <STRING>ref</STRING> <STRING>return</STRING> <STRING>sbyte</STRING>
      <STRING>sealed</STRING> <STRING>short</STRING> <STRING>sizeof</STRING> <STRING>stackalloc</STRING> <STRING>static</STRING>
      <STRING>string</STRING> <STRING>struct</STRING> <STRING>switch</STRING> <STRING>this</STRING> <STRING>throw</STRING> <STRING>true</STRING>
      <STRING>try</STRING> <STRING>typeof</STRING> <STRING>uint</STRING> <STRING>ulong</STRING> <STRING>unchecked</STRING> <STRING>unsafe</STRING>
      <STRING>ushort</STRING> <STRING>using</STRING> <STRING>virtual</STRING> <STRING>volatile</STRING> <STRING>void</STRING> <STRING>while</STRING><DELIMITER>)</DELIMITER>} <OPERATOR>=</OPERATOR> <KEYWORD>undef</KEYWORD><OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>@CSHARP_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'s/[{};]/ /g  if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%CSHARP_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>6</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'/[*/]|["<ESC>\'</ESC>]'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC>*/'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_NESTING'</STRING><OPERATOR>,</OPERATOR> <STRING>""</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC><ESC>\\</ESC>.|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'//'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'/*'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'*/'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EndCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'KEYWORD'</STRING><OPERATOR>,</OPERATOR> <STRING>'exists $CSHARP_KEYWORDS{$1}'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'SYMBOL'</STRING><OPERATOR>,</OPERATOR> <STRING>'[<ESC>\$</ESC>_a-zA-Z][<ESC>\$</ESC><ESC>\w</ESC>]*'</STRING><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'CSHARP'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@CSHARP_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>CSHARP_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## Template language definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>@TEMPLATE_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'s/[{;}]/ /g'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'s/%<ESC>\]</ESC>/<ESC>\002</ESC>/g'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'s/<ESC>\[</ESC>%/<ESC>\001</ESC>/g if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%TEMPLATE_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>15.0</NUMERIC><OPERATOR>,</OPERATOR> <COMMENT># who knows</COMMENT>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\001</ESC>'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>"/<ESC>\001</ESC>%#|.*%<ESC>\002</ESC>/"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_NESTING'</STRING><OPERATOR>,</OPERATOR> <STRING>""</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>""</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>";"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'TEMPLATE'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@TEMPLATE_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>TEMPLATE_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>##JavaScript language definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>@JAVASCRIPT_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'s/<ESC>\\</ESC><ESC>\\</ESC>./__/g;'</STRING><OPERATOR>,</OPERATOR> <COMMENT>## remove escaped characters</COMMENT>
    <STRING>'s/[{};]/ /g if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%JAVASCRIPT_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>15.0</NUMERIC><OPERATOR>,</OPERATOR> <COMMENT># who knows</COMMENT>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'/[*/]|["<ESC>\'</ESC>]'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC>*/'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_NESTING'</STRING><OPERATOR>,</OPERATOR> <STRING>""</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'//'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'/*'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'*/'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EndCmnt</VARIABLE><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'JAVASCRIPT'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@JAVASCRIPT_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>JAVASCRIPT_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## CSS language definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>@CSS_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'s/[{};]/ /g if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%CSS_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>22</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'&lt;!--|/<ESC>\\</ESC>*|["<ESC>\'</ESC>]'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC>*/|--&gt;'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_NESTING'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>1</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC><ESC>\\</ESC>.|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"&lt;!--"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"--&gt;"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EndCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'/*'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'*/'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EndCmnt</VARIABLE>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'CSS'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@CSS_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>CSS_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## Jess language definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>%JESS_KEYWORDS</VARIABLE><OPERATOR>;</OPERATOR>
<VARIABLE>@JESS_KEYWORDS</VARIABLE>{
    <DELIMITER>qw(</DELIMITER><STRING>and</STRING> <STRING>append</STRING> <STRING>boundp</STRING> <STRING>car</STRING> <STRING>catch</STRING>
      <STRING>cdr</STRING> <STRING>concat</STRING> <STRING>cond</STRING> <STRING>cons</STRING> <STRING>defun</STRING> <STRING>defvar</STRING>
      <STRING>eq</STRING> <STRING>equal</STRING> <STRING>error</STRING> <STRING>eval</STRING> <STRING>fboundp</STRING> <STRING>get</STRING>
      <STRING>if</STRING> <STRING>lambda</STRING> <STRING>let</STRING> <STRING>list</STRING> <STRING>load</STRING> <STRING>map</STRING> <STRING>mapcar</STRING>
      <STRING>member</STRING> <STRING>memq</STRING> <STRING>nconc</STRING> <STRING>nil</STRING> <STRING>not</STRING> <STRING>or</STRING>
      <STRING>prin1</STRING> <STRING>princ</STRING> <STRING>prog</STRING> <STRING>progn</STRING> <STRING>put</STRING> <STRING>quote</STRING>
      <STRING>reverse</STRING> <STRING>set</STRING> <STRING>setq</STRING> <STRING>t</STRING> <STRING>throw</STRING> <STRING>unless</STRING>
      <STRING>when</STRING> <STRING>while</STRING> <STRING>zerop</STRING><DELIMITER>)</DELIMITER>} <OPERATOR>=</OPERATOR> <KEYWORD>undef</KEYWORD><OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>@JESS_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'s/[()]/ /g  if ($OPTS{delim_ignore})'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%JESS_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>5.0</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>"[;<ESC>\"</ESC>]"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>""</STRING><OPERATOR>,</OPERATOR>
    <STRING>'CMMNT_NESTING'</STRING><OPERATOR>,</OPERATOR> <STRING>""</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC><ESC>\\</ESC>.|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>";"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'KEYWORD'</STRING><OPERATOR>,</OPERATOR> <STRING>'exists $LISP_KEYWORDS{$1}'</STRING><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'JESS'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@JESS_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>JESS_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## FLASH Config language definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>%FLASHCONFIG_KEYWORDS</VARIABLE><OPERATOR>;</OPERATOR>
<VARIABLE>@FLASHCONFIG_KEYWORDS</VARIABLE>{
    <DELIMITER>qw(</DELIMITER><STRING>REQUIRES</STRING> <STRING>REQUESTS</STRING>
      <STRING>PARAMETER</STRING> <STRING>D</STRING>
      <STRING>REAL</STRING> <STRING>INTEGER</STRING> <STRING>STRING</STRING>
      <STRING>PPDEFINE</STRING><DELIMITER>)</DELIMITER>} <OPERATOR>=</OPERATOR> <KEYWORD>undef</KEYWORD><OPERATOR>;</OPERATOR>

<KEYWORD>my</KEYWORD> <VARIABLE>@FLASHCONFIG_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'s/(^|<ESC>\s</ESC>+)[#D]/<ESC>\001</ESC>/g'</STRING><OPERATOR>,</OPERATOR>   <COMMENT>## denote '#' comments with \001</COMMENT>
  )<OPERATOR>;</OPERATOR>

<KEYWORD>my</KEYWORD> <VARIABLE>%FLASHCONFIG_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>15.0</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR><STRING>"[<ESC>\001</ESC>`<ESC>\"</ESC>']"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC><ESC>\\</ESC>.|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"`QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|`"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_`"</STRING><OPERATOR>,</OPERATOR> <STRING>"`"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"<ESC>\001</ESC>"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'`'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'KEYWORD'</STRING><OPERATOR>,</OPERATOR> <STRING>'exists $FLASHCONFIG_KEYWORDS{$1}'</STRING><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'FLASHCONFIG'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@FLASHCONFIG_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>FLASHCONFIG_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## FLASH Parameter language definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>%FLASHPARAMETER_KEYWORDS</VARIABLE><OPERATOR>;</OPERATOR>
<VARIABLE>@FLASHPARAMETER_KEYWORDS</VARIABLE>{
    <DELIMITER>qw(</DELIMITER><STRING></STRING> <STRING>.true.</STRING> <STRING>.false.</STRING> <STRING></STRING><DELIMITER>)</DELIMITER>} <OPERATOR>=</OPERATOR> <KEYWORD>undef</KEYWORD><OPERATOR>;</OPERATOR>

<KEYWORD>my</KEYWORD> <VARIABLE>@FLASHPARAMETER_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'s/(^|<ESC>\s</ESC>+)#/<ESC>\001</ESC>/g'</STRING><OPERATOR>,</OPERATOR>   <COMMENT>## denote '#' comments with \001</COMMENT>
  )<OPERATOR>;</OPERATOR>

<KEYWORD>my</KEYWORD> <VARIABLE>%FLASHPARAMETER_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>15.0</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR><STRING>"[<ESC>\001</ESC>`<ESC>\"</ESC>']"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC><ESC>\\</ESC>.|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"`QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|`"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_`"</STRING><OPERATOR>,</OPERATOR> <STRING>"`"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"<ESC>\001</ESC>"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'`'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'KEYWORD'</STRING><OPERATOR>,</OPERATOR> <STRING>'exists $FLASHPARAMETER_KEYWORDS{$1}'</STRING><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'FLASHPARAMETER'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@FLASHPARAMETER_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>FLASHPARAMETER_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## Plain Text definitions</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>@TEXT_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'s/^(.*)/<ESC>\001</ESC>$1/g'</STRING>
  )<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%TEXT_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'AESL'</STRING><OPERATOR>,</OPERATOR> <NUMERIC>15.0</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING><OPERATOR>,</OPERATOR><STRING>"[<ESC>\001</ESC>`<ESC>\"</ESC>']"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC><ESC>\\</ESC>.|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING><OPERATOR>,</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"`QUOTE_STATE"</STRING><OPERATOR>,</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|`"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_`"</STRING><OPERATOR>,</OPERATOR> <STRING>"`"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"<ESC>\001</ESC>"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'`'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'TEXT'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@TEXT_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>TEXT_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<KEYWORD>my</KEYWORD> <VARIABLE>%IDL_KEYWORDS</VARIABLE><OPERATOR>;</OPERATOR>
<VARIABLE>@IDL_KEYWORDS</VARIABLE>{
    <DELIMITER>qw(</DELIMITER><STRING>pro</STRING> <STRING>return</STRING> <STRING>begin</STRING> <STRING>end</STRING>
      <STRING>if</STRING> <STRING>then</STRING> <STRING>else</STRING> <STRING>endif</STRING>
      <STRING>for</STRING> <STRING>do</STRING> <STRING>endfor</STRING>
      <STRING>case</STRING> <STRING>of</STRING> <STRING>endcase</STRING><DELIMITER>)</DELIMITER>} <OPERATOR>=</OPERATOR> <KEYWORD>undef</KEYWORD><OPERATOR>;</OPERATOR>

<KEYWORD>my</KEYWORD> <VARIABLE>@IDL_EVALS</VARIABLE> <OPERATOR>=</OPERATOR> (
    <STRING>'s/;/<ESC>\001</ESC>/g'</STRING><OPERATOR>,</OPERATOR>   <COMMENT>## denote ';' comments with \001</COMMENT>
  )<OPERATOR>;</OPERATOR>

<KEYWORD>my</KEYWORD> <VARIABLE>%IDL_DEFNS</VARIABLE> <OPERATOR>=</OPERATOR> ( <STRING>'AESL'</STRING>         <OPERATOR>=&gt;</OPERATOR> <NUMERIC>15.0</NUMERIC><OPERATOR>,</OPERATOR>
    <STRING>'START_STATE'</STRING>  <OPERATOR>=&gt;</OPERATOR><STRING>"[<ESC>\001</ESC>'<ESC>\"</ESC>]"</STRING><OPERATOR>,</OPERATOR>
    <STRING>'"QUOTE_STATE'</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>'<ESC>\\</ESC><ESC>\\</ESC>.|"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>'END_"'</STRING>        <OPERATOR>=&gt;</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR>
    <STRING>"'QUOTE_STATE"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"<ESC>\\</ESC><ESC>\\</ESC>.|'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"END_'"</STRING>        <OPERATOR>=&gt;</OPERATOR> <STRING>"'"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"<ESC>\001</ESC>"</STRING>        <OPERATOR>=&gt;</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>"'"</STRING>           <OPERATOR>=&gt;</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'"'</STRING>           <OPERATOR>=&gt;</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE><OPERATOR>,</OPERATOR>
    <STRING>'KEYWORD'</STRING>     <OPERATOR>=&gt;</OPERATOR> <STRING>'exists $IDL_KEYWORDS{$1}'</STRING><OPERATOR>,</OPERATOR>
  )<OPERATOR>;</OPERATOR>
<VARIABLE>$LANG_RULES</VARIABLE>{<STRING>'IDL'</STRING>} <OPERATOR>=</OPERATOR> [ <OPERATOR>\</OPERATOR><VARIABLE>@IDL_EVALS</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR><CONSTANT>IDL_DEFNS</CONSTANT> ]<OPERATOR>;</OPERATOR>

<DOCCOMMENT>### END OF LANGUAGE DEFINITIONS ###</DOCCOMMENT>

<COMMENT>## Default language extensions</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## GLOBAL:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## DESCRIPTION:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>%Suffixes</VARIABLE> <OPERATOR>=</OPERATOR> (
    <COMMENT>## Assembler</COMMENT>
    <STRING>".s"</STRING>   <OPERATOR>=&gt;</OPERATOR>   <STRING>"Assembly"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".S"</STRING>   <OPERATOR>=&gt;</OPERATOR>   <STRING>"Assembly"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".as"</STRING>  <OPERATOR>=&gt;</OPERATOR>  <STRING>"Assembly"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".AS"</STRING>  <OPERATOR>=&gt;</OPERATOR>  <STRING>"Assembly"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".asm"</STRING> <OPERATOR>=&gt;</OPERATOR>  <STRING>"Assembly"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".ASM"</STRING> <OPERATOR>=&gt;</OPERATOR>  <STRING>"Assembly"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## C</COMMENT>
    <STRING>".c"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"C"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".C"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"C"</STRING><OPERATOR>,</OPERATOR>  <COMMENT>## We have some special rules we use later on so we</COMMENT>
    <STRING>".h"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"C"</STRING><OPERATOR>,</OPERATOR>  <COMMENT>## don't mistake a C++ file for a C file.</COMMENT>
    <STRING>".H"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"C"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## C++</COMMENT>
    <STRING>".cc"</STRING>  <OPERATOR>=&gt;</OPERATOR> <STRING>"C++"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".cxx"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"C++"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".cpp"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"C++"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".hh"</STRING>  <OPERATOR>=&gt;</OPERATOR>  <STRING>"C++"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## Chapel</COMMENT>
    <STRING>".chpl"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Chapel"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## Ada</COMMENT>
    <STRING>".a"</STRING>   <OPERATOR>=&gt;</OPERATOR>   <STRING>"Ada"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".ada"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Ada"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".Ada"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Ada"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".ADA"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Ada"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## Eiffel</COMMENT>
    <STRING>".e"</STRING>   <OPERATOR>=&gt;</OPERATOR> <STRING>"Eiffel"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".efl"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Eiffel"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".Efl"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Eiffel"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".EFL"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Eiffel"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## FORTAN</COMMENT>
    <STRING>".f"</STRING>   <OPERATOR>=&gt;</OPERATOR> <STRING>"FORTRAN"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".fh"</STRING>  <OPERATOR>=&gt;</OPERATOR> <STRING>"FORTRAN"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".for"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"FORTRAN"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".f90"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"FORTRAN"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".F"</STRING>   <OPERATOR>=&gt;</OPERATOR> <STRING>"FORTRAN"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".F90"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"FORTRAN"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## Java</COMMENT>
    <STRING>".java"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Java"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".java"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Java"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".JAV"</STRING>  <OPERATOR>=&gt;</OPERATOR> <STRING>"Java"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## Lisp</COMMENT>
    <STRING>".l"</STRING>   <OPERATOR>=&gt;</OPERATOR> <STRING>"Lisp"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".lsp"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Lisp"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".Lsp"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Lisp"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".LSP"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Lisp"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".el"</STRING>  <OPERATOR>=&gt;</OPERATOR> <STRING>"Lisp"</STRING><OPERATOR>,</OPERATOR> <COMMENT># Actually emacs lisp</COMMENT>
    <COMMENT>## Matlab</COMMENT>
    <STRING>".nb"</STRING>  <OPERATOR>=&gt;</OPERATOR> <STRING>"Mathematica"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".nbp"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Mathematica"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## Matlab</COMMENT>
    <STRING>".m"</STRING>   <OPERATOR>=&gt;</OPERATOR> <STRING>"Matlab"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## Flash parameter</COMMENT>
    <STRING>".par"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"FlashParameter"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## ".DAT" =&gt; "FlashParameter",</COMMENT>
    <COMMENT>## Pascal</COMMENT>
    <STRING>".p"</STRING> <OPERATOR>=&gt;</OPERATOR>   <STRING>"Pascal"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".pas"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Pascal"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".Pas"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Pascal"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".PAS"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Pascal"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## Perl</COMMENT>
    <STRING>".pl"</STRING> <OPERATOR>=&gt;</OPERATOR>  <STRING>"Perl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".PL"</STRING> <OPERATOR>=&gt;</OPERATOR>  <STRING>"Perl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".plt"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Perl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".PLT"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Perl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".ph"</STRING> <OPERATOR>=&gt;</OPERATOR>  <STRING>"Perl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".PH"</STRING> <OPERATOR>=&gt;</OPERATOR>  <STRING>"Perl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".pm"</STRING> <OPERATOR>=&gt;</OPERATOR>  <STRING>"Perl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".PM"</STRING> <OPERATOR>=&gt;</OPERATOR>  <STRING>"Perl"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## PHP</COMMENT>
    <STRING>".php"</STRING> <OPERATOR>=&gt;</OPERATOR>  <STRING>"PHP"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## shell</COMMENT>
    <STRING>".sh"</STRING>   <OPERATOR>=&gt;</OPERATOR> <STRING>"shell"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".bash"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"shell"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".csh"</STRING>  <OPERATOR>=&gt;</OPERATOR> <STRING>"shell"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".ksh"</STRING>  <OPERATOR>=&gt;</OPERATOR> <STRING>"shell"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".tcsh"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"shell"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".zsh"</STRING>  <OPERATOR>=&gt;</OPERATOR> <STRING>"shell"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## make</COMMENT>
    <STRING>".in"</STRING>   <OPERATOR>=&gt;</OPERATOR>  <STRING>"make"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".m4"</STRING>   <OPERATOR>=&gt;</OPERATOR>  <STRING>"make"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".am"</STRING>   <OPERATOR>=&gt;</OPERATOR>  <STRING>"make"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".ac"</STRING>   <OPERATOR>=&gt;</OPERATOR>  <STRING>"make"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".mk"</STRING>   <OPERATOR>=&gt;</OPERATOR>  <STRING>"make"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".MK"</STRING>   <OPERATOR>=&gt;</OPERATOR>  <STRING>"make"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".make"</STRING> <OPERATOR>=&gt;</OPERATOR>  <STRING>"make"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".MAKE"</STRING> <OPERATOR>=&gt;</OPERATOR>  <STRING>"make"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## Awk</COMMENT>
    <STRING>".awk"</STRING> <OPERATOR>=&gt;</OPERATOR>  <STRING>"Awk"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".AWK"</STRING> <OPERATOR>=&gt;</OPERATOR>  <STRING>"Awk"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## Tcl</COMMENT>
    <STRING>".tcl"</STRING>   <OPERATOR>=&gt;</OPERATOR> <STRING>"Tcl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".Tcl"</STRING>   <OPERATOR>=&gt;</OPERATOR> <STRING>"Tcl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".TCL"</STRING>   <OPERATOR>=&gt;</OPERATOR> <STRING>"Tcl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".tclsh"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Tcl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".TCLSH"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Tcl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".tk"</STRING>    <OPERATOR>=&gt;</OPERATOR> <STRING>"Tcl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".Tk"</STRING>    <OPERATOR>=&gt;</OPERATOR> <STRING>"Tcl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".TK"</STRING>    <OPERATOR>=&gt;</OPERATOR> <STRING>"Tcl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".wish"</STRING>  <OPERATOR>=&gt;</OPERATOR> <STRING>"Tcl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".WISH"</STRING>  <OPERATOR>=&gt;</OPERATOR> <STRING>"Tcl"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## ZPL</COMMENT>
    <STRING>".z"</STRING>  <OPERATOR>=&gt;</OPERATOR> <STRING>"ZPL"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".zh"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"ZPL"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## XML</COMMENT>
    <STRING>".xml"</STRING>  <OPERATOR>=&gt;</OPERATOR> <STRING>"XML"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".xsd"</STRING>  <OPERATOR>=&gt;</OPERATOR> <STRING>"XML"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".wsdl"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"XML"</STRING><OPERATOR>,</OPERATOR>

    <COMMENT>## HTML</COMMENT>
    <STRING>".html"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"HTML"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".htm"</STRING>  <OPERATOR>=&gt;</OPERATOR> <STRING>"HTML"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## JSP</COMMENT>
    <STRING>".jsp"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"JSP"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## SQL</COMMENT>
    <STRING>".sql"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"SQL"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## PYTHON</COMMENT>
    <STRING>".py"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Python"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## C#</COMMENT>
    <STRING>".cs"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"CSharp"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## CSS</COMMENT>
    <STRING>".css"</STRING> <OPERATOR>=&gt;</OPERATOR>   <STRING>"CSS"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## JavaScript</COMMENT>
    <STRING>".js"</STRING> <OPERATOR>=&gt;</OPERATOR>    <STRING>"JavaScript"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## Template</COMMENT>
    <STRING>".tt"</STRING> <OPERATOR>=&gt;</OPERATOR>    <STRING>"Template"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## Jess</COMMENT>
    <STRING>".clp"</STRING> <OPERATOR>=&gt;</OPERATOR>   <STRING>"Jess"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## Text</COMMENT>
    <STRING>".txt"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Text"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".TXT"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Text"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".doc"</STRING> <OPERATOR>=&gt;</OPERATOR>	<STRING>"Text"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".DOC"</STRING> <OPERATOR>=&gt;</OPERATOR>	<STRING>"Text"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".rtf"</STRING> <OPERATOR>=&gt;</OPERATOR>	<STRING>"Text"</STRING><OPERATOR>,</OPERATOR>
    <STRING>".RTF"</STRING> <OPERATOR>=&gt;</OPERATOR>	<STRING>"Text"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## IDL</COMMENT>
    <STRING>".pro"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"IDL"</STRING>
  )<OPERATOR>;</OPERATOR>

<COMMENT>## Default language interpreters</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## GLOBAL:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## DESCRIPTION:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>%Interpreters</VARIABLE> <OPERATOR>=</OPERATOR> (
    <COMMENT>## Perl</COMMENT>
    <STRING>"per5"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Perl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"perl"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Perl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"Perl"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Perl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"PERL"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Perl"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## Awk</COMMENT>
    <STRING>"awk"</STRING>  <OPERATOR>=&gt;</OPERATOR> <STRING>"Awk"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## Python</COMMENT>
    <STRING>"python"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Python"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## shell</COMMENT>
    <STRING>"sh"</STRING>   <OPERATOR>=&gt;</OPERATOR> <STRING>"shell"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"bash"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"shell"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"csh"</STRING>  <OPERATOR>=&gt;</OPERATOR> <STRING>"shell"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"ksh"</STRING>  <OPERATOR>=&gt;</OPERATOR> <STRING>"shell"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"tcsh"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"shell"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"zsh"</STRING>  <OPERATOR>=&gt;</OPERATOR> <STRING>"shell"</STRING><OPERATOR>,</OPERATOR>
    <COMMENT>## Tcl</COMMENT>
    <STRING>"tcl"</STRING>   <OPERATOR>=&gt;</OPERATOR> <STRING>"Tcl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"Tcl"</STRING>   <OPERATOR>=&gt;</OPERATOR> <STRING>"Tcl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"TCL"</STRING>   <OPERATOR>=&gt;</OPERATOR> <STRING>"Tcl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"tclsh"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Tcl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"TCLSH"</STRING> <OPERATOR>=&gt;</OPERATOR> <STRING>"Tcl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"tk"</STRING>    <OPERATOR>=&gt;</OPERATOR> <STRING>"Tcl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"Tk"</STRING>    <OPERATOR>=&gt;</OPERATOR> <STRING>"Tcl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"TK"</STRING>    <OPERATOR>=&gt;</OPERATOR> <STRING>"Tcl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"wish"</STRING>  <OPERATOR>=&gt;</OPERATOR> <STRING>"Tcl"</STRING><OPERATOR>,</OPERATOR>
    <STRING>"WISH"</STRING>  <OPERATOR>=&gt;</OPERATOR> <STRING>"Tcl"</STRING>
  )<OPERATOR>;</OPERATOR>

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## FUNCTION:</COMMENT>
<COMMENT>##   ErrorMsg -- Print an error message (prefixed by "$NAME: ").</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SYNOPSIS:</COMMENT>
<COMMENT>##   ErrorMsg("message text");</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## ARGUMENTS:</COMMENT>
<COMMENT>##   A single string containing the message text.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## RETURN VALUE: None.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## PRECONDITIONS:</COMMENT>
<COMMENT>##   The global variable $NAME should be set to the name of the running</COMMENT>
<COMMENT>##   script.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SIDE EFFECTS:</COMMENT>
<COMMENT>##   - Prints to STDERR</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>sub</KEYWORD> ErrorMsg {
    <FUNCTION>print</FUNCTION> <CONSTANT>STDERR</CONSTANT> (<STRING>"${NAME}: "</STRING><OPERATOR>,</OPERATOR> <VARIABLE>@_</VARIABLE><OPERATOR>,</OPERATOR> <STRING>"<ESC>\n</ESC>"</STRING>)<OPERATOR>;</OPERATOR>
}

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## FUNCTION:</COMMENT>
<COMMENT>##   FatalMsg -- Print an error message and then abort</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SYNOPSIS:</COMMENT>
<COMMENT>##   &amp;FatalMsg("message text");</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## ARGUMENTS:</COMMENT>
<COMMENT>##   A single string containing the message text.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## RETURN VALUE: None.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## PRECONDITIONS:</COMMENT>
<COMMENT>##   The global variable $NAME should be set to the name of the running</COMMENT>
<COMMENT>##   script.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SIDE EFFECTS:</COMMENT>
<COMMENT>##   - Prints an error message</COMMENT>
<COMMENT>##   - Exits the script using exit(2)</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>sub</KEYWORD> FatalMsg {
    <OPERATOR>&amp;</OPERATOR>ErrorMsg(<VARIABLE>@_</VARIABLE>)<OPERATOR>;</OPERATOR>
    <KEYWORD>exit</KEYWORD>(<NUMERIC>2</NUMERIC>)<OPERATOR>;</OPERATOR>
}

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## FUNCTION:</COMMENT>
<COMMENT>##   Usage -- Print a Usage message and then exit with the specified</COMMENT>
<COMMENT>##            exit-value. If the exit-value is &gt; 1, then usage is terse</COMMENT>
<COMMENT>##            (synopsis only) and goes to STDERR. Otherwise, usage is</COMMENT>
<COMMENT>##            verbose and goes to STDOUT.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SYNOPSIS:</COMMENT>
<COMMENT>##   &amp;Usage([$val]);</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## ARGUMENTS:</COMMENT>
<COMMENT>##   $val : (optional) The integer exit value to use (defaults to 2).</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## RETURN VALUE: None.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## PRECONDITIONS: None.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SIDE EFFECTS:</COMMENT>
<COMMENT>##   Exits the script using exit with the given exit-status.</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>sub</KEYWORD> Usage {
    <KEYWORD>local</KEYWORD>(<VARIABLE>$_</VARIABLE>) <OPERATOR>=</OPERATOR> <FUNCTION>shift</FUNCTION><OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> (<VARIABLE>$exitval</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$message</VARIABLE>) <OPERATOR>=</OPERATOR> (<NUMERIC>1</NUMERIC><OPERATOR>,</OPERATOR> <STRING>''</STRING>)<OPERATOR>;</OPERATOR>
    <COMMENT>## Collect arguments</COMMENT>
    <KEYWORD>if</KEYWORD> ( <DELIMITER>/</DELIMITER><REGEX>^[-+]?\d+$</REGEX><DELIMITER>/</DELIMITER> ) {
        (<VARIABLE>$exitval</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$message</VARIABLE>) <OPERATOR>=</OPERATOR> (<VARIABLE>$_</VARIABLE><OPERATOR>,</OPERATOR> <STRING>''</STRING>)<OPERATOR>;</OPERATOR>
    }
    <KEYWORD>elsif</KEYWORD> (<KEYWORD>defined</KEYWORD> <VARIABLE>$_</VARIABLE>  <OPERATOR>and</OPERATOR>  <FUNCTION>length</FUNCTION> <VARIABLE>$_</VARIABLE>) {
        (<VARIABLE>$exitval</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$message</VARIABLE>) <OPERATOR>=</OPERATOR> (<NUMERIC>2</NUMERIC><OPERATOR>,</OPERATOR> <VARIABLE>$_</VARIABLE>)<OPERATOR>;</OPERATOR>
    }
    <FUNCTION>printf</FUNCTION> <CONSTANT>STDERR</CONSTANT> (<STRING>"%s: %s<ESC>\n</ESC>"</STRING><OPERATOR>,</OPERATOR> basename(<VARIABLE>$0</VARIABLE>)<OPERATOR>,</OPERATOR> <VARIABLE>$message</VARIABLE>)  <KEYWORD>if</KEYWORD> (<VARIABLE>$message</VARIABLE>)<OPERATOR>;</OPERATOR>
    <VARIABLE>$ENV</VARIABLE>{<CONSTANT>PATH</CONSTANT>} <OPERATOR>.=</OPERATOR> <VARIABLE>$PathList_Sep</VARIABLE> <OPERATOR>.</OPERATOR> <VARIABLE>$Config</VARIABLE>{bin}<OPERATOR>;</OPERATOR>
    <FUNCTION>system</FUNCTION>( <VARIABLE>$Config</VARIABLE>{bin} <OPERATOR>.</OPERATOR> <VARIABLE>$Path_Sep</VARIABLE> <OPERATOR>.</OPERATOR> <STRING>'perldoc'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$0</VARIABLE> )<OPERATOR>;</OPERATOR>
    <KEYWORD>exit</KEYWORD>(<VARIABLE>$exitval</VARIABLE>)<OPERATOR>;</OPERATOR>
}

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## FUNCTION:</COMMENT>
<COMMENT>##   DbgPrintf -- Print debugging output. Prints the specified arguments</COMMENT>
<COMMENT>##                only if '-debug' was specified on the command-line.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SYNOPSIS:</COMMENT>
<COMMENT>##   DbgPrintf("%s\n", "debug message text");</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## ARGUMENTS:</COMMENT>
<COMMENT>##   The format and variables containing the debug message text (a newline</COMMENT>
<COMMENT>##   is not automatically printed so include it yourself if you need it).</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## RETURN VALUE: None.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## PRECONDITIONS:</COMMENT>
<COMMENT>##   Assumes that the global variable named $OPTS{'debug'} will evaluate to</COMMENT>
<COMMENT>##   TRUE if '-debug' was given on the command-line.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SIDE EFFECTS:</COMMENT>
<COMMENT>##   Prints to STDERR</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>sub</KEYWORD> DbgPrintf {
    <FUNCTION>printf</FUNCTION> <CONSTANT>STDERR</CONSTANT> (<VARIABLE>@_</VARIABLE>) <KEYWORD>if</KEYWORD> (<VARIABLE>$OPTS</VARIABLE>{<STRING>'debug'</STRING>})<OPERATOR>;</OPERATOR>
}

<COMMENT>## Match a string against a set of keywords (case insensitive and</COMMENT>
<COMMENT>## allowing unique prefixes). Return the list of matching elements.</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## FUNCTION:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SYNOPSIS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## ARGUMENTS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## RETURN VALUE:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## PRECONDITIONS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SIDE EFFECTS:</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>sub</KEYWORD> MatchKwd {
    <KEYWORD>my</KEYWORD>(<VARIABLE>$str</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>@keywords</VARIABLE>) <OPERATOR>=</OPERATOR> <VARIABLE>@_</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>local</KEYWORD> <VARIABLE>$_</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>@matches</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>grep</FUNCTION>( <DELIMITER>m/</DELIMITER><REGEX>^${str}$</REGEX><DELIMITER>/</DELIMITER><KEYWORD>i</KEYWORD><OPERATOR>,</OPERATOR> <VARIABLE>@keywords</VARIABLE> )<OPERATOR>;</OPERATOR>
    <VARIABLE>@matches</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>grep</FUNCTION>( <DELIMITER>m/</DELIMITER><REGEX>^${str}</REGEX><DELIMITER>/</DELIMITER><KEYWORD>i</KEYWORD><OPERATOR>,</OPERATOR> <VARIABLE>@keywords</VARIABLE> ) <KEYWORD>if</KEYWORD> ( <VARIABLE>@matches</VARIABLE> <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC> )<OPERATOR>;</OPERATOR>
    <VARIABLE>@matches</VARIABLE><OPERATOR>;</OPERATOR>
}

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## FUNCTION:</COMMENT>
<COMMENT>##   CanonicalLangName -- Returns the canonical capitalization of one of</COMMENT>
<COMMENT>##   the languages supported by sclc, or undef if the language is not</COMMENT>
<COMMENT>##   supported</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SYNPOSIS:</COMMENT>
<COMMENT>##   CanonicalLangName("Fortran") -&gt; "FORTRAN"</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## ARGUMENTS:</COMMENT>
<COMMENT>##   A single string</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## RETURN VALUE:</COMMENT>
<COMMENT>##   The canonical spelling if the language is supported, else undef</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## PRECONDITIONS:</COMMENT>
<COMMENT>##   Global @Languages array must be defined and populated</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SIDE EFFECTS: None</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>sub</KEYWORD> CanonicalLangName {
    <KEYWORD>my</KEYWORD> <VARIABLE>$expr</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>shift</FUNCTION><OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>@matches</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>grep</FUNCTION>(<DELIMITER>/</DELIMITER><REGEX>^${expr}$</REGEX><DELIMITER>/</DELIMITER><KEYWORD>i</KEYWORD><OPERATOR>,</OPERATOR> <VARIABLE>@Languages</VARIABLE>)<OPERATOR>;</OPERATOR>
    <KEYWORD>if</KEYWORD> (<VARIABLE>@matches</VARIABLE> <OPERATOR>&gt;</OPERATOR> <NUMERIC>0</NUMERIC>) {
        <KEYWORD>return</KEYWORD> <VARIABLE>$matches</VARIABLE>[<NUMERIC>0</NUMERIC>]<OPERATOR>;</OPERATOR>
    } <KEYWORD>else</KEYWORD> {
        <KEYWORD>return</KEYWORD> <KEYWORD>undef</KEYWORD><OPERATOR>;</OPERATOR>
    }
}

<COMMENT>## Validate -language option</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## FUNCTION:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SYNOPSIS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## ARGUMENTS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## RETURN VALUE:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## PRECONDITIONS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SIDE EFFECTS:</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>sub</KEYWORD> CheckLanguage {
    <KEYWORD>my</KEYWORD>(<VARIABLE>@extspecs</VARIABLE>) <OPERATOR>=</OPERATOR> <VARIABLE>@_</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>local</KEYWORD>(<VARIABLE>$_</VARIABLE>)<OPERATOR>;</OPERATOR>
    <KEYWORD>foreach</KEYWORD> (<VARIABLE>@extspecs</VARIABLE>) {
        <KEYWORD>my</KEYWORD> (<VARIABLE>$ext</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$lang</VARIABLE>) <OPERATOR>=</OPERATOR> (<STRING>''</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$_</VARIABLE>)<OPERATOR>;</OPERATOR>
        (<VARIABLE>$ext</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$lang</VARIABLE>) <OPERATOR>=</OPERATOR> (<VARIABLE>$1</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$2</VARIABLE>) <KEYWORD>if</KEYWORD> (<DELIMITER>/</DELIMITER><REGEX>^([^=]*)=(.+)$</REGEX><DELIMITER>/</DELIMITER>)<OPERATOR>;</OPERATOR>
        <KEYWORD>if</KEYWORD> (<OPERATOR>!</OPERATOR> <VARIABLE>$lang</VARIABLE>) {
            ErrorMsg(<STRING>"invalid -language argument <ESC>\"</ESC>$_<ESC>\"</ESC>"</STRING>)<OPERATOR>;</OPERATOR>
            <OPERATOR>++</OPERATOR><VARIABLE>$ERRORS</VARIABLE><OPERATOR>;</OPERATOR>
            <KEYWORD>next</KEYWORD><OPERATOR>;</OPERATOR>
        }
        <KEYWORD>my</KEYWORD> <VARIABLE>$expr</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$lang</VARIABLE><OPERATOR>;</OPERATOR>
        <VARIABLE>$expr</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>s/</DELIMITER><REGEX>\W</REGEX><DELIMITER>/</DELIMITER><STRING><ESC>\\</ESC>$&amp;</STRING><DELIMITER>/</DELIMITER><KEYWORD>g</KEYWORD><OPERATOR>;</OPERATOR> <COMMENT># Prepend a backslash to all non-word chars (why?)</COMMENT>
        <KEYWORD>my</KEYWORD> <VARIABLE>$canon_lang</VARIABLE> <OPERATOR>=</OPERATOR> CanonicalLangName(<VARIABLE>$expr</VARIABLE>)<OPERATOR>;</OPERATOR>
        <KEYWORD>if</KEYWORD>(<OPERATOR>!</OPERATOR> <KEYWORD>defined</KEYWORD>(<VARIABLE>$canon_lang</VARIABLE>)) {
            ErrorMsg(<STRING>"Unknown programming language: <ESC>\"</ESC>$lang<ESC>\"</ESC>"</STRING>)<OPERATOR>;</OPERATOR>
            <OPERATOR>++</OPERATOR><VARIABLE>$ERRORS</VARIABLE><OPERATOR>;</OPERATOR>
        }
        <KEYWORD>if</KEYWORD> (<OPERATOR>!</OPERATOR> <VARIABLE>$ext</VARIABLE>) {
            <VARIABLE>$DEFAULT_LANG</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$canon_lang</VARIABLE><OPERATOR>;</OPERATOR>
        }
        <KEYWORD>elsif</KEYWORD> (<VARIABLE>$ext</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>m|</DELIMITER><REGEX>^/(.*)$</REGEX><DELIMITER>|</DELIMITER>) {
            <VARIABLE>$Interpreters</VARIABLE>{<VARIABLE>$1</VARIABLE>} <OPERATOR>=</OPERATOR> <VARIABLE>$canon_lang</VARIABLE><OPERATOR>;</OPERATOR>
        }
        <KEYWORD>else</KEYWORD> {
            <VARIABLE>$Suffixes</VARIABLE>{<VARIABLE>$ext</VARIABLE>} <OPERATOR>=</OPERATOR> <VARIABLE>$canon_lang</VARIABLE><OPERATOR>;</OPERATOR>
        }
    }
}

<COMMENT>## Validate -sections option</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## FUNCTION:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SYNOPSIS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## ARGUMENTS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## RETURN VALUE:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## PRECONDITIONS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SIDE EFFECTS:</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>sub</KEYWORD> CheckSections {
    <KEYWORD>local</KEYWORD>(<VARIABLE>$_</VARIABLE>)<OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>@secspecs</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>split</FUNCTION>(<DELIMITER>/</DELIMITER><REGEX>\W</REGEX><DELIMITER>/</DELIMITER><OPERATOR>,</OPERATOR> <VARIABLE>$OPTS</VARIABLE>{<STRING>'sections'</STRING>})<OPERATOR>;</OPERATOR>
    <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <VARIABLE>@secspecs</VARIABLE>) {
        ErrorMsg(<STRING>"invalid sections specifier <ESC>\"</ESC>$OPTS{'sections'}<ESC>\"</ESC>"</STRING>)<OPERATOR>;</OPERATOR>
        <OPERATOR>++</OPERATOR><VARIABLE>$ERRORS</VARIABLE><OPERATOR>;</OPERATOR>
    }
    <KEYWORD>else</KEYWORD> {
        <KEYWORD>my</KEYWORD> <VARIABLE>@matches</VARIABLE> <OPERATOR>=</OPERATOR> ()<OPERATOR>;</OPERATOR>
        <KEYWORD>foreach</KEYWORD> (<VARIABLE>@secspecs</VARIABLE>) {
            <VARIABLE>@matches</VARIABLE> <OPERATOR>=</OPERATOR> MatchKwd(<VARIABLE>$_</VARIABLE><OPERATOR>,</OPERATOR> <STRING>"header"</STRING><OPERATOR>,</OPERATOR> <STRING>"files"</STRING><OPERATOR>,</OPERATOR> <STRING>"langtotals"</STRING><OPERATOR>,</OPERATOR> <STRING>"totals"</STRING>)<OPERATOR>;</OPERATOR>
            <KEYWORD>if</KEYWORD> (<VARIABLE>@matches</VARIABLE> <OPERATOR>==</OPERATOR> <NUMERIC>1</NUMERIC>) {
                <OPERATOR>++</OPERATOR><VARIABLE>$SECS</VARIABLE>{<VARIABLE>$matches</VARIABLE>[<NUMERIC>0</NUMERIC>]}<OPERATOR>;</OPERATOR>
            } <KEYWORD>elsif</KEYWORD> (<VARIABLE>@matches</VARIABLE> <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC>) {
                ErrorMsg(<STRING>"invalid sections specifier <ESC>\"</ESC>$_<ESC>\"</ESC>"</STRING>)<OPERATOR>;</OPERATOR>
                <OPERATOR>++</OPERATOR><VARIABLE>$ERRORS</VARIABLE><OPERATOR>;</OPERATOR>
            } <KEYWORD>else</KEYWORD> {
                ErrorMsg(<STRING>"ambiguous sections specifier <ESC>\"</ESC>$_<ESC>\"</ESC>"</STRING>)<OPERATOR>;</OPERATOR>
                <OPERATOR>++</OPERATOR><VARIABLE>$ERRORS</VARIABLE><OPERATOR>;</OPERATOR>
            }
        }
    }
}

<COMMENT>## Validate -counts option</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## FUNCTION:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SYNOPSIS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## ARGUMENTS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## RETURN VALUE:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## PRECONDITIONS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SIDE EFFECTS:</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>

<KEYWORD>sub</KEYWORD> CheckCounts {
    <KEYWORD>local</KEYWORD>(<VARIABLE>$_</VARIABLE>)<OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>@cntspecs</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>split</FUNCTION>(<DELIMITER>/</DELIMITER><REGEX>\W</REGEX><DELIMITER>/</DELIMITER><OPERATOR>,</OPERATOR> <VARIABLE>$OPTS</VARIABLE>{<STRING>'counts'</STRING>})<OPERATOR>;</OPERATOR>
    <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <VARIABLE>@cntspecs</VARIABLE>) {
        ErrorMsg(<STRING>"invalid counts specifier <ESC>\"</ESC>$OPTS{'counts'}<ESC>\"</ESC>"</STRING>)<OPERATOR>;</OPERATOR>
        <OPERATOR>++</OPERATOR><VARIABLE>$ERRORS</VARIABLE><OPERATOR>;</OPERATOR>
    }
    <KEYWORD>else</KEYWORD> {
        <KEYWORD>my</KEYWORD> <VARIABLE>@matches</VARIABLE> <OPERATOR>=</OPERATOR> ()<OPERATOR>;</OPERATOR>
        <KEYWORD>foreach</KEYWORD> (<VARIABLE>@cntspecs</VARIABLE>) {
            <VARIABLE>@matches</VARIABLE> <OPERATOR>=</OPERATOR> MatchKwd(<VARIABLE>$_</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>@Count_Names</VARIABLE><OPERATOR>,</OPERATOR> <STRING>'all'</STRING>)<OPERATOR>;</OPERATOR>
            <KEYWORD>if</KEYWORD> (<VARIABLE>@matches</VARIABLE> <OPERATOR>==</OPERATOR> <NUMERIC>1</NUMERIC>) {
                <KEYWORD>if</KEYWORD> (<VARIABLE>$matches</VARIABLE>[<NUMERIC>0</NUMERIC>] <OPERATOR>eq</OPERATOR> <STRING>'all'</STRING>) {
                    <KEYWORD>for</KEYWORD> (<VARIABLE>@Count_Names</VARIABLE>) {
                        <KEYWORD>next</KEYWORD> <KEYWORD>if</KEYWORD> <VARIABLE>$_</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>'AESL'</STRING><OPERATOR>;</OPERATOR> <COMMENT># skip this one</COMMENT>
                        <OPERATOR>++</OPERATOR><VARIABLE>$CNTS</VARIABLE>{<FUNCTION>lc</FUNCTION> <VARIABLE>$_</VARIABLE>}<OPERATOR>;</OPERATOR>
                    }
                } <KEYWORD>else</KEYWORD> {
                    <OPERATOR>++</OPERATOR><VARIABLE>$CNTS</VARIABLE>{<FUNCTION>lc</FUNCTION> <VARIABLE>$matches</VARIABLE>[<NUMERIC>0</NUMERIC>]}<OPERATOR>;</OPERATOR>
                }
            }
            <KEYWORD>elsif</KEYWORD> (<VARIABLE>@matches</VARIABLE> <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC>) {
                ErrorMsg(<STRING>"invalid counts specifier <ESC>\"</ESC>$_<ESC>\"</ESC>"</STRING>)<OPERATOR>;</OPERATOR>
                <OPERATOR>++</OPERATOR><VARIABLE>$ERRORS</VARIABLE><OPERATOR>;</OPERATOR>
            }
            <KEYWORD>else</KEYWORD> {
                ErrorMsg(<STRING>"ambiguous counts specifier <ESC>\"</ESC>$_<ESC>\"</ESC>"</STRING>)<OPERATOR>;</OPERATOR>
                <OPERATOR>++</OPERATOR><VARIABLE>$ERRORS</VARIABLE><OPERATOR>;</OPERATOR>
            }
        }
    }
}

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## FUNCTION:</COMMENT>
<COMMENT>##   SplitPath -- Split a pathname into dirname and basename components</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SYNOPSIS:</COMMENT>
<COMMENT>##   ($dirname, $basename, $vcsuffix) = SplitPath($pname);</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## ARGUMENTS:</COMMENT>
<COMMENT>##   $pname : The pathname of a file</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## RETURN VALUE:</COMMENT>
<COMMENT>##   Returns the array ($dirname, $basename, $vcsuffix)</COMMENT>
<COMMENT>##   where $vcsuffix is the portion of the string (if any) the follows</COMMENT>
<COMMENT>##   the first occurrence of $OPTS{'vcstring'}</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## PRECONDITIONS:</COMMENT>
<COMMENT>##   Assumes the global $OPTS{'vcstring'} is the version-control systems</COMMENT>
<COMMENT>##   separator text for splitting a pathname from its version.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SIDE EFFECTS: None.</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>sub</KEYWORD> SplitPath {
    <KEYWORD>local</KEYWORD>(<VARIABLE>$_</VARIABLE>) <OPERATOR>=</OPERATOR> <VARIABLE>@_</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD>(<VARIABLE>$dirname</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$basename</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$vcsuffix</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$i</VARIABLE>)<OPERATOR>;</OPERATOR>
    <KEYWORD>if</KEYWORD> (<VARIABLE>$OPTS</VARIABLE>{<STRING>'vcstring'</STRING>}) {
        <VARIABLE>$i</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>index</FUNCTION>(<VARIABLE>$_</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$OPTS</VARIABLE>{<STRING>'vcstring'</STRING>})<OPERATOR>;</OPERATOR>
        <KEYWORD>unless</KEYWORD> (<VARIABLE>$i</VARIABLE> <OPERATOR>&lt;</OPERATOR> <NUMERIC>0</NUMERIC>) {
            <VARIABLE>$vcsuffix</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>substr</FUNCTION>(<VARIABLE>$_</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$i</VARIABLE><OPERATOR>+</OPERATOR><NUMERIC>1</NUMERIC>)<OPERATOR>;</OPERATOR>
            <VARIABLE>$_</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>substr</FUNCTION>(<VARIABLE>$_</VARIABLE><OPERATOR>,</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>,</OPERATOR> <VARIABLE>$i</VARIABLE>)<OPERATOR>;</OPERATOR>
        }
    }
    (<VARIABLE>$dirname</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$basename</VARIABLE>) <OPERATOR>=</OPERATOR> (<STRING>'.'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$_</VARIABLE>)<OPERATOR>;</OPERATOR>
    <VARIABLE>$i</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>rindex</FUNCTION>(<VARIABLE>$_</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$Path_Sep</VARIABLE>)<OPERATOR>;</OPERATOR>
    <KEYWORD>unless</KEYWORD> (<VARIABLE>$i</VARIABLE> <OPERATOR>&lt;</OPERATOR> <NUMERIC>0</NUMERIC>) {
        <VARIABLE>$dirname</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>substr</FUNCTION>(<VARIABLE>$_</VARIABLE><OPERATOR>,</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>,</OPERATOR> <VARIABLE>$i</VARIABLE>)<OPERATOR>;</OPERATOR>
        <VARIABLE>$basename</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>substr</FUNCTION>(<VARIABLE>$_</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$i</VARIABLE><OPERATOR>+</OPERATOR><NUMERIC>1</NUMERIC>)<OPERATOR>;</OPERATOR>
    }
    (<VARIABLE>$dirname</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$basename</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$vcsuffix</VARIABLE>)<OPERATOR>;</OPERATOR>
}

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## FUNCTION:</COMMENT>
<COMMENT>##   ExcludeFile -- See if a file should be excluded from processing.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SYNOPSIS:</COMMENT>
<COMMENT>##   if (ExcludeFile($pname)) { ... }</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## ARGUMENTS:</COMMENT>
<COMMENT>##   $pname : The pathname of a file that we may wish to process.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## RETURN VALUE:</COMMENT>
<COMMENT>##   TRUE if the file should be excluded from processing,</COMMENT>
<COMMENT>##   FALSE otherwise.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## PRECONDITIONS:</COMMENT>
<COMMENT>##   Uses the following globals:</COMMENT>
<COMMENT>##      $OPTS{'except'} -- list of regexps matching files to exclude</COMMENT>
<COMMENT>##      $OPTS{'name'} -- list of regexps matching files to include</COMMENT>
<COMMENT>##      $OPTS{'default_exclude'} -- causes preset exclusions</COMMENT>
<COMMENT>##      $OPTS{'excludedir'} -- list of regexps matching paths to exclude</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SIDE EFFECTS: None.</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>sub</KEYWORD> ExcludeFile {
    <KEYWORD>my</KEYWORD> <VARIABLE>$pathname</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$_</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>local</KEYWORD>(<VARIABLE>$_</VARIABLE>) <OPERATOR>=</OPERATOR> <VARIABLE>@_</VARIABLE><OPERATOR>;</OPERATOR>
    <COMMENT>## see if we should exclude this file from the list</COMMENT>
    <KEYWORD>if</KEYWORD> ((@{ <VARIABLE>$OPTS</VARIABLE>{<STRING>'name'</STRING>} } <OPERATOR>&gt;</OPERATOR> <NUMERIC>0</NUMERIC>) <OPERATOR>||</OPERATOR> (@{ <VARIABLE>$OPTS</VARIABLE>{<STRING>'except'</STRING>} } <OPERATOR>&gt;</OPERATOR> <NUMERIC>0</NUMERIC>)) {
        <KEYWORD>my</KEYWORD>(<VARIABLE>$dirname</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$basename</VARIABLE>) <OPERATOR>=</OPERATOR> SplitPath(<VARIABLE>$_</VARIABLE>)<OPERATOR>;</OPERATOR>
        <KEYWORD>my</KEYWORD> <VARIABLE>@matches</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>grep</FUNCTION>(<VARIABLE>$basename</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>^$_$</REGEX><DELIMITER>/</DELIMITER><OPERATOR>,</OPERATOR> @{ <VARIABLE>$OPTS</VARIABLE>{<STRING>'except'</STRING>} })<OPERATOR>;</OPERATOR>
        <KEYWORD>return</KEYWORD> <NUMERIC>1</NUMERIC>  <KEYWORD>if</KEYWORD> (<VARIABLE>@matches</VARIABLE> <OPERATOR>&gt;</OPERATOR> <NUMERIC>0</NUMERIC>)<OPERATOR>;</OPERATOR> <COMMENT>## this is an exception</COMMENT>
        <KEYWORD>if</KEYWORD> (@{ <VARIABLE>$OPTS</VARIABLE>{<STRING>'name'</STRING>} } <OPERATOR>&gt;</OPERATOR> <NUMERIC>0</NUMERIC>) {
            <COMMENT>## only accept if we have a match</COMMENT>
            <VARIABLE>@matches</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>grep</FUNCTION>(<VARIABLE>$basename</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>^$_$</REGEX><DELIMITER>/</DELIMITER><OPERATOR>,</OPERATOR> @{ <VARIABLE>$OPTS</VARIABLE>{<STRING>'name'</STRING>} })<OPERATOR>;</OPERATOR>
            <KEYWORD>return</KEYWORD> <NUMERIC>1</NUMERIC>  <KEYWORD>if</KEYWORD> (<VARIABLE>@matches</VARIABLE> <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC>)<OPERATOR>;</OPERATOR> <COMMENT>## no match</COMMENT>
        }
    }

    <COMMENT># check for default exclusions</COMMENT>
    <KEYWORD>if</KEYWORD>(<VARIABLE>$OPTS</VARIABLE>{<STRING>'default_exclude'</STRING>}) {
        <KEYWORD>foreach</KEYWORD> <KEYWORD>my</KEYWORD> <VARIABLE>$ex_pattern</VARIABLE> (<VARIABLE>@EXCLUDES</VARIABLE>) {
            <KEYWORD>if</KEYWORD>(<VARIABLE>$pathname</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>m/</DELIMITER><REGEX>$ex_pattern</REGEX><DELIMITER>/</DELIMITER>) {

                <COMMENT># matches exclude pattern</COMMENT>
                <KEYWORD>return</KEYWORD> <NUMERIC>1</NUMERIC><OPERATOR>;</OPERATOR> <COMMENT># don't use this file</COMMENT>
            }
        }
    }

    <COMMENT># check for user excludes</COMMENT>
    <KEYWORD>if</KEYWORD>( @{ <VARIABLE>$OPTS</VARIABLE>{<STRING>'excludedir'</STRING>} } <OPERATOR>&gt;</OPERATOR> <NUMERIC>0</NUMERIC>) {
        <KEYWORD>my</KEYWORD> <VARIABLE>@user_excludes</VARIABLE> <OPERATOR>=</OPERATOR> @{ <VARIABLE>$OPTS</VARIABLE>{<STRING>'excludedir'</STRING>} }<OPERATOR>;</OPERATOR>
        <KEYWORD>foreach</KEYWORD> <KEYWORD>my</KEYWORD> <VARIABLE>$user_pattern</VARIABLE> (<VARIABLE>@user_excludes</VARIABLE>) {
            <KEYWORD>if</KEYWORD>(<VARIABLE>$pathname</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>m/</DELIMITER><REGEX>$user_pattern</REGEX><DELIMITER>/</DELIMITER>) {

                <COMMENT>#matches pattern, don't use</COMMENT>
                <KEYWORD>return</KEYWORD> <NUMERIC>1</NUMERIC><OPERATOR>;</OPERATOR>
            }
        }
    }
    <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
}

<COMMENT>## Return the reference name for the language-definition arrays</COMMENT>
<COMMENT>## of this language.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## FUNCTION:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SYNOPSIS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## ARGUMENTS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## RETURN VALUE:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## PRECONDITIONS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SIDE EFFECTS:</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>sub</KEYWORD> RefLanguage {
    <KEYWORD>my</KEYWORD>(<VARIABLE>$lang</VARIABLE>) <OPERATOR>=</OPERATOR> <VARIABLE>@_</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>local</KEYWORD>(<VARIABLE>$_</VARIABLE>) <OPERATOR>=</OPERATOR> <VARIABLE>$lang</VARIABLE><OPERATOR>;</OPERATOR>
    <COMMENT>## Figure out the language-specific pair of arrays to use</COMMENT>
    <KEYWORD>if</KEYWORD> (<VARIABLE>$lang</VARIABLE>) {
        <VARIABLE>$_</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>"C"</STRING> <KEYWORD>if</KEYWORD> (<VARIABLE>$lang</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>"C++"</STRING>)<OPERATOR>;</OPERATOR> <COMMENT>## C &amp; C++ use the same arrays</COMMENT>
        <COMMENT>## Arrays are named &lt;LANG&gt;_DEFNS and &lt;LANG&gt;_EVALS where &lt;LANG&gt; is</COMMENT>
        <COMMENT>## all uppercase with non-alphanumerics removed</COMMENT>
        <DELIMITER>s/</DELIMITER><REGEX>\W</REGEX><DELIMITER>/</DELIMITER><STRING></STRING><DELIMITER>/</DELIMITER><KEYWORD>g</KEYWORD><OPERATOR>;</OPERATOR>
        <DELIMITER>s/</DELIMITER><REGEX>[a-z]</REGEX><DELIMITER>/</DELIMITER><STRING><ESC>\U</ESC>$&amp;</STRING><DELIMITER>/</DELIMITER><KEYWORD>g</KEYWORD><OPERATOR>;</OPERATOR>
    }
    <VARIABLE>$_</VARIABLE><OPERATOR>;</OPERATOR>
}

<COMMENT>## Guess the language based on the contents of the given text line</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## FUNCTION:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SYNOPSIS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## ARGUMENTS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## RETURN VALUE:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## PRECONDITIONS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SIDE EFFECTS:</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>sub</KEYWORD> GuessLanguage {
    <KEYWORD>local</KEYWORD>(<VARIABLE>$_</VARIABLE>) <OPERATOR>=</OPERATOR> <VARIABLE>@_</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD>(<VARIABLE>$lang</VARIABLE>) <OPERATOR>=</OPERATOR> <STRING>""</STRING><OPERATOR>;</OPERATOR>
    <KEYWORD>if</KEYWORD> (<VARIABLE>$DEFAULT_LANG</VARIABLE>) {
        <VARIABLE>$lang</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$DEFAULT_LANG</VARIABLE><OPERATOR>;</OPERATOR>
    }
    <KEYWORD>elsif</KEYWORD> (<DELIMITER>m/</DELIMITER><REGEX>^\s*\#\s*(include|if|ifdef|define)\b</REGEX><DELIMITER>/</DELIMITER>) {
        <VARIABLE>$lang</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>"C"</STRING><OPERATOR>;</OPERATOR>
    }
    <KEYWORD>elsif</KEYWORD> (<DELIMITER>m|</DELIMITER><REGEX>^\s*/\*\*\s*$</REGEX><DELIMITER>|</DELIMITER>) {
        <VARIABLE>$lang</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>"Java"</STRING><OPERATOR>;</OPERATOR>
    }
    <KEYWORD>elsif</KEYWORD> (<DELIMITER>m|</DELIMITER><REGEX>^\s*/\*</REGEX><DELIMITER>|</DELIMITER>) {
        <VARIABLE>$lang</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>"C"</STRING><OPERATOR>;</OPERATOR>
    }
    <KEYWORD>elsif</KEYWORD> (<DELIMITER>m|</DELIMITER><REGEX>^\s*//</REGEX><DELIMITER>|</DELIMITER>) {
        <VARIABLE>$lang</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>"C++"</STRING><OPERATOR>;</OPERATOR>
    }
    <KEYWORD>elsif</KEYWORD> (<DELIMITER>/</DELIMITER><REGEX>\(\*.*\*\)</REGEX><DELIMITER>/</DELIMITER>) {
        <VARIABLE>$lang</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>"Mathematica"</STRING><OPERATOR>;</OPERATOR>
    }
    <KEYWORD>elsif</KEYWORD> (<DELIMITER>/</DELIMITER><REGEX>^\s*\{</REGEX><DELIMITER>/</DELIMITER>) {
        <VARIABLE>$lang</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>"Pascal"</STRING><OPERATOR>;</OPERATOR>
    }
    <KEYWORD>elsif</KEYWORD> (<DELIMITER>/</DELIMITER><REGEX>^\s*--</REGEX><DELIMITER>/</DELIMITER>) {
        <COMMENT>## $lang = "Ada";         ## or it could be Eiffel, ZPL or Chapel</COMMENT>
    }
    <KEYWORD>elsif</KEYWORD> (<DELIMITER>/</DELIMITER><REGEX>^\s*[\(;]</REGEX><DELIMITER>/</DELIMITER>) {
        <VARIABLE>$lang</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>"Lisp"</STRING><OPERATOR>;</OPERATOR>
    }
    <KEYWORD>elsif</KEYWORD> (<DELIMITER>/</DELIMITER><REGEX>^\s*\*</REGEX><DELIMITER>/</DELIMITER>) {
        <COMMENT>## $lang = "Assembly";</COMMENT>
    }

    <COMMENT># DO NOT USE: m:^\s*\#\s*\!\s*\S+$Path_Sep(\S+):</COMMENT>
    <COMMENT># IT IS INCOMPATIBLE ON WINDOWS</COMMENT>
    <KEYWORD>elsif</KEYWORD> (<DELIMITER>m|</DELIMITER><REGEX>^\s*#\s*\!\s*\S+[\\/]([^\\/\s]+)\s*</REGEX><DELIMITER>|</DELIMITER>) {
        <KEYWORD>my</KEYWORD> <VARIABLE>$execname</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$1</VARIABLE><OPERATOR>;</OPERATOR>  <COMMENT>## get the name of the program to exec</COMMENT>
        <COMMENT>## Remove the extension if we can't find its name</COMMENT>
        <VARIABLE>$execname</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>s/</DELIMITER><REGEX>\.[^.]*$</REGEX><DELIMITER>/</DELIMITER><STRING></STRING><DELIMITER>/</DELIMITER>   <KEYWORD>unless</KEYWORD> (<KEYWORD>defined</KEYWORD> <VARIABLE>$Interpreters</VARIABLE>{<VARIABLE>$execname</VARIABLE>})<OPERATOR>;</OPERATOR>
        <COMMENT>## Remove trailing numbers if we still can't find its name</COMMENT>
        <VARIABLE>$execname</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>s/</DELIMITER><REGEX>\d[.\d]*$</REGEX><DELIMITER>/</DELIMITER><STRING></STRING><DELIMITER>/</DELIMITER>  <KEYWORD>unless</KEYWORD> (<KEYWORD>defined</KEYWORD> <VARIABLE>$Interpreters</VARIABLE>{<VARIABLE>$execname</VARIABLE>})<OPERATOR>;</OPERATOR>
        <VARIABLE>$lang</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$Interpreters</VARIABLE>{<VARIABLE>$execname</VARIABLE>} <KEYWORD>if</KEYWORD> (<KEYWORD>defined</KEYWORD> <VARIABLE>$Interpreters</VARIABLE>{<VARIABLE>$execname</VARIABLE>})<OPERATOR>;</OPERATOR>
    }
    <KEYWORD>elsif</KEYWORD> (<DELIMITER>/</DELIMITER><REGEX>^\s*#</REGEX><DELIMITER>/</DELIMITER>) {
        <VARIABLE>$lang</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>"shell"</STRING><OPERATOR>;</OPERATOR>
    }

    <VARIABLE>$lang</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$DEFAULT_LANG</VARIABLE> <KEYWORD>if</KEYWORD> (<VARIABLE>$DEFAULT_LANG</VARIABLE> <OPERATOR>&amp;&amp;</OPERATOR> (<OPERATOR>!</OPERATOR> <VARIABLE>$lang</VARIABLE>))<OPERATOR>;</OPERATOR>

    <KEYWORD>my</KEYWORD> <VARIABLE>$ref</VARIABLE> <OPERATOR>=</OPERATOR> RefLanguage(<VARIABLE>$lang</VARIABLE>)<OPERATOR>;</OPERATOR>
    (<VARIABLE>$LANG_NAME</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$LANG_REF</VARIABLE>) <OPERATOR>=</OPERATOR> (<VARIABLE>$lang</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$ref</VARIABLE>)<OPERATOR>;</OPERATOR>
}

<COMMENT>## Determine the source language based on the filename</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## FUNCTION:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SYNOPSIS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## ARGUMENTS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## RETURN VALUE:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## PRECONDITIONS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SIDE EFFECTS:</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>sub</KEYWORD> SetLanguage {
    <KEYWORD>my</KEYWORD> (<VARIABLE>$filepath</VARIABLE>) <OPERATOR>=</OPERATOR> <VARIABLE>@_</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>local</KEYWORD>(<VARIABLE>$_</VARIABLE>) <OPERATOR>=</OPERATOR> <VARIABLE>$filepath</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>$lang</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>""</STRING><OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> (<VARIABLE>$dirname</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$basename</VARIABLE>) <OPERATOR>=</OPERATOR> SplitPath(<VARIABLE>$_</VARIABLE>)<OPERATOR>;</OPERATOR>
    <COMMENT>## Before suffix checking, check for double suffix issues</COMMENT>
    <COMMENT># if($basename =~ /\.par\./) {</COMMENT>
    <COMMENT>#	$lang = "FlashParameter";</COMMENT>
    <COMMENT># }</COMMENT>
    <COMMENT># If it starts with Config. it's a Config file</COMMENT>
    <COMMENT># elsif ($ basename =~ /^Config\./) {</COMMENT>
    <COMMENT>#	$lang = "FlashConfig";</COMMENT>
    <COMMENT># }</COMMENT>
    <COMMENT>## First see if we have a '.' suffix</COMMENT>
    <KEYWORD>if</KEYWORD> (<VARIABLE>$basename</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>.+(\.[^.]+)$</REGEX><DELIMITER>/</DELIMITER>) {
        <VARIABLE>$lang</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$Suffixes</VARIABLE>{<VARIABLE>$1</VARIABLE>} <KEYWORD>if</KEYWORD> (<KEYWORD>defined</KEYWORD> <VARIABLE>$Suffixes</VARIABLE>{<VARIABLE>$1</VARIABLE>})<OPERATOR>;</OPERATOR>
    }

<COMMENT># elsif ($basename =~ /^makefile/i) {</COMMENT>
<COMMENT>#    $lang = "make";</COMMENT>
<COMMENT># }</COMMENT>
<COMMENT># elsif( $basename =~ /^Config$/i) {</COMMENT>
<COMMENT>#    $lang = "FlashConfig";</COMMENT>
<COMMENT># }</COMMENT>
<COMMENT># elsif( $basename eq "README" || $basename eq "INSTALL" || $basename eq "<COMMENT_NOTE>TODO</COMMENT_NOTE>") {</COMMENT>
<COMMENT>#    $lang = "Text";</COMMENT>
<COMMENT># }</COMMENT>
    <KEYWORD>elsif</KEYWORD> (<VARIABLE>$filepath</VARIABLE> <OPERATOR>ne</OPERATOR> <STRING>'-'</STRING>) {
        <COMMENT>## Not a normal '.' suffix, have to look at all of them</COMMENT>
        <KEYWORD>my</KEYWORD> <VARIABLE>%seen</VARIABLE> <OPERATOR>=</OPERATOR> ()<OPERATOR>;</OPERATOR>
        <KEYWORD>foreach</KEYWORD> (<FUNCTION>keys</FUNCTION> <VARIABLE>%Suffixes</VARIABLE>) {
            <KEYWORD>next</KEYWORD> <KEYWORD>unless</KEYWORD> (<VARIABLE>$_</VARIABLE>)<OPERATOR>;</OPERATOR>
            <KEYWORD>next</KEYWORD> <KEYWORD>if</KEYWORD> (<KEYWORD>defined</KEYWORD> <VARIABLE>$seen</VARIABLE>{<VARIABLE>$_</VARIABLE>})<OPERATOR>;</OPERATOR>
            <OPERATOR>++</OPERATOR><VARIABLE>$seen</VARIABLE>{<VARIABLE>$_</VARIABLE>}<OPERATOR>;</OPERATOR>
            <DELIMITER>s/</DELIMITER><REGEX>\W</REGEX><DELIMITER>/</DELIMITER><STRING><ESC>\\</ESC>$&amp;</STRING><DELIMITER>/</DELIMITER><KEYWORD>g</KEYWORD><OPERATOR>;</OPERATOR>    <COMMENT>## escape regexp meta-characters</COMMENT>
            <VARIABLE>$lang</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$Suffixes</VARIABLE>{<VARIABLE>$_</VARIABLE>} <KEYWORD>if</KEYWORD> (<VARIABLE>$basename</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>m|</DELIMITER><REGEX>^.+$_$</REGEX><DELIMITER>|</DELIMITER>)<OPERATOR>;</OPERATOR>
            <KEYWORD>last</KEYWORD> <KEYWORD>if</KEYWORD> (<VARIABLE>$lang</VARIABLE>)<OPERATOR>;</OPERATOR>
        }
    }
    <KEYWORD>if</KEYWORD> (<VARIABLE>$OPTS</VARIABLE>{<STRING>'mapping'</STRING>}) {
        <COMMENT># print ("Mapping is specified!\n");</COMMENT>
        <KEYWORD>my</KEYWORD> <VARIABLE>$lang_candidate</VARIABLE> <OPERATOR>=</OPERATOR> MappingFileType(<VARIABLE>$basename</VARIABLE>)<OPERATOR>;</OPERATOR>
        <KEYWORD>if</KEYWORD> (<KEYWORD>defined</KEYWORD>(<VARIABLE>$lang_candidate</VARIABLE>)) {
            <COMMENT># Check if it's a real language</COMMENT>
            <VARIABLE>$lang</VARIABLE> <OPERATOR>=</OPERATOR> CanonicalLangName(<VARIABLE>$lang_candidate</VARIABLE>)<OPERATOR>;</OPERATOR>
            <KEYWORD>if</KEYWORD>(<OPERATOR>!</OPERATOR><KEYWORD>defined</KEYWORD>(<VARIABLE>$lang</VARIABLE>)) {
                FatalMsg(<STRING>"Unknown programming language in mapping file: <ESC>\"</ESC>$lang_candidate<ESC>\"</ESC>"</STRING>)<OPERATOR>;</OPERATOR>
            }
        }
    }
    <KEYWORD>if</KEYWORD> (<VARIABLE>$lang</VARIABLE>) {
        <VARIABLE>$lang</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>"C++"</STRING> <KEYWORD>if</KEYWORD> ((<VARIABLE>$lang</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>"C"</STRING>) <OPERATOR>&amp;&amp;</OPERATOR> (<VARIABLE>$DEFAULT_LANG</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>"C++"</STRING>))<OPERATOR>;</OPERATOR>
        <KEYWORD>my</KEYWORD> <VARIABLE>$ref</VARIABLE> <OPERATOR>=</OPERATOR> RefLanguage(<VARIABLE>$lang</VARIABLE>) <OPERATOR>||</OPERATOR> <STRING>""</STRING><OPERATOR>;</OPERATOR>
        (<VARIABLE>$LANG_NAME</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$LANG_REF</VARIABLE>) <OPERATOR>=</OPERATOR> (<VARIABLE>$lang</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$ref</VARIABLE>)<OPERATOR>;</OPERATOR>
    }
    <KEYWORD>else</KEYWORD> {
        <COMMENT>## If we still dont know the language -- see if we can tell by</COMMENT>
        <COMMENT>## looking at the contents of the first non-blank line</COMMENT>
        <KEYWORD>my</KEYWORD> <VARIABLE>$found_line</VARIABLE><OPERATOR>=</OPERATOR><NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
        <KEYWORD>if</KEYWORD> (<VARIABLE>$filepath</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>'-'</STRING>) {
            <VARIABLE>$_</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>''</STRING><OPERATOR>;</OPERATOR>
        }
        <KEYWORD>elsif</KEYWORD> (<FUNCTION>open</FUNCTION>(<CONSTANT>FILEPATH</CONSTANT><OPERATOR>,</OPERATOR> <VARIABLE>$filepath</VARIABLE>)) {
            <KEYWORD>while</KEYWORD> (<OPERATOR>&lt;</OPERATOR><CONSTANT>FILEPATH</CONSTANT><OPERATOR>&gt;</OPERATOR>) {
                <KEYWORD>if</KEYWORD> ( <DELIMITER>/</DELIMITER><REGEX>^\s$</REGEX><DELIMITER>/</DELIMITER> ) {
                    <FUNCTION>chop</FUNCTION><OPERATOR>;</OPERATOR>
                }
                <KEYWORD>else</KEYWORD> {
                    <VARIABLE>$found_line</VARIABLE> <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC><OPERATOR>;</OPERATOR>
                    <KEYWORD>last</KEYWORD><OPERATOR>;</OPERATOR>
                }
            }
            <FUNCTION>close</FUNCTION>(<CONSTANT>FILEPATH</CONSTANT>)<OPERATOR>;</OPERATOR>
        }
        <KEYWORD>if</KEYWORD>( <OPERATOR>!</OPERATOR> <VARIABLE>$found_line</VARIABLE>) {
            <KEYWORD>my</KEYWORD> <VARIABLE>$ref</VARIABLE> <OPERATOR>=</OPERATOR> RefLanguage(<VARIABLE>$DEFAULT_LANG</VARIABLE>)<OPERATOR>||</OPERATOR><STRING>""</STRING><OPERATOR>;</OPERATOR>
            (<VARIABLE>$LANG_NAME</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$LANG_REF</VARIABLE>) <OPERATOR>=</OPERATOR> (<VARIABLE>$DEFAULT_LANG</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$ref</VARIABLE>)<OPERATOR>;</OPERATOR>
        }
        <KEYWORD>else</KEYWORD> {
            GuessLanguage(<VARIABLE>$_</VARIABLE>)<OPERATOR>;</OPERATOR>
        }
    }
}

<COMMENT>## See if the given line matches a -separate expression from the command-line</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## FUNCTION:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SYNOPSIS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## ARGUMENTS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## RETURN VALUE:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## PRECONDITIONS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SIDE EFFECTS:</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>sub</KEYWORD> IsSeparator {
    <KEYWORD>local</KEYWORD>(<VARIABLE>$_</VARIABLE>) <OPERATOR>=</OPERATOR> <VARIABLE>@_</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>return</KEYWORD> <NUMERIC>0</NUMERIC> <KEYWORD>if</KEYWORD> (@{ <VARIABLE>$OPTS</VARIABLE>{<STRING>'separate'</STRING>} } <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC>)<OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>$regexp</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>foreach</KEYWORD> <VARIABLE>$regexp</VARIABLE> (@{ <VARIABLE>$OPTS</VARIABLE>{<STRING>'separate'</STRING>} }) {
        <KEYWORD>return</KEYWORD> <NUMERIC>1</NUMERIC> <KEYWORD>if</KEYWORD> (<DELIMITER>/</DELIMITER><REGEX>^(?:$regexp)$</REGEX><DELIMITER>/</DELIMITER>)<OPERATOR>;</OPERATOR>
    }
    <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
}

<COMMENT>## Token -- Count various kinds of token; optionally list them.</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>sub</KEYWORD> Token {
    <KEYWORD>my</KEYWORD> (<VARIABLE>$counts</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$dtype</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$ttype</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$token</VARIABLE>) <OPERATOR>=</OPERATOR> <VARIABLE>@_</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>$tok</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$dtype</VARIABLE><OPERATOR>.</OPERATOR><VARIABLE>$ttype</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>$n</VARIABLE> <OPERATOR>=</OPERATOR> <OPERATOR>++</OPERATOR><VARIABLE>$$</VARIABLE>counts{<VARIABLE>$tok</VARIABLE>}<OPERATOR>;</OPERATOR>
    <OPERATOR>++</OPERATOR><VARIABLE>$$</VARIABLE>counts{<VARIABLE>$dtype</VARIABLE><OPERATOR>.</OPERATOR><STRING>'TPtoks'</STRING>}<OPERATOR>;</OPERATOR>
    DbgPrintf(<STRING>"%4d %s  %s<ESC>\n</ESC>"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$n</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$tok</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$token</VARIABLE>)<OPERATOR>;</OPERATOR>
}

<COMMENT>## SourceCount -- Count the lines, blank-lines, comments, NCSL, tokens, etc.</COMMENT>
<COMMENT>##                in the given source file (a filename of '-' means use STDIN).</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## returns the array %counts upon success,</COMMENT>
<COMMENT>## If the file can't be opened, then returns ('Error', "Error")</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## FUNCTION:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SYNOPSIS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## ARGUMENTS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## RETURN VALUE:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## PRECONDITIONS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SIDE EFFECTS:</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>use</KEYWORD> vars <DELIMITER>qw(</DELIMITER><STRING>@langEvals</STRING> <STRING>%langDefns</STRING><DELIMITER>)</DELIMITER><OPERATOR>;</OPERATOR>

<KEYWORD>sub</KEYWORD> SourceCount {
    <KEYWORD>my</KEYWORD> <VARIABLE>$filename</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>shift</FUNCTION><OPERATOR>;</OPERATOR>
    <KEYWORD>local</KEYWORD>(<OPERATOR>*</OPERATOR>langEvals<OPERATOR>,</OPERATOR> <OPERATOR>*</OPERATOR>langDefns) <OPERATOR>=</OPERATOR> <VARIABLE>@_</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>%error</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'Error'</STRING><OPERATOR>,</OPERATOR> <STRING>"Error"</STRING>)<OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>$filehandle</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>local</KEYWORD>(<VARIABLE>$_</VARIABLE>)<OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>$diffType</VARIABLE><OPERATOR>;</OPERATOR>       <COMMENT>## one of '' or '&lt;' or '&gt;'</COMMENT>
    <KEYWORD>my</KEYWORD> (<VARIABLE>$inComment</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$inQuote</VARIABLE>) <OPERATOR>=</OPERATOR> (<NUMERIC>0</NUMERIC><OPERATOR>,</OPERATOR> <STRING>''</STRING>)<OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>%counts</VARIABLE> <OPERATOR>=</OPERATOR> ()<OPERATOR>;</OPERATOR>

    <COMMENT>## Fill in any missing langDefns</COMMENT>
    <KEYWORD>for</KEYWORD> (<FUNCTION>keys</FUNCTION> <VARIABLE>%DEFAULT_DEFNS</VARIABLE>) {
        <VARIABLE>$langDefns</VARIABLE>{<VARIABLE>$_</VARIABLE>} <OPERATOR>=</OPERATOR> <VARIABLE>$DEFAULT_DEFNS</VARIABLE>{<VARIABLE>$_</VARIABLE>} <KEYWORD>unless</KEYWORD> <FUNCTION>exists</FUNCTION> <VARIABLE>$langDefns</VARIABLE>{<VARIABLE>$_</VARIABLE>}<OPERATOR>;</OPERATOR>
    }

    <COMMENT>## Open input</COMMENT>
    <KEYWORD>if</KEYWORD> ((<VARIABLE>$filename</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>"-"</STRING>) <OPERATOR>&amp;&amp;</OPERATOR> <OPERATOR>!</OPERATOR>(<VARIABLE>$OPTS</VARIABLE>{<STRING>'filelist'</STRING>} <OPERATOR>&amp;&amp;</OPERATOR> (<VARIABLE>@ARGV</VARIABLE> <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC>))) {
        <VARIABLE>$filehandle</VARIABLE> <OPERATOR>=</OPERATOR> <OPERATOR>\*</OPERATOR><CONSTANT>STDIN</CONSTANT><OPERATOR>;</OPERATOR>
    }
    <KEYWORD>else</KEYWORD> {
        <KEYWORD>if</KEYWORD> (<VARIABLE>$OPTS</VARIABLE>{<STRING>'pred'</STRING>} <OPERATOR>||</OPERATOR> <VARIABLE>$OPTS</VARIABLE>{<STRING>'fromversion'</STRING>} <OPERATOR>||</OPERATOR> <VARIABLE>$OPTS</VARIABLE>{<STRING>'toversion'</STRING>}) {
            <COMMENT>## invoke cdiff using ClearCase version selectors</COMMENT>
            <KEYWORD>my</KEYWORD> <VARIABLE>$from_pname</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$filename</VARIABLE><OPERATOR>;</OPERATOR>
            <KEYWORD>my</KEYWORD> <VARIABLE>$to_pname</VARIABLE>   <OPERATOR>=</OPERATOR> <VARIABLE>$filename</VARIABLE><OPERATOR>;</OPERATOR>
            <VARIABLE>$from_pname</VARIABLE>      <OPERATOR>.=</OPERATOR> <STRING>"<ESC>\@</ESC><ESC>\@</ESC>$OPTS{'fromversion'}"</STRING>  <KEYWORD>if</KEYWORD> (<VARIABLE>$OPTS</VARIABLE>{<STRING>'fromversion'</STRING>})<OPERATOR>;</OPERATOR>
            <VARIABLE>$to_pname</VARIABLE>        <OPERATOR>.=</OPERATOR> <STRING>"<ESC>\@</ESC><ESC>\@</ESC>$OPTS{'toversion'}"</STRING>    <KEYWORD>if</KEYWORD> (<VARIABLE>$OPTS</VARIABLE>{<STRING>'toversion'</STRING>})<OPERATOR>;</OPERATOR>
            <KEYWORD>my</KEYWORD> <VARIABLE>$cdiff_cmd</VARIABLE>  <OPERATOR>=</OPERATOR> ${<CONSTANT>EXECDIR</CONSTANT>} <OPERATOR>.</OPERATOR> <VARIABLE>$Path_Sep</VARIABLE> <OPERATOR>.</OPERATOR> <STRING>'cdiff'</STRING><OPERATOR>;</OPERATOR>
            <VARIABLE>$cdiff_cmd</VARIABLE>       <OPERATOR>.=</OPERATOR> <STRING>" -unlimited -noprolog -blank_ignore"</STRING><OPERATOR>;</OPERATOR>
            <VARIABLE>$cdiff_cmd</VARIABLE>       <OPERATOR>.=</OPERATOR> (<VARIABLE>$OPTS</VARIABLE>{<STRING>'pred'</STRING>}) <OPERATOR>?</OPERATOR> <STRING>" -pred"</STRING> <OPERATOR>:</OPERATOR> <STRING>" $from_pname"</STRING><OPERATOR>;</OPERATOR>
            <VARIABLE>$cdiff_cmd</VARIABLE>       <OPERATOR>.=</OPERATOR> <STRING>" $to_pname"</STRING><OPERATOR>;</OPERATOR>
            <VARIABLE>$filename</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>"$cdiff_cmd |"</STRING><OPERATOR>;</OPERATOR>
        }
        <VARIABLE>$filehandle</VARIABLE> <OPERATOR>=</OPERATOR> <OPERATOR>\*</OPERATOR><CONSTANT>INPUT</CONSTANT><OPERATOR>;</OPERATOR>
        <KEYWORD>unless</KEYWORD> (<FUNCTION>open</FUNCTION>(<CONSTANT>INPUT</CONSTANT><OPERATOR>,</OPERATOR> <VARIABLE>$filename</VARIABLE>)) {
            <OPERATOR>&amp;</OPERATOR>ErrorMsg(<STRING>"Can't open $filename for reading: $!"</STRING>)<OPERATOR>;</OPERATOR>
            <KEYWORD>return</KEYWORD> <VARIABLE>%error</VARIABLE><OPERATOR>;</OPERATOR>
        }
    }

    <KEYWORD>while</KEYWORD> (<OPERATOR>&lt;</OPERATOR><VARIABLE>$filehandle</VARIABLE><OPERATOR>&gt;</OPERATOR>) {
        <FUNCTION>chomp</FUNCTION><OPERATOR>;</OPERATOR>
        <VARIABLE>$diffType</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>''</STRING><OPERATOR>;</OPERATOR>
        <COMMENT>## See if this is a context separator.</COMMENT>
        <KEYWORD>if</KEYWORD> (<OPERATOR>&amp;</OPERATOR>IsSeparator(<VARIABLE>$_</VARIABLE>)) {
            <COMMENT>## Yes, reset context and get the next line.</COMMENT>
            (<VARIABLE>$inComment</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$inQuote</VARIABLE>) <OPERATOR>=</OPERATOR> (<NUMERIC>0</NUMERIC><OPERATOR>,</OPERATOR> <STRING>''</STRING>)<OPERATOR>;</OPERATOR>
            <KEYWORD>next</KEYWORD><OPERATOR>;</OPERATOR>
        }
        <COMMENT>## Strip any leading prefix</COMMENT>
        <DELIMITER>s/</DELIMITER><REGEX>^(?:$OPTS{'prefix'})</REGEX><DELIMITER>/</DELIMITER><STRING></STRING><DELIMITER>/</DELIMITER> <KEYWORD>if</KEYWORD> (<VARIABLE>$OPTS</VARIABLE>{<STRING>'prefix'</STRING>})<OPERATOR>;</OPERATOR>

        <COMMENT>## If this is diff(1) output, do some special stuff</COMMENT>
        <KEYWORD>if</KEYWORD> (<VARIABLE>$OPTS</VARIABLE>{<STRING>'diff'</STRING>}) {
            <KEYWORD>if</KEYWORD> (<DELIMITER>/</DELIMITER><REGEX>^([&lt;&gt;])\s+</REGEX><DELIMITER>/</DELIMITER>) {
                <COMMENT>## line was inserted or deleted (strip the prefix)</COMMENT>
                <VARIABLE>$diffType</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$1</VARIABLE><OPERATOR>;</OPERATOR>
                <VARIABLE>$_</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$'</VARIABLE><OPERATOR>;</OPERATOR> <COMMENT>#'</COMMENT>
            } <KEYWORD>else</KEYWORD> {
                <COMMENT>## Reset context and get the next line.</COMMENT>
                (<VARIABLE>$inComment</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$inQuote</VARIABLE>) <OPERATOR>=</OPERATOR> (<NUMERIC>0</NUMERIC><OPERATOR>,</OPERATOR> <STRING>''</STRING>)<OPERATOR>;</OPERATOR>
                <KEYWORD>next</KEYWORD><OPERATOR>;</OPERATOR>
            }
        }

        <COMMENT>## Check for a blank line</COMMENT>
        <OPERATOR>++</OPERATOR><VARIABLE>$counts</VARIABLE>{<STRING>"${diffType}Lines"</STRING>}<OPERATOR>;</OPERATOR>
        <OPERATOR>++</OPERATOR><VARIABLE>$counts</VARIABLE>{<STRING>"Lines"</STRING>} <KEYWORD>if</KEYWORD> (<VARIABLE>$diffType</VARIABLE>)<OPERATOR>;</OPERATOR> <COMMENT>## count total lines in a diff</COMMENT>
        <KEYWORD>if</KEYWORD> (<DELIMITER>/</DELIMITER><REGEX>^\s*$</REGEX><DELIMITER>/</DELIMITER>) {
            <OPERATOR>++</OPERATOR><VARIABLE>$counts</VARIABLE>{<STRING>"${diffType}Blank"</STRING>}<OPERATOR>;</OPERATOR>
            <KEYWORD>next</KEYWORD><OPERATOR>;</OPERATOR>
        }

        <COMMENT># Check if a file labelled as "C" is really C++</COMMENT>
        <KEYWORD>if</KEYWORD> (<VARIABLE>$LANG_NAME</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>"C"</STRING> <OPERATOR>&amp;&amp;</OPERATOR> <OPERATOR>!</OPERATOR>(<VARIABLE>$inComment</VARIABLE> <OPERATOR>||</OPERATOR> <VARIABLE>$inQuote</VARIABLE>)) {
            <VARIABLE>$LANG_NAME</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>"C++"</STRING> <KEYWORD>if</KEYWORD> IsCeePlusPlus(<VARIABLE>$_</VARIABLE>)<OPERATOR>;</OPERATOR>
        }

        <COMMENT>## Perform any language-specific preprocessing</COMMENT>
        <KEYWORD>my</KEYWORD> <VARIABLE>$expr</VARIABLE><OPERATOR>;</OPERATOR>
        <KEYWORD>foreach</KEYWORD> <VARIABLE>$expr</VARIABLE> (<VARIABLE>@langEvals</VARIABLE>) {
            <KEYWORD>eval</KEYWORD> <VARIABLE>$expr</VARIABLE><OPERATOR>;</OPERATOR>
        }
        <COMMENT>## See how many comments, statements &amp; tokens are on this line</COMMENT>
        <KEYWORD>my</KEYWORD> (<VARIABLE>$hasSource</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$hasComment</VARIABLE>) <OPERATOR>=</OPERATOR> (<NUMERIC>0</NUMERIC><OPERATOR>,</OPERATOR> <NUMERIC>0</NUMERIC>)<OPERATOR>;</OPERATOR>
        <DELIMITER>s/</DELIMITER><REGEX>^\s*</REGEX><DELIMITER>/</DELIMITER><STRING></STRING><DELIMITER>/</DELIMITER><OPERATOR>;</OPERATOR>
        <KEYWORD>while</KEYWORD> (<VARIABLE>$_</VARIABLE>) {
            <KEYWORD>if</KEYWORD> (<VARIABLE>$inComment</VARIABLE> <OPERATOR>&gt;</OPERATOR> <NUMERIC>0</NUMERIC>) {
                <OPERATOR>++</OPERATOR><VARIABLE>$hasComment</VARIABLE><OPERATOR>;</OPERATOR>
                <KEYWORD>if</KEYWORD> (<DELIMITER>m/</DELIMITER><REGEX>$langDefns{'CMMNT_STATE'}</REGEX><DELIMITER>/</DELIMITER>) {
                    <VARIABLE>$_</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$'</VARIABLE><OPERATOR>;</OPERATOR> <COMMENT>#'</COMMENT>
                    <KEYWORD>if</KEYWORD> (<VARIABLE>$langDefns</VARIABLE>{<STRING>'CMMNT_NESTING'</STRING>}) {
                        <OPERATOR>--</OPERATOR><VARIABLE>$inComment</VARIABLE> <KEYWORD>if</KEYWORD> (<VARIABLE>$langDefns</VARIABLE>{<VARIABLE>$&amp;</VARIABLE>} <OPERATOR>eq</OPERATOR> <VARIABLE>$EndCmnt</VARIABLE>)<OPERATOR>;</OPERATOR>
                        <OPERATOR>++</OPERATOR><VARIABLE>$inComment</VARIABLE> <KEYWORD>if</KEYWORD> (<VARIABLE>$langDefns</VARIABLE>{<VARIABLE>$&amp;</VARIABLE>} <OPERATOR>eq</OPERATOR> <VARIABLE>$BeginCmnt</VARIABLE>)<OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> {
                        <VARIABLE>$inComment</VARIABLE> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>  <KEYWORD>if</KEYWORD> (<VARIABLE>$langDefns</VARIABLE>{<VARIABLE>$&amp;</VARIABLE>} <OPERATOR>eq</OPERATOR> <VARIABLE>$EndCmnt</VARIABLE>)<OPERATOR>;</OPERATOR>
                    }
                } <KEYWORD>else</KEYWORD> {
                    <VARIABLE>$_</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>''</STRING><OPERATOR>;</OPERATOR>
                }
            } <KEYWORD>elsif</KEYWORD> (<VARIABLE>$inQuote</VARIABLE>) {
                <OPERATOR>++</OPERATOR><VARIABLE>$hasSource</VARIABLE><OPERATOR>;</OPERATOR>
                <KEYWORD>if</KEYWORD> (<DELIMITER>m/</DELIMITER><REGEX>$langDefns{"${inQuote}QUOTE_STATE"}</REGEX><DELIMITER>/</DELIMITER>) {
                    <VARIABLE>$_</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$'</VARIABLE><OPERATOR>;</OPERATOR> <COMMENT>#'</COMMENT>
                    <VARIABLE>$inQuote</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>''</STRING> <KEYWORD>if</KEYWORD> (<VARIABLE>$&amp;</VARIABLE> <OPERATOR>eq</OPERATOR> <VARIABLE>$langDefns</VARIABLE>{<STRING>"END_${inQuote}"</STRING>})<OPERATOR>;</OPERATOR>
                } <KEYWORD>else</KEYWORD> {
                    <VARIABLE>$_</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>''</STRING><OPERATOR>;</OPERATOR>
                }
            } <KEYWORD>elsif</KEYWORD> (<DELIMITER>m/</DELIMITER><REGEX>^(?:$langDefns{'START_STATE'})</REGEX><DELIMITER>/</DELIMITER>) {
                <VARIABLE>$_</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$'</VARIABLE><OPERATOR>;</OPERATOR> <COMMENT>#'</COMMENT>
                <KEYWORD>if</KEYWORD> (<VARIABLE>$langDefns</VARIABLE>{<VARIABLE>$&amp;</VARIABLE>} <OPERATOR>eq</OPERATOR> <VARIABLE>$EolCmnt</VARIABLE>) {
                    <OPERATOR>++</OPERATOR><VARIABLE>$hasComment</VARIABLE><OPERATOR>;</OPERATOR>
                    <OPERATOR>++</OPERATOR><VARIABLE>$hasSource</VARIABLE> <KEYWORD>if</KEYWORD> (<VARIABLE>$`</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>\S</REGEX><DELIMITER>/</DELIMITER>)<OPERATOR>;</OPERATOR>
                    <VARIABLE>$_</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>''</STRING><OPERATOR>;</OPERATOR>
                } <KEYWORD>elsif</KEYWORD> (<VARIABLE>$langDefns</VARIABLE>{<VARIABLE>$&amp;</VARIABLE>} <OPERATOR>eq</OPERATOR> <VARIABLE>$BeginCmnt</VARIABLE>) {
                    <OPERATOR>++</OPERATOR><VARIABLE>$hasComment</VARIABLE><OPERATOR>;</OPERATOR>
                    <OPERATOR>++</OPERATOR><VARIABLE>$hasSource</VARIABLE> <KEYWORD>if</KEYWORD> (<VARIABLE>$`</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>\S</REGEX><DELIMITER>/</DELIMITER>)<OPERATOR>;</OPERATOR>
                    <VARIABLE>$inComment</VARIABLE> <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC><OPERATOR>;</OPERATOR>
                } <KEYWORD>else</KEYWORD> {
                    <OPERATOR>++</OPERATOR><VARIABLE>$hasSource</VARIABLE><OPERATOR>;</OPERATOR>
                    <KEYWORD>if</KEYWORD> (<VARIABLE>$langDefns</VARIABLE>{<VARIABLE>$&amp;</VARIABLE>} <OPERATOR>eq</OPERATOR> <VARIABLE>$BeginQuote</VARIABLE>) {
                        <VARIABLE>$inQuote</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$&amp;</VARIABLE><OPERATOR>;</OPERATOR>
                        <KEYWORD>my</KEYWORD> <VARIABLE>$quote</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$_</VARIABLE><OPERATOR>;</OPERATOR>
                        <VARIABLE>$quote</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>s/</DELIMITER><REGEX>$inQuote.*</REGEX><DELIMITER>/</DELIMITER><STRING></STRING><DELIMITER>/</DELIMITER> <OPERATOR>or</OPERATOR> <VARIABLE>$quote</VARIABLE> <OPERATOR>.=</OPERATOR> <STRING>'...'</STRING><OPERATOR>;</OPERATOR>
                        <OPERATOR>&amp;</OPERATOR>Token(<OPERATOR>\%</OPERATOR>counts<OPERATOR>,</OPERATOR> <VARIABLE>$diffType</VARIABLE><OPERATOR>,</OPERATOR> <STRING>'CPtoks'</STRING><OPERATOR>,</OPERATOR>
                            <STRING>"$inQuote$quote$inQuote"</STRING>)<OPERATOR>;</OPERATOR>
                    }
                }
            } <KEYWORD>else</KEYWORD> {
                <OPERATOR>++</OPERATOR><VARIABLE>$hasSource</VARIABLE><OPERATOR>;</OPERATOR>
                <KEYWORD>if</KEYWORD> (<DELIMITER>s/</DELIMITER><REGEX>^($langDefns{'SYMBOL'})\s*</REGEX><DELIMITER>/</DELIMITER><STRING></STRING><DELIMITER>/</DELIMITER>) {
                    <KEYWORD>if</KEYWORD> (<KEYWORD>eval</KEYWORD> <VARIABLE>$langDefns</VARIABLE>{<STRING>'KEYWORD'</STRING>}) {
                        <OPERATOR>&amp;</OPERATOR>Token(<OPERATOR>\%</OPERATOR>counts<OPERATOR>,</OPERATOR> <VARIABLE>$diffType</VARIABLE><OPERATOR>,</OPERATOR> <STRING>'KPtoks'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$&amp;</VARIABLE>)<OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> {
                        <OPERATOR>&amp;</OPERATOR>Token(<OPERATOR>\%</OPERATOR>counts<OPERATOR>,</OPERATOR> <VARIABLE>$diffType</VARIABLE><OPERATOR>,</OPERATOR> <STRING>'SPtoks'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$&amp;</VARIABLE>)<OPERATOR>;</OPERATOR>
                    }
                } <KEYWORD>elsif</KEYWORD> (<DELIMITER>s/</DELIMITER><REGEX>^(?:$langDefns{'NUMBER'})\s*</REGEX><DELIMITER>/</DELIMITER><STRING></STRING><DELIMITER>/</DELIMITER>) {
                    <OPERATOR>&amp;</OPERATOR>Token(<OPERATOR>\%</OPERATOR>counts<OPERATOR>,</OPERATOR> <VARIABLE>$diffType</VARIABLE><OPERATOR>,</OPERATOR> <STRING>'CPtoks'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$&amp;</VARIABLE>)<OPERATOR>;</OPERATOR>
                } <KEYWORD>elsif</KEYWORD> (<DELIMITER>s/</DELIMITER><REGEX>^(?:$langDefns{'GROUPER'})\s*</REGEX><DELIMITER>/</DELIMITER><STRING></STRING><DELIMITER>/</DELIMITER>) {
                    <OPERATOR>&amp;</OPERATOR>Token(<OPERATOR>\%</OPERATOR>counts<OPERATOR>,</OPERATOR> <VARIABLE>$diffType</VARIABLE><OPERATOR>,</OPERATOR> <STRING>'GPtoks'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$&amp;</VARIABLE>)<OPERATOR>;</OPERATOR>
                } <KEYWORD>elsif</KEYWORD> (<DELIMITER>s/</DELIMITER><REGEX>^(?:$langDefns{'OPERATOR'})\s*</REGEX><DELIMITER>/</DELIMITER><STRING></STRING><DELIMITER>/</DELIMITER>) {
                    <OPERATOR>&amp;</OPERATOR>Token(<OPERATOR>\%</OPERATOR>counts<OPERATOR>,</OPERATOR> <VARIABLE>$diffType</VARIABLE><OPERATOR>,</OPERATOR> <STRING>'OPtoks'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$&amp;</VARIABLE>)<OPERATOR>;</OPERATOR>
                } <KEYWORD>else</KEYWORD> {    <COMMENT># ignore anything else</COMMENT>
                    <OPERATOR>&amp;</OPERATOR>ErrorMsg(<STRING>"undefined token '$_'<ESC>\n</ESC>"</STRING>)<OPERATOR>;</OPERATOR>
                    <DELIMITER>s/</DELIMITER><REGEX>^.</REGEX><DELIMITER>/</DELIMITER><STRING></STRING><DELIMITER>/</DELIMITER><OPERATOR>;</OPERATOR>
                }
            }
            <DELIMITER>s/</DELIMITER><REGEX>^\s*</REGEX><DELIMITER>/</DELIMITER><STRING></STRING><DELIMITER>/</DELIMITER><OPERATOR>;</OPERATOR>
        }
        <OPERATOR>++</OPERATOR><VARIABLE>$counts</VARIABLE>{<STRING>"${diffType}NCSL"</STRING>}  <KEYWORD>if</KEYWORD> (<VARIABLE>$hasSource</VARIABLE>)<OPERATOR>;</OPERATOR>
        <OPERATOR>++</OPERATOR><VARIABLE>$counts</VARIABLE>{<STRING>"${diffType}Cmnts"</STRING>} <KEYWORD>if</KEYWORD> (<VARIABLE>$hasComment</VARIABLE>)<OPERATOR>;</OPERATOR>
    }

    <FUNCTION>close</FUNCTION>(<VARIABLE>$filehandle</VARIABLE>) <KEYWORD>unless</KEYWORD> (<VARIABLE>$filename</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>'-'</STRING>)<OPERATOR>;</OPERATOR>

    <COMMENT>## Determine Assembly Eqivalent counts</COMMENT>
    <KEYWORD>my</KEYWORD> <VARIABLE>$aeFactor</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$AssemblyEquivalence</VARIABLE>{<VARIABLE>$LANG_NAME</VARIABLE>}<OPERATOR>;</OPERATOR>
    <VARIABLE>$aeFactor</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$langDefns</VARIABLE>{<STRING>'AESL'</STRING>} <KEYWORD>unless</KEYWORD> (<VARIABLE>$aeFactor</VARIABLE>)<OPERATOR>;</OPERATOR>
    <VARIABLE>$counts</VARIABLE>{<STRING>'AESL'</STRING>}  <OPERATOR>=</OPERATOR> (<VARIABLE>$counts</VARIABLE>{<STRING>'NCSL'</STRING>}  <OPERATOR>*</OPERATOR> <VARIABLE>$aeFactor</VARIABLE>) <KEYWORD>if</KEYWORD> (<VARIABLE>$counts</VARIABLE>{<STRING>'NCSL'</STRING>})<OPERATOR>;</OPERATOR>
    <VARIABLE>$counts</VARIABLE>{<STRING>'&lt;AESL'</STRING>} <OPERATOR>=</OPERATOR> (<VARIABLE>$counts</VARIABLE>{<STRING>'&lt;NCSL'</STRING>} <OPERATOR>*</OPERATOR> <VARIABLE>$aeFactor</VARIABLE>) <KEYWORD>if</KEYWORD> (<VARIABLE>$counts</VARIABLE>{<STRING>'&lt;NCSL'</STRING>})<OPERATOR>;</OPERATOR>
    <VARIABLE>$counts</VARIABLE>{<STRING>'&gt;AESL'</STRING>} <OPERATOR>=</OPERATOR> (<VARIABLE>$counts</VARIABLE>{<STRING>'&gt;NCSL'</STRING>} <OPERATOR>*</OPERATOR> <VARIABLE>$aeFactor</VARIABLE>) <KEYWORD>if</KEYWORD> (<VARIABLE>$counts</VARIABLE>{<STRING>'&gt;NCSL'</STRING>})<OPERATOR>;</OPERATOR>

    <VARIABLE>%counts</VARIABLE><OPERATOR>;</OPERATOR>
}

<COMMENT>## Print a report line or header. We know it is a header if</COMMENT>
<COMMENT>## the first argument is a 's', not a 'd'</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## FUNCTION:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SYNOPSIS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## ARGUMENTS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## RETURN VALUE:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## PRECONDITIONS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SIDE EFFECTS:</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>sub</KEYWORD> PrintCounts {
    <KEYWORD>my</KEYWORD> <VARIABLE>@tmp</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>@_</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> (<VARIABLE>$ntype</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$fname</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$language</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$Name</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$type</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$Count</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$is_total</VARIABLE>) <OPERATOR>=</OPERATOR> <VARIABLE>@tmp</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>local</KEYWORD> <VARIABLE>$_</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> (<VARIABLE>$fwidth</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>@nums</VARIABLE>)<OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>$ll</VARIABLE> <OPERATOR>=</OPERATOR> <NUMERIC>79</NUMERIC><OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>$nwidth</VARIABLE> <OPERATOR>=</OPERATOR> <NUMERIC>6</NUMERIC><OPERATOR>;</OPERATOR>

    <KEYWORD>foreach</KEYWORD> (@<VARIABLE>$Name</VARIABLE>) {
        <KEYWORD>my</KEYWORD> <VARIABLE>$set</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$CNTS</VARIABLE>{<FUNCTION>lc</FUNCTION> <VARIABLE>$_</VARIABLE>}<OPERATOR>;</OPERATOR>
        <KEYWORD>next</KEYWORD> <KEYWORD>unless</KEYWORD> (<VARIABLE>$set</VARIABLE>)<OPERATOR>;</OPERATOR>

        <KEYWORD>if</KEYWORD> (<VARIABLE>$ntype</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>'d'</STRING>) {
            <FUNCTION>printf</FUNCTION>(<STRING>"%${nwidth}${ntype} "</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$$</VARIABLE>Count{<STRING>"$type$_"</STRING>} <OPERATOR>||</OPERATOR> <NUMERIC>0</NUMERIC>)<OPERATOR>;</OPERATOR>
        } <KEYWORD>else</KEYWORD> {
            <FUNCTION>printf</FUNCTION>(<STRING>"%${nwidth}${ntype} "</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$_</VARIABLE>)<OPERATOR>;</OPERATOR>
        }
        <FUNCTION>push</FUNCTION>(<VARIABLE>@nums</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$_</VARIABLE>)<OPERATOR>;</OPERATOR>
    }
    <FUNCTION>print</FUNCTION> <STRING>"${fname}"</STRING><OPERATOR>;</OPERATOR>
    <FUNCTION>print</FUNCTION> <STRING>"  ($language)"</STRING> <KEYWORD>if</KEYWORD> (<VARIABLE>$language</VARIABLE>)<OPERATOR>;</OPERATOR>
    <FUNCTION>print</FUNCTION> <STRING>"<ESC>\n</ESC>"</STRING><OPERATOR>;</OPERATOR>

    <KEYWORD>if</KEYWORD> (<VARIABLE>$ntype</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>'s'</STRING>) {
        <COMMENT>## need to print a header-bar</COMMENT>
        <KEYWORD>my</KEYWORD> <VARIABLE>$fwidth</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$ll</VARIABLE><OPERATOR>;</OPERATOR>
        <KEYWORD>foreach</KEYWORD> (<VARIABLE>@nums</VARIABLE>) {
            <FUNCTION>printf</FUNCTION>(<STRING>"%-${nwidth}s "</STRING><OPERATOR>,</OPERATOR> <STRING>'='</STRING> x <VARIABLE>$nwidth</VARIABLE>)<OPERATOR>;</OPERATOR>
            <VARIABLE>$fwidth</VARIABLE> <OPERATOR>-=</OPERATOR> (<VARIABLE>$nwidth</VARIABLE> <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>)<OPERATOR>;</OPERATOR>
        }
        <KEYWORD>my</KEYWORD> <VARIABLE>$fbar</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>'='</STRING> x <VARIABLE>$fwidth</VARIABLE><OPERATOR>;</OPERATOR>
        <FUNCTION>print</FUNCTION> <STRING>"${fbar}<ESC>\n</ESC>"</STRING><OPERATOR>;</OPERATOR>
    }

    <COMMENT># For writing to xml file if xml_output specified</COMMENT>
    <KEYWORD>if</KEYWORD> (<VARIABLE>$ntype</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>'d'</STRING> <OPERATOR>&amp;&amp;</OPERATOR> <VARIABLE>$OPTS</VARIABLE>{<STRING>'xml_output'</STRING>}) {
        <OPERATOR>&amp;</OPERATOR>WriteXml(<VARIABLE>@tmp</VARIABLE>)<OPERATOR>;</OPERATOR>
    }

    <KEYWORD>if</KEYWORD>(<VARIABLE>$OPTS</VARIABLE>{<STRING>'tm3_output'</STRING>}) {
        <KEYWORD>if</KEYWORD> (<VARIABLE>$ntype</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>'s'</STRING>) {
            WriteTm3Header(<VARIABLE>@tmp</VARIABLE>)<OPERATOR>;</OPERATOR>
        } <KEYWORD>elsif</KEYWORD> (<VARIABLE>$ntype</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>'d'</STRING>) {
            WriteTm3Entry(<VARIABLE>@tmp</VARIABLE>) <KEYWORD>unless</KEYWORD> <VARIABLE>$is_total</VARIABLE><OPERATOR>;</OPERATOR>
        }
    }
}

<COMMENT>## Writes the TM3 header to the file</COMMENT>
<KEYWORD>sub</KEYWORD> WriteTm3Header {
    <KEYWORD>my</KEYWORD> <VARIABLE>$tm3file</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$OPTS</VARIABLE>{<STRING>'tm3_output'</STRING>}<OPERATOR>;</OPERATOR>
    <FUNCTION>open</FUNCTION>(TM3<OPERATOR>,</OPERATOR> <STRING>"&gt;$tm3file"</STRING>) <OPERATOR>or</OPERATOR> <KEYWORD>die</KEYWORD> <STRING>"Error: cannt open $tm3file for writing<ESC>\n</ESC>"</STRING><OPERATOR>;</OPERATOR>
    <FUNCTION>print</FUNCTION> TM3 <STRING>"Language<ESC>\t</ESC>"</STRING> <OPERATOR>.</OPERATOR> <STRING>"Lines<ESC>\t</ESC>"</STRING>   <OPERATOR>.</OPERATOR> <STRING>"Blank<ESC>\t</ESC>"</STRING>   <OPERATOR>.</OPERATOR> <STRING>"Comments<ESC>\t</ESC>"</STRING> <OPERATOR>.</OPERATOR> <STRING>"SLOC<ESC>\t</ESC>"</STRING>    <OPERATOR>.</OPERATOR> <STRING>"Tokens<ESC>\n</ESC>"</STRING><OPERATOR>;</OPERATOR>
    <FUNCTION>print</FUNCTION> TM3 <STRING>"STRING<ESC>\t</ESC>"</STRING>   <OPERATOR>.</OPERATOR> <STRING>"INTEGER<ESC>\t</ESC>"</STRING> <OPERATOR>.</OPERATOR> <STRING>"INTEGER<ESC>\t</ESC>"</STRING> <OPERATOR>.</OPERATOR> <STRING>"INTEGER<ESC>\t</ESC>"</STRING>  <OPERATOR>.</OPERATOR> <STRING>"INTEGER<ESC>\t</ESC>"</STRING> <OPERATOR>.</OPERATOR> <STRING>"INTEGER<ESC>\n</ESC>"</STRING><OPERATOR>;</OPERATOR>
    <FUNCTION>close</FUNCTION> TM3<OPERATOR>;</OPERATOR>
}

<KEYWORD>sub</KEYWORD> WriteTm3Entry {
    <KEYWORD>my</KEYWORD> (<VARIABLE>$ntype</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$fname</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$language</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$Name</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$type</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$Count</VARIABLE>) <OPERATOR>=</OPERATOR> <VARIABLE>@_</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>$tm3file</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$OPTS</VARIABLE>{<STRING>'tm3_output'</STRING>}<OPERATOR>;</OPERATOR>
    <FUNCTION>open</FUNCTION>(TM3<OPERATOR>,</OPERATOR> <STRING>"&gt;&gt;$tm3file"</STRING>) <OPERATOR>or</OPERATOR> <KEYWORD>die</KEYWORD> <STRING>"Error: can't open $tm3file for writing<ESC>\n</ESC>"</STRING><OPERATOR>;</OPERATOR>

    <KEYWORD>my</KEYWORD> <VARIABLE>$lines</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$$</VARIABLE>Count{<STRING>'Lines'</STRING>} <OPERATOR>||</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>$blank</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$$</VARIABLE>Count{<STRING>'Blank'</STRING>} <OPERATOR>||</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>$comments</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$$</VARIABLE>Count{<STRING>'Cmnts'</STRING>} <OPERATOR>||</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>$sloc</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$$</VARIABLE>Count{<STRING>'NCSL'</STRING>} <OPERATOR>||</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>$tokens</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$$</VARIABLE>Count{<STRING>'TPtoks'</STRING>} <OPERATOR>||</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
    <FUNCTION>print</FUNCTION> TM3 <STRING>"$language<ESC>\t</ESC>$lines<ESC>\t</ESC>$blank<ESC>\t</ESC>$comments<ESC>\t</ESC>$sloc<ESC>\t</ESC>$tokens<ESC>\t</ESC>"</STRING><OPERATOR>;</OPERATOR>

<COMMENT># Divide up the path based on the path separator.</COMMENT>
<COMMENT># Not that currently we only support forward slash, this will break under windows</COMMENT>
    <KEYWORD>my</KEYWORD> <VARIABLE>@path</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>split</FUNCTION>(<DELIMITER>/</DELIMITER><REGEX>\/</REGEX><DELIMITER>/</DELIMITER><OPERATOR>,</OPERATOR><VARIABLE>$fname</VARIABLE>)<OPERATOR>;</OPERATOR>
    <KEYWORD>foreach</KEYWORD> (<VARIABLE>@path</VARIABLE>) {
        <FUNCTION>print</FUNCTION> TM3 <STRING>"<ESC>\t</ESC>$_"</STRING><OPERATOR>;</OPERATOR>
    }
    <FUNCTION>print</FUNCTION> TM3 <STRING>"<ESC>\n</ESC>"</STRING><OPERATOR>;</OPERATOR>
    <FUNCTION>close</FUNCTION> TM3<OPERATOR>;</OPERATOR>
}

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## Adds a file element to the xml file containing the totals for a file.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## Added by J. Sakuda for XML output support.</COMMENT>
<COMMENT>## Formatted for Hackystat's XmlData sensor.</COMMENT>
<COMMENT>## Please DO NOT change the XML format.</COMMENT>
<COMMENT>## See:</COMMENT>
<COMMENT>## http://hackydev.ics.hawaii.edu/hackyDevSite/external/docbook/apas11.html</COMMENT>
<COMMENT>## for details on why these attributes are being used.</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>sub</KEYWORD> WriteXml {
    <KEYWORD>my</KEYWORD> (<VARIABLE>$ntype</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$fname</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$language</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$Name</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$type</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$Count</VARIABLE>) <OPERATOR>=</OPERATOR> <VARIABLE>@_</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>local</KEYWORD> <VARIABLE>$_</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>if</KEYWORD> (<VARIABLE>$language</VARIABLE>) { <COMMENT># make sure lang is set, or else probably header</COMMENT>
        <COMMENT># represents all attributes for one file element</COMMENT>
        <KEYWORD>my</KEYWORD> <VARIABLE>%fileInfoHash</VARIABLE> <OPERATOR>=</OPERATOR> ()<OPERATOR>;</OPERATOR>
        <VARIABLE>$fileInfoHash</VARIABLE>{<STRING>'tool'</STRING>} <OPERATOR>=</OPERATOR> <STRING>'SCLC'</STRING><OPERATOR>;</OPERATOR>
        <VARIABLE>$fileInfoHash</VARIABLE>{<STRING>'sdt'</STRING>} <OPERATOR>=</OPERATOR> <STRING>'FileMetric'</STRING><OPERATOR>;</OPERATOR>
        <VARIABLE>$fileInfoHash</VARIABLE>{<STRING>'fileType'</STRING>} <OPERATOR>=</OPERATOR> <VARIABLE>$language</VARIABLE><OPERATOR>;</OPERATOR>
        <VARIABLE>$fileInfoHash</VARIABLE>{<STRING>'fileName'</STRING>} <OPERATOR>=</OPERATOR> <OBJ>Cwd</OBJ><OPERATOR>::</OPERATOR><OO>abs_path</OO>(<VARIABLE>$fname</VARIABLE>)<OPERATOR>;</OPERATOR>

        <KEYWORD>my</KEYWORD> <VARIABLE>$src_lines</VARIABLE> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
        <KEYWORD>my</KEYWORD> <VARIABLE>$cmnt_lines</VARIABLE> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
        <KEYWORD>my</KEYWORD> <VARIABLE>$blank_lines</VARIABLE> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>

        <KEYWORD>foreach</KEYWORD> (@<VARIABLE>$Name</VARIABLE>) {
            <KEYWORD>my</KEYWORD> <VARIABLE>$set</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$CNTS</VARIABLE>{<FUNCTION>lc</FUNCTION> <VARIABLE>$_</VARIABLE>}<OPERATOR>;</OPERATOR>
            <KEYWORD>next</KEYWORD> <KEYWORD>unless</KEYWORD> (<VARIABLE>$set</VARIABLE>)<OPERATOR>;</OPERATOR>
            <KEYWORD>if</KEYWORD> (<VARIABLE>$_</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>'NCSL'</STRING>) {
                <VARIABLE>$src_lines</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$$</VARIABLE>Count{<STRING>"$type$_"</STRING>} <OPERATOR>||</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
                <VARIABLE>$fileInfoHash</VARIABLE>{<STRING>'sourceLines'</STRING>} <OPERATOR>=</OPERATOR> <VARIABLE>$src_lines</VARIABLE><OPERATOR>;</OPERATOR>
            }
            <KEYWORD>elsif</KEYWORD> (<VARIABLE>$_</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>'Lines'</STRING>) {

                <COMMENT># Don't need lines with included blanks.</COMMENT>
                <COMMENT>#$lines = $$Count{"$type$_"};</COMMENT>
            }
            <KEYWORD>elsif</KEYWORD> (<VARIABLE>$_</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>'Blank'</STRING>) {
                <VARIABLE>$blank_lines</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$$</VARIABLE>Count{<STRING>"$type$_"</STRING>} <OPERATOR>||</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
                <VARIABLE>$fileInfoHash</VARIABLE>{<STRING>'blankLines'</STRING>} <OPERATOR>=</OPERATOR> <VARIABLE>$blank_lines</VARIABLE><OPERATOR>;</OPERATOR>
            }
            <KEYWORD>elsif</KEYWORD> (<VARIABLE>$_</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>'Cmnts'</STRING>) {
                <VARIABLE>$cmnt_lines</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$$</VARIABLE>Count{<STRING>"$type$_"</STRING>} <OPERATOR>||</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
                <VARIABLE>$fileInfoHash</VARIABLE>{<STRING>'commentLines'</STRING>} <OPERATOR>=</OPERATOR> <VARIABLE>$cmnt_lines</VARIABLE><OPERATOR>;</OPERATOR>
            }
            <KEYWORD>else</KEYWORD> {
                <VARIABLE>$fileInfoHash</VARIABLE>{<FUNCTION>lc</FUNCTION> <VARIABLE>$_</VARIABLE>} <OPERATOR>=</OPERATOR> <VARIABLE>$$</VARIABLE>Count{<STRING>"$type$_"</STRING>}<OPERATOR>;</OPERATOR>
            }
        }

        <COMMENT># calculate total lines  (cmmnts + src + blank)</COMMENT>
        <VARIABLE>$fileInfoHash</VARIABLE>{<STRING>'totalLines'</STRING>} <OPERATOR>=</OPERATOR> <VARIABLE>$src_lines</VARIABLE> <OPERATOR>+</OPERATOR> <VARIABLE>$cmnt_lines</VARIABLE> <OPERATOR>+</OPERATOR> <VARIABLE>$blank_lines</VARIABLE><OPERATOR>;</OPERATOR>

        <COMMENT># Get MPI and OpenMP counts</COMMENT>
        <KEYWORD>if</KEYWORD>(<VARIABLE>$language</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>'C++'</STRING> <OPERATOR>||</OPERATOR> <VARIABLE>$language</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>'C'</STRING> <OPERATOR>||</OPERATOR> <VARIABLE>$language</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>'FORTRAN'</STRING>) {
            <KEYWORD>my</KEYWORD> <VARIABLE>%mpi_totals</VARIABLE> <OPERATOR>=</OPERATOR> <OPERATOR>&amp;</OPERATOR>CountMPI(<VARIABLE>$fname</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$language</VARIABLE>)<OPERATOR>;</OPERATOR>
            <KEYWORD>my</KEYWORD> <VARIABLE>%omp_totals</VARIABLE> <OPERATOR>=</OPERATOR> <OPERATOR>&amp;</OPERATOR>CountOMP(<VARIABLE>$fname</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$language</VARIABLE>)<OPERATOR>;</OPERATOR>
            <KEYWORD>foreach</KEYWORD> <KEYWORD>my</KEYWORD> <VARIABLE>$key</VARIABLE> (<FUNCTION>keys</FUNCTION> <VARIABLE>%mpi_totals</VARIABLE>) {
                <VARIABLE>$fileInfoHash</VARIABLE>{<VARIABLE>$key</VARIABLE>} <OPERATOR>=</OPERATOR> <VARIABLE>$mpi_totals</VARIABLE>{<VARIABLE>$key</VARIABLE>}<OPERATOR>;</OPERATOR>
            }
            <KEYWORD>foreach</KEYWORD> <KEYWORD>my</KEYWORD> <VARIABLE>$key</VARIABLE> (<FUNCTION>keys</FUNCTION> <VARIABLE>%omp_totals</VARIABLE>) {
                <VARIABLE>$fileInfoHash</VARIABLE>{<VARIABLE>$key</VARIABLE>} <OPERATOR>=</OPERATOR> <VARIABLE>$omp_totals</VARIABLE>{<VARIABLE>$key</VARIABLE>}<OPERATOR>;</OPERATOR>
            }
        }
        <FUNCTION>push</FUNCTION>(<VARIABLE>@fileElementArray</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR>fileInfoHash)<OPERATOR>;</OPERATOR>
    }
}

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## Added by J. Sakuda to count MPI tokens.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## Args:</COMMENT>
<COMMENT>##  file -- The name of the file to process for MPI.</COMMENT>
<COMMENT>##  lang --  The language that the file is determined to be (i.e. C++)</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>sub</KEYWORD> CountMPI {
    <KEYWORD>my</KEYWORD> (<VARIABLE>$file</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$lang</VARIABLE>) <OPERATOR>=</OPERATOR> <VARIABLE>@_</VARIABLE><OPERATOR>;</OPERATOR>
    <FUNCTION>open</FUNCTION>(<CONSTANT>INPUT</CONSTANT><OPERATOR>,</OPERATOR> <VARIABLE>$file</VARIABLE>) <OPERATOR>or</OPERATOR> <KEYWORD>die</KEYWORD>(<STRING>"Error opening file to check for MPI totals."</STRING>)<OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>%mpi_counts</VARIABLE> <OPERATOR>=</OPERATOR> ()<OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>$inComment</VARIABLE> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
    <KEYWORD>while</KEYWORD>( <KEYWORD>my</KEYWORD> <VARIABLE>$line</VARIABLE> <OPERATOR>=</OPERATOR> <OPERATOR>&lt;</OPERATOR><CONSTANT>INPUT</CONSTANT><OPERATOR>&gt;</OPERATOR> ){
        <FUNCTION>chomp</FUNCTION>(<VARIABLE>$line</VARIABLE>)<OPERATOR>;</OPERATOR>
        <KEYWORD>if</KEYWORD> (<VARIABLE>$lang</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>'C'</STRING> <OPERATOR>||</OPERATOR> <VARIABLE>$lang</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>'C++'</STRING>) {
            <KEYWORD>my</KEYWORD> <VARIABLE>$cmnt_start</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>'/<ESC>\*</ESC>'</STRING><OPERATOR>;</OPERATOR>
            <KEYWORD>my</KEYWORD> <VARIABLE>$cmnt_end</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>'<ESC>\*</ESC>/'</STRING><OPERATOR>;</OPERATOR>
            <KEYWORD>my</KEYWORD> <VARIABLE>$cmnt_single</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>'//'</STRING><OPERATOR>;</OPERATOR>
            <KEYWORD>if</KEYWORD> (<VARIABLE>$line</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>$cmnt_start</REGEX><DELIMITER>/</DELIMITER>) { <COMMENT># check if line contains /*</COMMENT>
                <COMMENT># split on /* to get part preceeding /*</COMMENT>
                <KEYWORD>my</KEYWORD> <VARIABLE>@code</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>split</FUNCTION>(<DELIMITER>/</DELIMITER><REGEX>$cmnt_start</REGEX><DELIMITER>/</DELIMITER><OPERATOR>,</OPERATOR> <VARIABLE>$line</VARIABLE>)<OPERATOR>;</OPERATOR>

                <COMMENT># process part before /*, it is either blank or code</COMMENT>
                <KEYWORD>while</KEYWORD> (<VARIABLE>$code</VARIABLE>[<NUMERIC>0</NUMERIC>] <OPERATOR>=~</OPERATOR> <DELIMITER>m/</DELIMITER><REGEX>MPI_\w*</REGEX><DELIMITER>/</DELIMITER><KEYWORD>gi</KEYWORD>) {
                    <VARIABLE>$mpi_counts</VARIABLE>{<VARIABLE>$&amp;</VARIABLE>}<OPERATOR>++;</OPERATOR>
                }
                <VARIABLE>$inComment</VARIABLE><OPERATOR>++;</OPERATOR> <COMMENT># mark that in multi-line comment</COMMENT>
            }
            <KEYWORD>elsif</KEYWORD> (<VARIABLE>$line</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>$cmnt_single</REGEX><DELIMITER>/</DELIMITER>) { <COMMENT># check single line cmnt</COMMENT>
                <COMMENT># split on // to get part preceeding the //</COMMENT>
                <KEYWORD>my</KEYWORD> <VARIABLE>@code</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>split</FUNCTION>(<DELIMITER>/</DELIMITER><REGEX>$cmnt_single</REGEX><DELIMITER>/</DELIMITER><OPERATOR>,</OPERATOR> <VARIABLE>$line</VARIABLE>)<OPERATOR>;</OPERATOR>

                <COMMENT># process part before //, either blank or code</COMMENT>
                <KEYWORD>while</KEYWORD> (<VARIABLE>$code</VARIABLE>[<NUMERIC>0</NUMERIC>] <OPERATOR>=~</OPERATOR> <DELIMITER>m/</DELIMITER><REGEX>MPI_\w*</REGEX><DELIMITER>/</DELIMITER><KEYWORD>gi</KEYWORD>) {
                    <VARIABLE>$mpi_counts</VARIABLE>{<VARIABLE>$&amp;</VARIABLE>}<OPERATOR>++;</OPERATOR>
                }

                <COMMENT># Once we've processed this case, go to the next line</COMMENT>
                <KEYWORD>next</KEYWORD><OPERATOR>;</OPERATOR>
            }
            <KEYWORD>if</KEYWORD> (<VARIABLE>$line</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>$cmnt_end</REGEX><DELIMITER>/</DELIMITER>) { <COMMENT># check end of multi-line cmnt</COMMENT>
                <VARIABLE>$inComment</VARIABLE> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR> <COMMENT># cmnt end found, not in multi-line cmnt</COMMENT>
            }
            <KEYWORD>if</KEYWORD> (<VARIABLE>$inComment</VARIABLE> <OPERATOR>&gt;</OPERATOR> <NUMERIC>0</NUMERIC>) {

                <COMMENT># if inComment &gt; 0 then in multi-line comment</COMMENT>
                <COMMENT># so don't process $line, either processed earlier or</COMMENT>
                <COMMENT># doesn't need to be processed because line is only comment text</COMMENT>
                <KEYWORD>next</KEYWORD><OPERATOR>;</OPERATOR>
            }
            <KEYWORD>else</KEYWORD> { <COMMENT># not in multi-line comment, process $line</COMMENT>
                <KEYWORD>while</KEYWORD> (<VARIABLE>$line</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>m/</DELIMITER><REGEX>MPI_\w*</REGEX><DELIMITER>/</DELIMITER><KEYWORD>gi</KEYWORD>) {
                    <VARIABLE>$mpi_counts</VARIABLE>{<VARIABLE>$&amp;</VARIABLE>}<OPERATOR>++;</OPERATOR>
                }
            }
        }
        <KEYWORD>elsif</KEYWORD> (<VARIABLE>$lang</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>'FORTRAN'</STRING>) {
            <KEYWORD>my</KEYWORD> <VARIABLE>$cmnt_char</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>'C'</STRING><OPERATOR>;</OPERATOR>
            <KEYWORD>my</KEYWORD> <VARIABLE>$cmnt_char2</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>'!'</STRING><OPERATOR>;</OPERATOR>
            <KEYWORD>if</KEYWORD> (<VARIABLE>$line</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>^$cmnt_char</REGEX><DELIMITER>/</DELIMITER> <OPERATOR>||</OPERATOR> <VARIABLE>$line</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>^$cmnt_char2</REGEX><DELIMITER>/</DELIMITER>) {
                <KEYWORD>next</KEYWORD><OPERATOR>;</OPERATOR> <COMMENT># comment starts a beginning of line, don't process</COMMENT>
            }
            <KEYWORD>elsif</KEYWORD> (<VARIABLE>$line</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>$cmnt_char2</REGEX><DELIMITER>/</DELIMITER>) {

                <COMMENT># split on !, only check part before !</COMMENT>
                <KEYWORD>my</KEYWORD> <VARIABLE>@code</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>split</FUNCTION>(<DELIMITER>/</DELIMITER><REGEX>$cmnt_char2</REGEX><DELIMITER>/</DELIMITER><OPERATOR>,</OPERATOR> <VARIABLE>$line</VARIABLE>)<OPERATOR>;</OPERATOR>
                <VARIABLE>$line</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$code</VARIABLE>[<NUMERIC>0</NUMERIC>]<OPERATOR>;</OPERATOR>
            }
            <KEYWORD>while</KEYWORD> (<VARIABLE>$line</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>m/</DELIMITER><REGEX>MPI_\w*</REGEX><DELIMITER>/</DELIMITER><KEYWORD>gi</KEYWORD>) { <COMMENT># find MPI_* tokens</COMMENT>
                <VARIABLE>$mpi_counts</VARIABLE>{<VARIABLE>$&amp;</VARIABLE>}<OPERATOR>++;</OPERATOR>
            }
        }
    }

    <COMMENT># return the MPI hash</COMMENT>
    <VARIABLE>%mpi_counts</VARIABLE><OPERATOR>;</OPERATOR>
}

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## Added by J. Sakuda to count OpenMP tokens.</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## Args:</COMMENT>
<COMMENT>##  file -- The name of the file to process for OpenMP.</COMMENT>
<COMMENT>##  lang --  The language that the file is determined to be (i.e. C++)</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>sub</KEYWORD> CountOMP {
    <KEYWORD>my</KEYWORD> (<VARIABLE>$file</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$lang</VARIABLE>) <OPERATOR>=</OPERATOR> <VARIABLE>@_</VARIABLE><OPERATOR>;</OPERATOR>
    <FUNCTION>open</FUNCTION>(<CONSTANT>INPUT</CONSTANT><OPERATOR>,</OPERATOR> <VARIABLE>$file</VARIABLE>) <OPERATOR>or</OPERATOR> <KEYWORD>die</KEYWORD>(<STRING>"Error opening file to check for OpenMP totals."</STRING>)<OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>%omp_counts</VARIABLE> <OPERATOR>=</OPERATOR> ()<OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>$inComment</VARIABLE> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
    <KEYWORD>while</KEYWORD>( <KEYWORD>my</KEYWORD> <VARIABLE>$line</VARIABLE> <OPERATOR>=</OPERATOR> <OPERATOR>&lt;</OPERATOR><CONSTANT>INPUT</CONSTANT><OPERATOR>&gt;</OPERATOR> ){
        <FUNCTION>chomp</FUNCTION>(<VARIABLE>$line</VARIABLE>)<OPERATOR>;</OPERATOR>
        <KEYWORD>if</KEYWORD> (<VARIABLE>$lang</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>'C'</STRING> <OPERATOR>||</OPERATOR> <VARIABLE>$lang</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>'C++'</STRING>) {
            <KEYWORD>my</KEYWORD> <VARIABLE>$cmnt_start</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>'/<ESC>\*</ESC>'</STRING><OPERATOR>;</OPERATOR>
            <KEYWORD>my</KEYWORD> <VARIABLE>$cmnt_end</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>'<ESC>\*</ESC>/'</STRING><OPERATOR>;</OPERATOR>
            <KEYWORD>my</KEYWORD> <VARIABLE>$cmnt_single</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>'//'</STRING><OPERATOR>;</OPERATOR>
            <KEYWORD>if</KEYWORD> (<VARIABLE>$line</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>$cmnt_start</REGEX><DELIMITER>/</DELIMITER>) { <COMMENT># check if line contains /*</COMMENT>
                <COMMENT># split on /* to get part preceeding /*</COMMENT>
                <KEYWORD>my</KEYWORD> <VARIABLE>@code</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>split</FUNCTION>(<DELIMITER>/</DELIMITER><REGEX>$cmnt_start</REGEX><DELIMITER>/</DELIMITER><OPERATOR>,</OPERATOR> <VARIABLE>$line</VARIABLE>)<OPERATOR>;</OPERATOR>

                <COMMENT># process part before /*, it is either blank or code</COMMENT>
                <KEYWORD>while</KEYWORD> (<VARIABLE>$code</VARIABLE>[<NUMERIC>0</NUMERIC>] <OPERATOR>=~</OPERATOR> <DELIMITER>m/</DELIMITER><REGEX>omp[_\ ][\w\ ]+</REGEX><DELIMITER>/</DELIMITER><KEYWORD>gi</KEYWORD>) {
                    <KEYWORD>my</KEYWORD> <VARIABLE>$omp_token</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$&amp;</VARIABLE><OPERATOR>;</OPERATOR>
                    <VARIABLE>$omp_token</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>s/</DELIMITER><REGEX>\ </REGEX><DELIMITER>/</DELIMITER><STRING>_</STRING><DELIMITER>/</DELIMITER><KEYWORD>g</KEYWORD><OPERATOR>;</OPERATOR>
                    <KEYWORD>if</KEYWORD> (<VARIABLE>$omp_token</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>_$</REGEX><DELIMITER>/</DELIMITER>) { <COMMENT># check for _ at end</COMMENT>
                        <FUNCTION>chop</FUNCTION> <VARIABLE>$omp_token</VARIABLE><OPERATOR>;</OPERATOR> <COMMENT># remove extra _ at end</COMMENT>
                    }
                    <VARIABLE>$omp_counts</VARIABLE>{<VARIABLE>$omp_token</VARIABLE>}<OPERATOR>++;</OPERATOR>
                }
                <VARIABLE>$inComment</VARIABLE><OPERATOR>++;</OPERATOR> <COMMENT># mark that in multi-line comment</COMMENT>
            }
            <KEYWORD>elsif</KEYWORD> (<VARIABLE>$line</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>$cmnt_single</REGEX><DELIMITER>/</DELIMITER>) { <COMMENT># check single line cmnt</COMMENT>
                <COMMENT># split on // to get part preceeding the //</COMMENT>
                <KEYWORD>my</KEYWORD> <VARIABLE>@code</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>split</FUNCTION>(<DELIMITER>/</DELIMITER><REGEX>$cmnt_single</REGEX><DELIMITER>/</DELIMITER><OPERATOR>,</OPERATOR> <VARIABLE>$line</VARIABLE>)<OPERATOR>;</OPERATOR>

                <COMMENT># process part before //, either blank or code</COMMENT>
                <KEYWORD>while</KEYWORD> (<VARIABLE>$code</VARIABLE>[<NUMERIC>0</NUMERIC>] <OPERATOR>=~</OPERATOR> <DELIMITER>m/</DELIMITER><REGEX>omp[_\ ][\w\ ]+</REGEX><DELIMITER>/</DELIMITER><KEYWORD>gi</KEYWORD>) {
                    <KEYWORD>my</KEYWORD> <VARIABLE>$omp_token</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$&amp;</VARIABLE><OPERATOR>;</OPERATOR>
                    <VARIABLE>$omp_token</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>s/</DELIMITER><REGEX>\ </REGEX><DELIMITER>/</DELIMITER><STRING>_</STRING><DELIMITER>/</DELIMITER><KEYWORD>g</KEYWORD><OPERATOR>;</OPERATOR>
                    <KEYWORD>if</KEYWORD> (<VARIABLE>$omp_token</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>_$</REGEX><DELIMITER>/</DELIMITER>) { <COMMENT># check for _ at end</COMMENT>
                        <FUNCTION>chop</FUNCTION> <VARIABLE>$omp_token</VARIABLE><OPERATOR>;</OPERATOR> <COMMENT># remove extra _ at end</COMMENT>
                    }
                    <VARIABLE>$omp_counts</VARIABLE>{<VARIABLE>$omp_token</VARIABLE>}<OPERATOR>++;</OPERATOR>
                }
            }
            <KEYWORD>if</KEYWORD> (<VARIABLE>$line</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>$cmnt_end</REGEX><DELIMITER>/</DELIMITER>) { <COMMENT># check end of multi-line cmnt</COMMENT>
                <VARIABLE>$inComment</VARIABLE> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR> <COMMENT># cmnt end found, not in multi-line cmnt</COMMENT>
            }
            <KEYWORD>if</KEYWORD> (<VARIABLE>$inComment</VARIABLE> <OPERATOR>&gt;</OPERATOR> <NUMERIC>0</NUMERIC>) {

                <COMMENT># if inComment &gt; 0 then in multi-line comment</COMMENT>
                <COMMENT># so don't process $line, either processed earlier or</COMMENT>
                <COMMENT># doesn't need to be processed because line is only comment text</COMMENT>
                <KEYWORD>next</KEYWORD><OPERATOR>;</OPERATOR>
            }
            <KEYWORD>else</KEYWORD> { <COMMENT># not in multi-line comment, process $line</COMMENT>
                <KEYWORD>while</KEYWORD> (<VARIABLE>$line</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>m/</DELIMITER><REGEX>omp[_\ ][\w\ ]+</REGEX><DELIMITER>/</DELIMITER><KEYWORD>gi</KEYWORD>) {
                    <KEYWORD>my</KEYWORD> <VARIABLE>$omp_token</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$&amp;</VARIABLE><OPERATOR>;</OPERATOR>
                    <VARIABLE>$omp_token</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>s/</DELIMITER><REGEX>\ </REGEX><DELIMITER>/</DELIMITER><STRING>_</STRING><DELIMITER>/</DELIMITER><KEYWORD>g</KEYWORD><OPERATOR>;</OPERATOR>
                    <KEYWORD>if</KEYWORD> (<VARIABLE>$omp_token</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>_$</REGEX><DELIMITER>/</DELIMITER>) { <COMMENT># check for _ at end</COMMENT>
                        <FUNCTION>chop</FUNCTION> <VARIABLE>$omp_token</VARIABLE><OPERATOR>;</OPERATOR> <COMMENT># remove extra _ at end</COMMENT>
                    }
                    <VARIABLE>$omp_counts</VARIABLE>{<VARIABLE>$omp_token</VARIABLE>}<OPERATOR>++;</OPERATOR>
                }
            }
        }
        <KEYWORD>elsif</KEYWORD> (<VARIABLE>$lang</VARIABLE> <OPERATOR>eq</OPERATOR> <STRING>'FORTRAN'</STRING>) {
            <KEYWORD>if</KEYWORD> (<VARIABLE>$line</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>^C</REGEX><DELIMITER>/</DELIMITER> <OPERATOR>||</OPERATOR> (<VARIABLE>$line</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>^!</REGEX><DELIMITER>/</DELIMITER> <OPERATOR>&amp;&amp;</OPERATOR> <VARIABLE>$line</VARIABLE> <OPERATOR>!~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>^!\$OMP</REGEX><DELIMITER>/</DELIMITER><KEYWORD>i</KEYWORD>)) {
                <KEYWORD>next</KEYWORD><OPERATOR>;</OPERATOR> <COMMENT># comment starts a beginning of line, don't process</COMMENT>
            }
            <KEYWORD>elsif</KEYWORD> (<VARIABLE>$line</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>!</REGEX><DELIMITER>/</DELIMITER> <OPERATOR>&amp;&amp;</OPERATOR> <VARIABLE>$line</VARIABLE> <OPERATOR>!~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>!\$</REGEX><DELIMITER>/</DELIMITER>) {

                <COMMENT># split on !, only check part before !</COMMENT>
                <KEYWORD>my</KEYWORD> <VARIABLE>@code</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>split</FUNCTION>(<DELIMITER>/</DELIMITER><REGEX>!</REGEX><DELIMITER>/</DELIMITER><OPERATOR>,</OPERATOR> <VARIABLE>$line</VARIABLE>)<OPERATOR>;</OPERATOR>
                <VARIABLE>$line</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$code</VARIABLE>[<NUMERIC>0</NUMERIC>]<OPERATOR>;</OPERATOR>
            }
            <KEYWORD>while</KEYWORD> (<VARIABLE>$line</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>m/</DELIMITER><REGEX>OMP[_\ ][\w\ ]+</REGEX><DELIMITER>/</DELIMITER><KEYWORD>gi</KEYWORD>) {
                <KEYWORD>my</KEYWORD> <VARIABLE>$omp_token</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$&amp;</VARIABLE><OPERATOR>;</OPERATOR>
                <VARIABLE>$omp_token</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>s/</DELIMITER><REGEX>\ </REGEX><DELIMITER>/</DELIMITER><STRING>_</STRING><DELIMITER>/</DELIMITER><KEYWORD>g</KEYWORD><OPERATOR>;</OPERATOR>
                <KEYWORD>if</KEYWORD> (<VARIABLE>$omp_token</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>_$</REGEX><DELIMITER>/</DELIMITER>) { <COMMENT># check for _ at end</COMMENT>
                    <FUNCTION>chop</FUNCTION> <VARIABLE>$omp_token</VARIABLE><OPERATOR>;</OPERATOR> <COMMENT># remove extra _ at end</COMMENT>
                }
                <VARIABLE>$omp_counts</VARIABLE>{<VARIABLE>$omp_token</VARIABLE>}<OPERATOR>++;</OPERATOR>
            }
        }
    }

    <COMMENT># return the OpenMP hash</COMMENT>
    <VARIABLE>%omp_counts</VARIABLE><OPERATOR>;</OPERATOR>
}

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## FUNCTION:</COMMENT>
<COMMENT>##   ExpandDirectory -- Expand a directory into all its elements</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SYNOPSIS:</COMMENT>
<COMMENT>##   @elements = &amp;ExpandDirectory($dir);</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## ARGUMENTS:</COMMENT>
<COMMENT>##   $dir : The pathname of a directory</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## RETURN VALUE:</COMMENT>
<COMMENT>##   An array containing the pathname of all elements in the directory</COMMENT>
<COMMENT>##   (NOT including '.' or '..').</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## PRECONDITIONS:</COMMENT>
<COMMENT>##   Uses the global %TRAVERSED to keep track of which directories</COMMENT>
<COMMENT>##   have already been expanded (so we dont get into an infinite</COMMENT>
<COMMENT>##   directory exandning loop).</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SIDE EFFECTS:</COMMENT>
<COMMENT>##   Records the traversed directory in %TRAVERSED.</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>my</KEYWORD> <VARIABLE>%TRAVERSED</VARIABLE> <OPERATOR>=</OPERATOR> ()<OPERATOR>;</OPERATOR>
<KEYWORD>sub</KEYWORD> ExpandDirectory {
    <KEYWORD>my</KEYWORD>(<VARIABLE>$dir</VARIABLE>) <OPERATOR>=</OPERATOR> <VARIABLE>@_</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD>(<VARIABLE>$absdir</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>@elements</VARIABLE>)<OPERATOR>;</OPERATOR>
    <KEYWORD>local</KEYWORD>(<VARIABLE>$_</VARIABLE>)<OPERATOR>;</OPERATOR>
    <KEYWORD>unless</KEYWORD> (<VARIABLE>$Is_WinDos</VARIABLE>) {
        <COMMENT>## On Unix, make sure we dont traverse this directory twice</COMMENT>
        <COMMENT>## due to symlinks</COMMENT>
        <KEYWORD>my</KEYWORD>(<VARIABLE>$absdir</VARIABLE>)<OPERATOR>;</OPERATOR>
        <FUNCTION>chomp</FUNCTION>(<VARIABLE>$absdir</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>`cd $dir &amp;&amp; /bin/pwd`</FUNCTION>)<OPERATOR>;</OPERATOR>
        <KEYWORD>return</KEYWORD> <VARIABLE>@elements</VARIABLE> <KEYWORD>if</KEYWORD> (<KEYWORD>defined</KEYWORD> <VARIABLE>$TRAVERSED</VARIABLE>{<VARIABLE>$absdir</VARIABLE>})<OPERATOR>;</OPERATOR>
        <OPERATOR>++</OPERATOR><VARIABLE>$TRAVERSED</VARIABLE>{<VARIABLE>$absdir</VARIABLE>}<OPERATOR>;</OPERATOR>
    }
    <COMMENT>## Open the directory for reading</COMMENT>
    <KEYWORD>unless</KEYWORD> (<FUNCTION>opendir</FUNCTION>(<CONSTANT>DIRECTORY</CONSTANT><OPERATOR>,</OPERATOR> <VARIABLE>$dir</VARIABLE>)) {
        <OPERATOR>&amp;</OPERATOR>error_msg(<STRING>"Can't traverse directory $dir: $!"</STRING>)<OPERATOR>;</OPERATOR>
        <KEYWORD>return</KEYWORD> <VARIABLE>@elements</VARIABLE><OPERATOR>;</OPERATOR>
    }
    <VARIABLE>$dir</VARIABLE> <OPERATOR>=</OPERATOR> <STRING>''</STRING> <KEYWORD>if</KEYWORD> (<VARIABLE>$dir</VARIABLE> <OPERATOR>eq</OPERATOR> <VARIABLE>$Path_Sep</VARIABLE>)<OPERATOR>;</OPERATOR> <COMMENT>## might be root</COMMENT>
    <COMMENT>## Read all the directory entries</COMMENT>
    <KEYWORD>while</KEYWORD> (<VARIABLE>$_</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>readdir</FUNCTION>(<CONSTANT>DIRECTORY</CONSTANT>)) {
        <KEYWORD>next</KEYWORD> <KEYWORD>if</KEYWORD> (<DELIMITER>/</DELIMITER><REGEX>^\.*$</REGEX><DELIMITER>/</DELIMITER>)<OPERATOR>;</OPERATOR>  <COMMENT>## ignore . and ..</COMMENT>
        <FUNCTION>push</FUNCTION>(<VARIABLE>@elements</VARIABLE><OPERATOR>,</OPERATOR> <STRING>"${dir}${Path_Sep}$_"</STRING>)<OPERATOR>;</OPERATOR>
    }
    <FUNCTION>closedir</FUNCTION>(<CONSTANT>DIRECTORY</CONSTANT>)<OPERATOR>;</OPERATOR>
    (<VARIABLE>@elements</VARIABLE>)<OPERATOR>;</OPERATOR>
}

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## FUNCTION:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SYNOPSIS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## ARGUMENTS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## RETURN VALUE:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## PRECONDITIONS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SIDE EFFECTS:</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>sub</KEYWORD> CountFiles {
    <KEYWORD>my</KEYWORD> <VARIABLE>@files</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>@_</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>local</KEYWORD> (<VARIABLE>$_</VARIABLE>)<OPERATOR>;</OPERATOR>
    <KEYWORD>foreach</KEYWORD> (<VARIABLE>@files</VARIABLE>) {
        <KEYWORD>if</KEYWORD> (<OPERATOR>-</OPERATOR>d <VARIABLE>$_</VARIABLE>  <OPERATOR>&amp;&amp;</OPERATOR> <VARIABLE>$OPTS</VARIABLE>{<STRING>'recurse'</STRING>}) {
            <KEYWORD>my</KEYWORD> <VARIABLE>@entries</VARIABLE> <OPERATOR>=</OPERATOR> ExpandDirectory(<VARIABLE>$_</VARIABLE>)<OPERATOR>;</OPERATOR>
            CountFiles(<VARIABLE>@entries</VARIABLE>)<OPERATOR>;</OPERATOR>
            <KEYWORD>next</KEYWORD><OPERATOR>;</OPERATOR>
        }
        <COMMENT>## See if we should exclude this file from the list</COMMENT>
        <KEYWORD>next</KEYWORD> <KEYWORD>if</KEYWORD> (ExcludeFile(<VARIABLE>$_</VARIABLE>))<OPERATOR>;</OPERATOR>
        <KEYWORD>if</KEYWORD> (<OPERATOR>-</OPERATOR>d <VARIABLE>$_</VARIABLE>  <OPERATOR>&amp;&amp;</OPERATOR> <VARIABLE>$OPTS</VARIABLE>{<STRING>'recurse'</STRING>}) {
            ErrorMsg(<STRING>"$_ is a directory."</STRING>) <KEYWORD>unless</KEYWORD> (<VARIABLE>$OPTS</VARIABLE>{<STRING>'ignore'</STRING>})<OPERATOR>;</OPERATOR>
            <KEYWORD>next</KEYWORD><OPERATOR>;</OPERATOR>
        }
        <KEYWORD>if</KEYWORD> (<OPERATOR>-</OPERATOR>B _) {
            ErrorMsg(<STRING>"$_ is a binary file."</STRING>) <KEYWORD>unless</KEYWORD> (<VARIABLE>$OPTS</VARIABLE>{<STRING>'ignore'</STRING>})<OPERATOR>;</OPERATOR>
            <KEYWORD>next</KEYWORD><OPERATOR>;</OPERATOR>
        }
        <COMMENT>## See if we can determine the programming language</COMMENT>
        (<VARIABLE>$LANG_NAME</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$LANG_REF</VARIABLE>) <OPERATOR>=</OPERATOR> (<STRING>''</STRING><OPERATOR>,</OPERATOR> <STRING>''</STRING>)<OPERATOR>;</OPERATOR>
        SetLanguage(<VARIABLE>$_</VARIABLE>)<OPERATOR>;</OPERATOR>
        ErrorMsg(<STRING>"Can't determine programming language for $_"</STRING>)
          <KEYWORD>unless</KEYWORD> (<VARIABLE>$LANG_REF</VARIABLE> <OPERATOR>||</OPERATOR> <VARIABLE>$OPTS</VARIABLE>{<STRING>'ignore'</STRING>})<OPERATOR>;</OPERATOR>
        <KEYWORD>next</KEYWORD> <KEYWORD>unless</KEYWORD> (<FUNCTION>exists</FUNCTION> <VARIABLE>$LANG_RULES</VARIABLE>{<VARIABLE>$LANG_REF</VARIABLE>})<OPERATOR>;</OPERATOR>
        <KEYWORD>my</KEYWORD> <VARIABLE>%counts</VARIABLE> <OPERATOR>=</OPERATOR> <OPERATOR>&amp;</OPERATOR>SourceCount(<VARIABLE>$_</VARIABLE><OPERATOR>,</OPERATOR> @{ <VARIABLE>$LANG_RULES</VARIABLE>{<VARIABLE>$LANG_REF</VARIABLE>} })<OPERATOR>;</OPERATOR>
        <KEYWORD>next</KEYWORD> <KEYWORD>if</KEYWORD> (<VARIABLE>$counts</VARIABLE>{<STRING>'Error'</STRING>} <OPERATOR>||</OPERATOR> <OPERATOR>!</OPERATOR><VARIABLE>$counts</VARIABLE>{<STRING>'Lines'</STRING>})<OPERATOR>;</OPERATOR>
        PrintCounts(<STRING>'s'</STRING><OPERATOR>,</OPERATOR> <STRING>''</STRING><OPERATOR>,</OPERATOR> <STRING>''</STRING><OPERATOR>,</OPERATOR> <OPERATOR>\</OPERATOR><VARIABLE>@Count_Names</VARIABLE><OPERATOR>,</OPERATOR> <STRING>""</STRING><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR>counts<OPERATOR>,</OPERATOR> <NUMERIC>0</NUMERIC>)
          <KEYWORD>if</KEYWORD> ((<OPERATOR>++</OPERATOR><VARIABLE>$NumSources</VARIABLE> <OPERATOR>==</OPERATOR> <NUMERIC>1</NUMERIC>) <OPERATOR>&amp;&amp;</OPERATOR> <VARIABLE>$SECS</VARIABLE>{<STRING>'header'</STRING>})<OPERATOR>;</OPERATOR>
        <OPERATOR>++</OPERATOR><VARIABLE>$NumSources</VARIABLE>{<VARIABLE>$LANG_NAME</VARIABLE>}<OPERATOR>;</OPERATOR>
        <KEYWORD>my</KEYWORD> (<VARIABLE>@kindList</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$kind</VARIABLE>) <OPERATOR>=</OPERATOR> (<STRING>""</STRING>)<OPERATOR>;</OPERATOR>
        <VARIABLE>@kindList</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'&lt;'</STRING><OPERATOR>,</OPERATOR> <STRING>'&gt;'</STRING>) <KEYWORD>if</KEYWORD> (<VARIABLE>$OPTS</VARIABLE>{<STRING>'diff'</STRING>})<OPERATOR>;</OPERATOR>
        <KEYWORD>for</KEYWORD> <VARIABLE>$kind</VARIABLE> (<VARIABLE>@kindList</VARIABLE>) {
            PrintCounts(<STRING>'d'</STRING><OPERATOR>,</OPERATOR> <STRING>"$_$KIND{$kind}"</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$LANG_NAME</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\</OPERATOR><VARIABLE>@Count_Names</VARIABLE><OPERATOR>,</OPERATOR>
                <VARIABLE>$kind</VARIABLE><OPERATOR>,</OPERATOR> <OPERATOR>\%</OPERATOR>counts<OPERATOR>,</OPERATOR> <NUMERIC>0</NUMERIC>)<OPERATOR>;</OPERATOR>
        }

        <KEYWORD>for</KEYWORD> (<FUNCTION>keys</FUNCTION> <VARIABLE>%counts</VARIABLE>) {
            <VARIABLE>$Totals</VARIABLE>{<VARIABLE>$_</VARIABLE>} <OPERATOR>+=</OPERATOR> <VARIABLE>$counts</VARIABLE>{<VARIABLE>$_</VARIABLE>}<OPERATOR>;</OPERATOR>
            <VARIABLE>$Totals</VARIABLE>{<VARIABLE>$LANG_NAME</VARIABLE>}{<VARIABLE>$_</VARIABLE>} <OPERATOR>+=</OPERATOR> <VARIABLE>$counts</VARIABLE>{<VARIABLE>$_</VARIABLE>}<OPERATOR>;</OPERATOR>
        }
    }
}

<COMMENT>## Report the totals for each language and overall</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## FUNCTION:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SYNOPSIS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## ARGUMENTS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## RETURN VALUE:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## PRECONDITIONS:</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SIDE EFFECTS:</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>sub</KEYWORD> PrintTotals {
    <KEYWORD>local</KEYWORD> <VARIABLE>$_</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> (<VARIABLE>$totals</VARIABLE>) <OPERATOR>=</OPERATOR> <VARIABLE>@_</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>$str</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>@languages</VARIABLE> <OPERATOR>=</OPERATOR> (<FUNCTION>keys</FUNCTION> <VARIABLE>%NumSources</VARIABLE>)<OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> (<VARIABLE>@kindList</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$kind</VARIABLE>) <OPERATOR>=</OPERATOR> (<STRING>""</STRING>)<OPERATOR>;</OPERATOR>
    <VARIABLE>@kindList</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'&lt;'</STRING><OPERATOR>,</OPERATOR> <STRING>'&gt;'</STRING>) <KEYWORD>if</KEYWORD> (<VARIABLE>$OPTS</VARIABLE>{<STRING>'diff'</STRING>})<OPERATOR>;</OPERATOR>

    <KEYWORD>foreach</KEYWORD> (<VARIABLE>@languages</VARIABLE>) {
        <KEYWORD>for</KEYWORD> <VARIABLE>$kind</VARIABLE> (<VARIABLE>@kindList</VARIABLE>) {
            <KEYWORD>if</KEYWORD> (<VARIABLE>$SECS</VARIABLE>{<STRING>'langtotals'</STRING>}) {
                <VARIABLE>$str</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>sprintf</FUNCTION>(<STRING>"%s  (%d %s)"</STRING><OPERATOR>,</OPERATOR>
                    <STRING>"----- $_$KIND{$kind} -----"</STRING><OPERATOR>,</OPERATOR>
                    <VARIABLE>$NumSources</VARIABLE>{<VARIABLE>$_</VARIABLE>}<OPERATOR>,</OPERATOR>
                    (<VARIABLE>$NumSources</VARIABLE>{<VARIABLE>$_</VARIABLE>} <OPERATOR>==</OPERATOR> <NUMERIC>1</NUMERIC>) <OPERATOR>?</OPERATOR> <STRING>'file'</STRING> <OPERATOR>:</OPERATOR> <STRING>'files'</STRING>)<OPERATOR>;</OPERATOR>
                PrintCounts(<STRING>'d'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$str</VARIABLE><OPERATOR>,</OPERATOR> <STRING>''</STRING><OPERATOR>,</OPERATOR> <OPERATOR>\</OPERATOR><VARIABLE>@Count_Names</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$kind</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$totals</VARIABLE><OPERATOR>-&gt;</OPERATOR>{<VARIABLE>$_</VARIABLE>}<OPERATOR>,</OPERATOR> <NUMERIC>1</NUMERIC>)<OPERATOR>;</OPERATOR>
            }
        }
    }
    <KEYWORD>for</KEYWORD> <VARIABLE>$kind</VARIABLE> (<VARIABLE>@kindList</VARIABLE>) {
        <VARIABLE>$str</VARIABLE> <OPERATOR>=</OPERATOR> <FUNCTION>sprintf</FUNCTION>(<STRING>"%s  (%d %s)"</STRING><OPERATOR>,</OPERATOR>
            <STRING>"***** TOTAL$KIND{$kind} *****"</STRING><OPERATOR>,</OPERATOR>
            <VARIABLE>$NumSources</VARIABLE><OPERATOR>,</OPERATOR>
            (<VARIABLE>$NumSources</VARIABLE> <OPERATOR>==</OPERATOR> <NUMERIC>1</NUMERIC>) <OPERATOR>?</OPERATOR> <STRING>'file'</STRING> <OPERATOR>:</OPERATOR> <STRING>'files'</STRING>)<OPERATOR>;</OPERATOR>
        PrintCounts(<STRING>'d'</STRING><OPERATOR>,</OPERATOR> <VARIABLE>$str</VARIABLE><OPERATOR>,</OPERATOR> <STRING>''</STRING><OPERATOR>,</OPERATOR> <OPERATOR>\</OPERATOR><VARIABLE>@Count_Names</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$kind</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$totals</VARIABLE><OPERATOR>,</OPERATOR> <NUMERIC>1</NUMERIC>)
          <KEYWORD>if</KEYWORD> (<VARIABLE>$SECS</VARIABLE>{<STRING>'totals'</STRING>} <OPERATOR>&amp;&amp;</OPERATOR> ((<OPERATOR>!</OPERATOR><VARIABLE>$SECS</VARIABLE>{<STRING>'langtotals'</STRING>}) <OPERATOR>||</OPERATOR> (<VARIABLE>@languages</VARIABLE> <OPERATOR>&gt;</OPERATOR> <NUMERIC>1</NUMERIC>)))<OPERATOR>;</OPERATOR>
    }
}

<KEYWORD>use</KEYWORD> <OBJ>Getopt</OBJ><OPERATOR>::</OPERATOR><OO>Long</OO><OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>@Mapping</VARIABLE> <OPERATOR>=</OPERATOR> ()<OPERATOR>;</OPERATOR>
<KEYWORD>my</KEYWORD> <VARIABLE>%MappingRule</VARIABLE> <OPERATOR>=</OPERATOR> ()<OPERATOR>;</OPERATOR>
<COMMENT>## main -- procedural interface to the script.</COMMENT>
<KEYWORD>sub</KEYWORD> main {
    <KEYWORD>local</KEYWORD> <VARIABLE>@ARGV</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>@_</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>local</KEYWORD> <VARIABLE>$_</VARIABLE><OPERATOR>;</OPERATOR>

    <COMMENT>## Default options</COMMENT>
    <VARIABLE>$OPTS</VARIABLE>{<STRING>'debug'</STRING>}        <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
    <VARIABLE>$OPTS</VARIABLE>{<STRING>'help'</STRING>}         <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
    <VARIABLE>$OPTS</VARIABLE>{<STRING>'delim_ignore'</STRING>} <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
    <VARIABLE>$OPTS</VARIABLE>{<STRING>'diff'</STRING>}         <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
    <VARIABLE>$OPTS</VARIABLE>{<STRING>'filelist'</STRING>}     <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
    <VARIABLE>$OPTS</VARIABLE>{<STRING>'ignore'</STRING>}       <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
    <VARIABLE>$OPTS</VARIABLE>{<STRING>'pred'</STRING>}         <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
    <VARIABLE>$OPTS</VARIABLE>{<STRING>'recurse'</STRING>}      <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
    <VARIABLE>$OPTS</VARIABLE>{<STRING>'counts'</STRING>}       <OPERATOR>=</OPERATOR> <STRING>"lines+blank+cmnts+ncsl+tptoks"</STRING><OPERATOR>;</OPERATOR>
    <VARIABLE>$OPTS</VARIABLE>{<STRING>'sections'</STRING>}     <OPERATOR>=</OPERATOR> <STRING>"header+files+langtotals+totals"</STRING><OPERATOR>;</OPERATOR>
    <VARIABLE>$OPTS</VARIABLE>{<STRING>'fromversion'</STRING>}  <OPERATOR>=</OPERATOR> <STRING>""</STRING><OPERATOR>;</OPERATOR>
    <VARIABLE>$OPTS</VARIABLE>{<STRING>'prefix'</STRING>}       <OPERATOR>=</OPERATOR> <STRING>""</STRING><OPERATOR>;</OPERATOR>
    <VARIABLE>$OPTS</VARIABLE>{<STRING>'toversion'</STRING>}    <OPERATOR>=</OPERATOR> <STRING>""</STRING><OPERATOR>;</OPERATOR>
    <VARIABLE>$OPTS</VARIABLE>{<STRING>'vcstring'</STRING>}     <OPERATOR>=</OPERATOR> <STRING>""</STRING><OPERATOR>;</OPERATOR>
    <VARIABLE>$OPTS</VARIABLE>{<STRING>'language'</STRING>}     <OPERATOR>=</OPERATOR> []<OPERATOR>;</OPERATOR>
    <VARIABLE>$OPTS</VARIABLE>{<STRING>'name'</STRING>}         <OPERATOR>=</OPERATOR> []<OPERATOR>;</OPERATOR>
    <VARIABLE>$OPTS</VARIABLE>{<STRING>'except'</STRING>}       <OPERATOR>=</OPERATOR> []<OPERATOR>;</OPERATOR>
    <VARIABLE>$OPTS</VARIABLE>{<STRING>'separate'</STRING>}     <OPERATOR>=</OPERATOR> []<OPERATOR>;</OPERATOR>
    <VARIABLE>$OPTS</VARIABLE>{<STRING>'xml_output'</STRING>}   <OPERATOR>=</OPERATOR> <STRING>""</STRING><OPERATOR>;</OPERATOR>
    <VARIABLE>$OPTS</VARIABLE>{<STRING>'tm3_output'</STRING>}   <OPERATOR>=</OPERATOR> <STRING>""</STRING><OPERATOR>;</OPERATOR>
    <VARIABLE>$OPTS</VARIABLE>{<STRING>'default_exclude'</STRING>} <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
    <VARIABLE>$OPTS</VARIABLE>{<STRING>'excludedir'</STRING>}   <OPERATOR>=</OPERATOR> []<OPERATOR>;</OPERATOR>
    <VARIABLE>$OPTS</VARIABLE>{<STRING>'mapping'</STRING>}   <OPERATOR>=</OPERATOR> <STRING>""</STRING><OPERATOR>;</OPERATOR>

    <COMMENT>## Parse options</COMMENT>
    <KEYWORD>my</KEYWORD> <VARIABLE>$rc</VARIABLE> <OPERATOR>=</OPERATOR> GetOptions( <OPERATOR>\%</OPERATOR><CONSTANT>OPTS</CONSTANT><OPERATOR>,</OPERATOR>
        <STRING>"debug"</STRING><OPERATOR>,</OPERATOR>
        <STRING>"help"</STRING><OPERATOR>,</OPERATOR>
        <STRING>"output=s"</STRING><OPERATOR>,</OPERATOR>
        <STRING>"counts=s"</STRING><OPERATOR>,</OPERATOR>
        <STRING>"delim_ignore|delim-ignore"</STRING><OPERATOR>,</OPERATOR>
        <STRING>"diff"</STRING><OPERATOR>,</OPERATOR>
        <STRING>"except=s@"</STRING><OPERATOR>,</OPERATOR>
        <STRING>"filelist"</STRING><OPERATOR>,</OPERATOR>
        <STRING>"fromversion=s"</STRING><OPERATOR>,</OPERATOR>
        <STRING>"ignore"</STRING><OPERATOR>,</OPERATOR>
        <STRING>"language=s@"</STRING><OPERATOR>,</OPERATOR>
        <STRING>"name=s@"</STRING><OPERATOR>,</OPERATOR>
        <STRING>"pred"</STRING><OPERATOR>,</OPERATOR>
        <STRING>"prefix=s"</STRING><OPERATOR>,</OPERATOR>
        <STRING>"recurse"</STRING><OPERATOR>,</OPERATOR>
        <STRING>"sections=s"</STRING><OPERATOR>,</OPERATOR>
        <STRING>"separate=s@"</STRING><OPERATOR>,</OPERATOR>
        <STRING>"toversion=s"</STRING><OPERATOR>,</OPERATOR>
        <STRING>"vcstring=s"</STRING><OPERATOR>,</OPERATOR>
        <STRING>"xml_output=s"</STRING><OPERATOR>,</OPERATOR>
        <STRING>"tm3_output=s"</STRING><OPERATOR>,</OPERATOR>
        <STRING>"default_exclude"</STRING><OPERATOR>,</OPERATOR>
        <STRING>"excludedir=s@"</STRING><OPERATOR>,</OPERATOR>
        <STRING>"mapping=s"</STRING>
      )<OPERATOR>;</OPERATOR>
    Usage(<NUMERIC>1</NUMERIC>) <KEYWORD>if</KEYWORD> (<VARIABLE>$OPTS</VARIABLE>{<STRING>'help'</STRING>})<OPERATOR>;</OPERATOR>
    Usage(<NUMERIC>2</NUMERIC>) <KEYWORD>unless</KEYWORD> (<VARIABLE>$rc</VARIABLE>)<OPERATOR>;</OPERATOR>
    Usage(<NUMERIC>2</NUMERIC>) <KEYWORD>if</KEYWORD> ((<VARIABLE>@ARGV</VARIABLE> <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC>) <OPERATOR>&amp;&amp;</OPERATOR> (<OPERATOR>-</OPERATOR>t <CONSTANT>STDIN</CONSTANT>))<OPERATOR>;</OPERATOR>

    <COMMENT>## Check for syntax errors</COMMENT>
    <KEYWORD>if</KEYWORD> (<VARIABLE>$OPTS</VARIABLE>{<STRING>'pred'</STRING>} <OPERATOR>&amp;&amp;</OPERATOR> <VARIABLE>$OPTS</VARIABLE>{<STRING>'fromversion'</STRING>}) {
        ErrorMsg(<STRING>"The '-pred' and '-fromversion' options are incompatible!"</STRING>)<OPERATOR>;</OPERATOR>
        <OPERATOR>++</OPERATOR><VARIABLE>$ERRORS</VARIABLE><OPERATOR>;</OPERATOR>
    }
    CheckLanguage(@{ <VARIABLE>$OPTS</VARIABLE>{<STRING>'language'</STRING>} }) <KEYWORD>if</KEYWORD> (@{ <VARIABLE>$OPTS</VARIABLE>{<STRING>'language'</STRING>} } <OPERATOR>&gt;</OPERATOR> <NUMERIC>0</NUMERIC>)<OPERATOR>;</OPERATOR>
    CheckSections(<VARIABLE>$OPTS</VARIABLE>{<STRING>'sections'</STRING>}) <KEYWORD>if</KEYWORD> (<VARIABLE>$OPTS</VARIABLE>{<STRING>'sections'</STRING>})<OPERATOR>;</OPERATOR>
    CheckCounts(<VARIABLE>$OPTS</VARIABLE>{<STRING>'counts'</STRING>}) <KEYWORD>if</KEYWORD> (<VARIABLE>$OPTS</VARIABLE>{<STRING>'counts'</STRING>})<OPERATOR>;</OPERATOR>

    Usage(<NUMERIC>2</NUMERIC>) <KEYWORD>if</KEYWORD> (<VARIABLE>$ERRORS</VARIABLE>)<OPERATOR>;</OPERATOR>

    <COMMENT>## Redirect STDOUT if requested</COMMENT>
    <KEYWORD>if</KEYWORD> (<VARIABLE>$OPTS</VARIABLE>{<STRING>'output'</STRING>}) {
        <FUNCTION>close</FUNCTION> <CONSTANT>STDOUT</CONSTANT><OPERATOR>;</OPERATOR>
        <FUNCTION>open</FUNCTION>(<CONSTANT>STDOUT</CONSTANT><OPERATOR>,</OPERATOR> <STRING>"&gt;$OPTS{'output'}"</STRING>)
          <OPERATOR>or</OPERATOR> FatalMsg(<STRING>"Unable to redirect STDOUT to $OPTS{'output'}: $!"</STRING>)<OPERATOR>;</OPERATOR>
    }

    <KEYWORD>if</KEYWORD> (<VARIABLE>$OPTS</VARIABLE>{<STRING>'pred'</STRING>} <OPERATOR>||</OPERATOR> <VARIABLE>$OPTS</VARIABLE>{<STRING>'fromversion'</STRING>} <OPERATOR>||</OPERATOR> <VARIABLE>$OPTS</VARIABLE>{<STRING>'toversion'</STRING>}) {
        <COMMENT>## Set mandatory options for using cdiff</COMMENT>
        <VARIABLE>$OPTS</VARIABLE>{<STRING>'diff'</STRING>}     <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC><OPERATOR>;</OPERATOR>
        <VARIABLE>$OPTS</VARIABLE>{<STRING>'separate'</STRING>} <OPERATOR>=</OPERATOR> [<STRING>'-----'</STRING>]<OPERATOR>;</OPERATOR>
    }
    <VARIABLE>%KIND</VARIABLE> <OPERATOR>=</OPERATOR> (
        <STRING>''</STRING> <OPERATOR>,</OPERATOR> <STRING>''</STRING><OPERATOR>,</OPERATOR>
        <STRING>'&lt;'</STRING><OPERATOR>,</OPERATOR> <STRING>' DELETED'</STRING><OPERATOR>,</OPERATOR>
        <STRING>'&gt;'</STRING><OPERATOR>,</OPERATOR> <STRING>' INSERTED'</STRING>
      )<OPERATOR>;</OPERATOR>
    <KEYWORD>if</KEYWORD> (<VARIABLE>$OPTS</VARIABLE>{<STRING>'mapping'</STRING>}) {

        <COMMENT># read in the file first and construct the man-made rule table</COMMENT>
        <FUNCTION>open</FUNCTION>(<CONSTANT>MAPPING</CONSTANT><OPERATOR>,</OPERATOR> <VARIABLE>$OPTS</VARIABLE>{<STRING>'mapping'</STRING>}) <OPERATOR>||</OPERATOR> FatalMsg(<STRING>"The mapping file does not exist"</STRING>)<OPERATOR>;</OPERATOR>
        <KEYWORD>while</KEYWORD> (<OPERATOR>&lt;</OPERATOR><CONSTANT>MAPPING</CONSTANT><OPERATOR>&gt;</OPERATOR>) {
            <FUNCTION>chomp</FUNCTION>()<OPERATOR>;</OPERATOR>
            <KEYWORD>if</KEYWORD> (<VARIABLE>$_</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>m/</DELIMITER><REGEX>(\S*)\s*(\S*)</REGEX><DELIMITER>/</DELIMITER>) {

             <COMMENT># print($1);</COMMENT>
             <COMMENT># print($2);</COMMENT>
             <COMMENT># So $1 will be the regular expression and $2 will be the filetype.</COMMENT>
                <FUNCTION>push</FUNCTION> (<VARIABLE>@Mapping</VARIABLE><OPERATOR>,</OPERATOR> <VARIABLE>$1</VARIABLE>)<OPERATOR>;</OPERATOR>
                <VARIABLE>$MappingRule</VARIABLE>{<VARIABLE>$1</VARIABLE>} <OPERATOR>=</OPERATOR> <VARIABLE>$2</VARIABLE><OPERATOR>;</OPERATOR>
            }
        }
        <FUNCTION>close</FUNCTION>(<CONSTANT>MAPPING</CONSTANT>)<OPERATOR>;</OPERATOR>
    }

    <KEYWORD>if</KEYWORD> (<OPERATOR>!</OPERATOR> <VARIABLE>$OPTS</VARIABLE>{<STRING>'filelist'</STRING>}) {
        <VARIABLE>@ARGV</VARIABLE> <OPERATOR>=</OPERATOR> (<STRING>'-'</STRING>) <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <VARIABLE>@ARGV</VARIABLE>)<OPERATOR>;</OPERATOR>
        CountFiles(<VARIABLE>@ARGV</VARIABLE>)<OPERATOR>;</OPERATOR>
    }
    <KEYWORD>else</KEYWORD> {
        <COMMENT>## have to read list of filenames from input</COMMENT>
        <KEYWORD>while</KEYWORD> (<OPERATOR>&lt;&gt;</OPERATOR>) {
            <FUNCTION>chomp</FUNCTION><OPERATOR>;</OPERATOR>
            CountFiles(<VARIABLE>$_</VARIABLE>)<OPERATOR>;</OPERATOR>
        }
    }
    PrintTotals(<OPERATOR>\%</OPERATOR>Totals) <KEYWORD>if</KEYWORD> ((<VARIABLE>$SECS</VARIABLE>{<STRING>'totals'</STRING>} <OPERATOR>||</OPERATOR> <VARIABLE>$SECS</VARIABLE>{<STRING>'langtotals'</STRING>}) <OPERATOR>&amp;&amp;</OPERATOR>
        ((<OPERATOR>!</OPERATOR> <VARIABLE>$SECS</VARIABLE>{<STRING>'files'</STRING>}) <OPERATOR>||</OPERATOR> (<VARIABLE>$NumSources</VARIABLE> <OPERATOR>&gt;</OPERATOR> <NUMERIC>1</NUMERIC>)))<OPERATOR>;</OPERATOR>

    <KEYWORD>if</KEYWORD> (<VARIABLE>$OPTS</VARIABLE>{<STRING>'xml_output'</STRING>}) {
        WriteXmlToFile()<OPERATOR>;</OPERATOR>
    }
}

<COMMENT>##----------------------------------------------------------------------</COMMENT>
<COMMENT>## FUNCTION:</COMMENT>
<COMMENT>##   MappingFileType -- Return a given file's type based on the rule</COMMENT>
<COMMENT>##   provided by the user</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SYNPOSIS:</COMMENT>
<COMMENT>##   MappingFileType("README") -&gt; "Text"</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## ARGUMENTS:</COMMENT>
<COMMENT>##   Base file name without path but with suffix</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## RETURN VALUE:</COMMENT>
<COMMENT>##   File type set by the user in the rule file for specific file name</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## PRECONDITIONS:</COMMENT>
<COMMENT>##   Global @Mapping and %MappingRule</COMMENT>
<COMMENT>##</COMMENT>
<COMMENT>## SIDE EFFECTS: None</COMMENT>
<COMMENT>##----------------------------------------------------------------------</COMMENT>
<KEYWORD>sub</KEYWORD> MappingFileType {
    <KEYWORD>my</KEYWORD> <VARIABLE>$basename</VARIABLE> <OPERATOR>=</OPERATOR> <VARIABLE>$_</VARIABLE>[<NUMERIC>0</NUMERIC>]<OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>$pattern</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>foreach</KEYWORD> (<VARIABLE>@Mapping</VARIABLE>) {
        <KEYWORD>if</KEYWORD> (<VARIABLE>$basename</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>$_</REGEX><DELIMITER>/</DELIMITER>) {
            <KEYWORD>return</KEYWORD> <VARIABLE>$MappingRule</VARIABLE>{<VARIABLE>$_</VARIABLE>}<OPERATOR>;</OPERATOR>
        }
    }
    <KEYWORD>return</KEYWORD> <KEYWORD>undef</KEYWORD><OPERATOR>;</OPERATOR>
}

<COMMENT># Check if unit tests are running,</COMMENT>
<COMMENT># return 1 if true, else 0</COMMENT>
<KEYWORD>sub</KEYWORD> UnitTestsAreRunning {

    <COMMENT># The test runner is t/all_tests.t</COMMENT>
    <COMMENT># We just check if the calling program conatins the word test</COMMENT>
    <KEYWORD>return</KEYWORD> (<VARIABLE>$0</VARIABLE> <OPERATOR>=~</OPERATOR> <DELIMITER>/</DELIMITER><REGEX>test</REGEX><DELIMITER>/</DELIMITER>)<OPERATOR>;</OPERATOR>
}

<COMMENT># Write the XML data to  file</COMMENT>
<KEYWORD>sub</KEYWORD> WriteXmlToFile {

    <COMMENT># write to XML file</COMMENT>
    <KEYWORD>my</KEYWORD> <VARIABLE>$xml</VARIABLE> <OPERATOR>=</OPERATOR> <OBJ>XML</OBJ><OPERATOR>::</OPERATOR><OO>Simple</OO><OPERATOR>-&gt;</OPERATOR><OO>new</OO>(RootName<OPERATOR>=&gt;</OPERATOR><STRING>'sclc'</STRING>)<OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>%fileHash</VARIABLE> <OPERATOR>=</OPERATOR> ()<OPERATOR>;</OPERATOR>
    <VARIABLE>$fileHash</VARIABLE>{<STRING>'file'</STRING>} <OPERATOR>=</OPERATOR> <OPERATOR>\</OPERATOR><VARIABLE>@fileElementArray</VARIABLE><OPERATOR>;</OPERATOR>
    <KEYWORD>my</KEYWORD> <VARIABLE>%sclcHash</VARIABLE> <OPERATOR>=</OPERATOR> ()<OPERATOR>;</OPERATOR>
    <VARIABLE>$sclcHash</VARIABLE>{<STRING>'sclc'</STRING>} <OPERATOR>=</OPERATOR> <OPERATOR>\%</OPERATOR>fileHash<OPERATOR>;</OPERATOR>
    <VARIABLE>$xml</VARIABLE><OPERATOR>-&gt;</OPERATOR><OO>XMLout</OO>(<OPERATOR>\%</OPERATOR>sclcHash<OPERATOR>,</OPERATOR> OutputFile<OPERATOR>=&gt;</OPERATOR><VARIABLE>$OPTS</VARIABLE>{<STRING>'xml_output'</STRING>}<OPERATOR>,</OPERATOR> KeepRoot<OPERATOR>=&gt;</OPERATOR><NUMERIC>1</NUMERIC><OPERATOR>,</OPERATOR> XMLDecl<OPERATOR>=&gt;</OPERATOR><STRING>"&lt;?xml version='1.0'?&gt;"</STRING>)<OPERATOR>;</OPERATOR>
}

<COMMENT># The following is a KLUGE to distinguish C++ from C</COMMENT>
<COMMENT># Return 1 if the line of code has C++-specific content, else false</COMMENT>
<KEYWORD>sub</KEYWORD> IsCeePlusPlus {
    <KEYWORD>local</KEYWORD>(<VARIABLE>$_</VARIABLE>) <OPERATOR>=</OPERATOR> <FUNCTION>shift</FUNCTION><OPERATOR>;</OPERATOR>
    <KEYWORD>return</KEYWORD> <DELIMITER>m/</DELIMITER><REGEX>(?: ^\s*</REGEX>
<REGEX>          (?: \:\:\s*\w |</REGEX>
<REGEX>           (?: class |</REGEX>
<REGEX>        public \s* : |</REGEX>
<REGEX>        private \s* : |</REGEX>
<REGEX>        protected \s* : |</REGEX>
<REGEX>        template \s* &lt; | </REGEX>
<REGEX>        virtual | </REGEX>
<REGEX>        throw \s* [\(;] |</REGEX>
<REGEX>        try \s* [{}] |</REGEX>
<REGEX>        catch \s* \( |</REGEX>
<REGEX>        dynamic_cast</REGEX>
<REGEX>        )</REGEX>
<REGEX>           )</REGEX>
<REGEX>          \b) |</REGEX>
<REGEX>          (?: ^[^\/\"\']*</REGEX>
<REGEX>           (?: \b</REGEX>
<REGEX>        (?: throw \s* [\(;] |</REGEX>
<REGEX>         try \s* [{}] |</REGEX>
<REGEX>         catch \s* \( |</REGEX>
<REGEX>         dynamic_cast</REGEX>
<REGEX>         )\b |</REGEX>
<REGEX>        \:\:</REGEX>
<REGEX>        )</REGEX>
<REGEX>)</REGEX><DELIMITER>/</DELIMITER><KEYWORD>x</KEYWORD><OPERATOR>;</OPERATOR>

}

<COMMENT>#---------------------------------------------------------------------</COMMENT>
<KEYWORD>package</KEYWORD> main<OPERATOR>;</OPERATOR>

<KEYWORD>use</KEYWORD> <OBJ>XML</OBJ><OPERATOR>::</OPERATOR><OO>Simple</OO><OPERATOR>;</OPERATOR>

<KEYWORD>my</KEYWORD> <VARIABLE>$DO_NOT_EXECUTE</VARIABLE> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>

<KEYWORD>if</KEYWORD> (<OPERATOR>&amp;</OPERATOR><OBJ>Sclc</OBJ><OPERATOR>::</OPERATOR><OO>UnitTestsAreRunning</OO>()) {
    <VARIABLE>$DO_NOT_EXECUTE</VARIABLE> <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC><OPERATOR>;</OPERATOR>
}

<OBJ>Sclc</OBJ><OPERATOR>::</OPERATOR><OO>main</OO>(<VARIABLE>@ARGV</VARIABLE>) <KEYWORD>unless</KEYWORD> (<VARIABLE>$DO_NOT_EXECUTE</VARIABLE>)<OPERATOR>;</OPERATOR>