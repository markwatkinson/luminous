<COMMENT>/**************************************************************</COMMENT>
<COMMENT>  JLex: A Lexical Analyzer Generator for Java(TM)</COMMENT>
<COMMENT>  Written by Elliot Berk &lt;ejberk@cs.princeton.edu&gt;. Copyright 1996.</COMMENT>
<COMMENT>  Maintained by C. Scott Ananian &lt;cananian@alumni.princeton.edu&gt;.</COMMENT>
<COMMENT>  See below for copyright notice, license, and disclaimer.</COMMENT>
<COMMENT>  New releases from http://www.cs.princeton.edu/~appel/modern/java/JLex/</COMMENT>
<COMMENT></COMMENT>
<COMMENT>  Version 1.2.6, 2/7/03, [C. Scott Ananian]</COMMENT>
<COMMENT>   Renamed 'assert' function 'ASSERT' to accomodate Java 1.4's new keyword.</COMMENT>
<COMMENT>   Fixed a bug which certain forms of comment in the JLex directives section</COMMENT>
<COMMENT>     (which are not allowed) to be incorrectly parsed as macro definitions.</COMMENT>
<COMMENT>  Version 1.2.5, 7/25/99-5/16/00, [C. Scott Ananian]</COMMENT>
<COMMENT>   Stomped on one more 8-bit character bug.  Should work now (really!).</COMMENT>
<COMMENT>   Added unicode support, including unicode escape sequences.</COMMENT>
<COMMENT>   Rewrote internal JavaLexBitSet class as SparseBitSet for efficient</COMMENT>
<COMMENT>     unicoding.</COMMENT>
<COMMENT>   Added an NFA character class simplification pass for unicode efficiency.</COMMENT>
<COMMENT>   Changed byte- and stream-oriented I/O routines to use characters and</COMMENT>
<COMMENT>     java.io.Reader and java.io.Writer instead --- which means we read in</COMMENT>
<COMMENT>     unicode specifications correctly and write out a proper unicode java</COMMENT>
<COMMENT>     source file.  As a happy side-effect, the output java file is written</COMMENT>
<COMMENT>     with your platform's preferred newline character(s).</COMMENT>
<COMMENT>   Rewrote CInput to fix bugs with line-counting in the specification file</COMMENT>
<COMMENT>     and "unusual behaviour" when the last line of the specification wasn't</COMMENT>
<COMMENT>     terminated with a newline. Thanks to Matt Hanna &lt;mhanna@cs.caltech.edu&gt;</COMMENT>
<COMMENT>     for pointing out the bug.</COMMENT>
<COMMENT>   Fixed a bug that would cause JLex not to terminate given certain input</COMMENT>
<COMMENT>     specifications.  Thanks to Mark Greenstreet &lt;mrg@cs.ubc.ca&gt; and</COMMENT>
<COMMENT>     Frank B. Brokken &lt;frank@suffix.icce.rug.nl&gt; for reporting this.</COMMENT>
<COMMENT>   CUP parser integration improved according to suggestions made by</COMMENT>
<COMMENT>     David MacMahon &lt;davidm@smartsc.com&gt;.  The %cup directive now tells</COMMENT>
<COMMENT>     JLex to generate a parser conforming to the java_cup.runtime.Scanner</COMMENT>
<COMMENT>     interface; see manual for more details.</COMMENT>
<COMMENT>   Fixed bug with null string literals ("") in regexps.  Reported by</COMMENT>
<COMMENT>     Charles Fischer &lt;fischer@cs.wisc.edu&gt;.</COMMENT>
<COMMENT>   Rewrote start-of-line and end-of-line handling, closing active bug #5.</COMMENT>
<COMMENT>     Also fixed line-counting code, closing active bug #12.  All</COMMENT>
<COMMENT>     new-line handling is now platform-independent.</COMMENT>
<COMMENT>   Used unpackFromString more extensively to allow larger cmap, etc,</COMMENT>
<COMMENT>     tables.  This helps unicode support work reliably.  It's also</COMMENT>
<COMMENT>     prettier now if you happen to read the source to the generated</COMMENT>
<COMMENT>     lexer.</COMMENT>
<COMMENT>   Generated lexer now accepts unicode LS (U+2028) and PS (U+2029) as</COMMENT>
<COMMENT>     line separators for strict unicode compliance; see</COMMENT>
<COMMENT>     http://www.unicode.org/unicode/reports/tr18/</COMMENT>
<COMMENT>   Fixed bug with character constants in action strings.  Reported by</COMMENT>
<COMMENT>     Andrew Appel against 1.2.5b3.</COMMENT>
<COMMENT>   Fixed bug with illegal \^C-style escape sequences.  Reported by</COMMENT>
<COMMENT>     Toshiya Iwai &lt;iwai@isdnet.co.jp&gt; against 1.2.5b4.</COMMENT>
<COMMENT>   Fixed "newline in quoted string" error when unpaired single- or</COMMENT>
<COMMENT>     double-quotes were present in comments in the action phrase.</COMMENT>
<COMMENT>     Reported by Stephen Ostermiller &lt;1010JLex@ostermiller.com&gt;</COMMENT>
<COMMENT>     against 1.2.5b4.  Reported by Eric Esposito &lt;eric.esposito@unh.edu&gt;</COMMENT>
<COMMENT>     against 1.2.4 and 1.2.5b2.</COMMENT>
<COMMENT>   Fixed "newline in quoted string" error when /* or // appeared</COMMENT>
<COMMENT>     in quoted strings in the action phrase.  Reported by</COMMENT>
<COMMENT>     David Eichmann &lt;david-eichmann@uiowa.edu&gt; against 1.2.5b5.</COMMENT>
<COMMENT>   Fixed 'illegal constant' errors in case statements caused by</COMMENT>
<COMMENT>     Sun's JDK 1.3 more closely adhering to the Java Language</COMMENT>
<COMMENT>     Specification.  Reported by a number of people, but</COMMENT>
<COMMENT>     Harold Grovesteen &lt;hgrovesteen@home.com&gt; was the first to direct me to</COMMENT>
<COMMENT>     a Sun bug report (4119776) which quoted the relevant section of the</COMMENT>
<COMMENT>     JLS (15.27) to convince me that the JLex construction actually was</COMMENT>
<COMMENT>     illegal.  Reported against 1.2.5b6, but this bit of code has been</COMMENT>
<COMMENT>     present since the very first version of JLex (1.1.1).</COMMENT>
<COMMENT></COMMENT>
<COMMENT>  Version 1.2.4, 7/24/99, [C. Scott Ananian]</COMMENT>
<COMMENT>   Correct the parsing of '-' in character classes, closing active</COMMENT>
<COMMENT>     bug #1.  Behaviour follows egrep: leading and trailing dashes in</COMMENT>
<COMMENT>     a character class lose their special meaning, so [-+] and [+-] do</COMMENT>
<COMMENT>     what you would expect them to.</COMMENT>
<COMMENT>   New %ignorecase directive for generating case-insensitive lexers by</COMMENT>
<COMMENT>     expanding matched character classes in a unicode-friendly way.</COMMENT>
<COMMENT>   Handle unmatched braces in quoted strings or comments within</COMMENT>
<COMMENT>     action code blocks.</COMMENT>
<COMMENT>   Fixed input lexer to allow whitespace in character classes, closing</COMMENT>
<COMMENT>     active bug #9.  Whitespace in quotes had been previously fixed.</COMMENT>
<COMMENT>   Made Yylex.YYEOF and %yyeof work like the manual says they should.</COMMENT>
<COMMENT></COMMENT>
<COMMENT>  Version 1.2.3, 6/26/97, [Raimondas Lencevicius]</COMMENT>
<COMMENT>   Fixed the yy_nxt[][] assignment that has generated huge code</COMMENT>
<COMMENT>   exceeding 64K method size limit. Now the assignment</COMMENT>
<COMMENT>   is handled by unpacking a string encoding of integer array.</COMMENT>
<COMMENT>   To achieve that, added</COMMENT>
<COMMENT>   "private int [][] unpackFromString(int size1, int size2, String st)"</COMMENT>
<COMMENT>   function and coded the yy_nxt[][] values into a string</COMMENT>
<COMMENT>   by printing integers into a string and representing</COMMENT>
<COMMENT>   integer sequences as "value:length" pairs.</COMMENT>
<COMMENT>   Improvement: generated .java file reduced 2 times, .class file</COMMENT>
<COMMENT>     reduced 6 times for sample grammar. No 64K errors.</COMMENT>
<COMMENT>   Possible negatives: Some editors and OSs may not be able to handle</COMMENT>
<COMMENT>     the huge one-line generated string. String unpacking may be slower</COMMENT>
<COMMENT>     than direct array initialization.</COMMENT>
<COMMENT></COMMENT>
<COMMENT>  Version 1.2.2, 10/24/97, [Martin Dirichs]</COMMENT>
<COMMENT>  Notes:</COMMENT>
<COMMENT>    Changed yy_instream to yy_reader of type BufferedReader. This reflects</COMMENT>
<COMMENT>     the improvements in the JDK 1.1 concerning InputStreams. As a</COMMENT>
<COMMENT>     consequence, changed yy_buffer from byte[] to char[].</COMMENT>
<COMMENT>     The lexer can now be initialized with either an InputStream</COMMENT>
<COMMENT>     or a Reader. A third, private constructor is called by the other</COMMENT>
<COMMENT>     two to execute user specified constructor code.</COMMENT>
<COMMENT></COMMENT>
<COMMENT>  Version 1.2.1, 9/15/97 [A. Appel]</COMMENT>
<COMMENT>   Fixed bugs 6 (character codes &gt; 127) and 10 (deprecated String constructor).</COMMENT>
<COMMENT></COMMENT>
<COMMENT>  Version 1.2, 5/5/97, [Elliot Berk]</COMMENT>
<COMMENT>  Notes:</COMMENT>
<COMMENT>    Simply changed the name from JavaLex to JLex.  No other changes.</COMMENT>
<COMMENT></COMMENT>
<COMMENT>  Version 1.1.5, 2/25/97, [Elliot Berk]</COMMENT>
<COMMENT>  Notes:</COMMENT>
<COMMENT>    Simple optimization to the creation of the source files.</COMMENT>
<COMMENT>     Added a BufferedOutputStream in the creation of the DataOutputStream</COMMENT>
<COMMENT>     field m_outstream of the class CLexGen.  This helps performance by</COMMENT>
<COMMENT>     doing some buffering, and was suggested by Max Hailperin,</COMMENT>
<COMMENT>     Associate Professor of Computer Science, Gustavus Adolphus College.</COMMENT>
<COMMENT></COMMENT>
<COMMENT>  Version 1.1.4, 12/12/96, [Elliot Berk]</COMMENT>
<COMMENT>  Notes:</COMMENT>
<COMMENT>    Added %public directive to make generated class public.</COMMENT>
<COMMENT></COMMENT>
<COMMENT>  Version 1.1.3, 12/11/96, [Elliot Berk]</COMMENT>
<COMMENT>  Notes:</COMMENT>
<COMMENT>    Converted assertion failure on invalid character class</COMMENT>
<COMMENT>     when a dash '-' is not preceded with a start-of-range character.</COMMENT>
<COMMENT>     Converted this into parse error E_DASH.</COMMENT>
<COMMENT></COMMENT>
<COMMENT>  Version 1.1.2, October 30, 1996 [Elliot Berk]</COMMENT>
<COMMENT>    Fixed BitSet bugs by installing a BitSet class of my own,</COMMENT>
<COMMENT>     called JavaLexBitSet.  Fixed support for '\r', non-UNIX</COMMENT>
<COMMENT>     sequences.  Added try/catch block around lexer generation</COMMENT>
<COMMENT>     in main routine to moderate error information presented</COMMENT>
<COMMENT>     to user.  Fixed macro expansion, so that macros following</COMMENT>
<COMMENT>     quotes are expanded correctly in regular expressions.</COMMENT>
<COMMENT>     Fixed dynamic reallocation of accept action buffers.</COMMENT>
<COMMENT></COMMENT>
<COMMENT>  Version 1.1.1, September 3, 1996 [Andrew Appel]</COMMENT>
<COMMENT>    Made the class "Main" instead of "JavaLex",</COMMENT>
<COMMENT>     improved the installation instructions to reflect this.</COMMENT>
<COMMENT></COMMENT>
<COMMENT>  Version 1.1, August 15, 1996  [Andrew Appel]</COMMENT>
<COMMENT>    Made yychar, yyline, yytext global to the lexer so that</COMMENT>
<COMMENT>     auxiliary functions can access them.</COMMENT>
<COMMENT>  **************************************************************/</COMMENT>

<COMMENT>/***************************************************************</COMMENT>
<COMMENT>       JLEX COPYRIGHT NOTICE, LICENSE, AND DISCLAIMER</COMMENT>
<COMMENT>  Copyright 1996-2000 by Elliot Joel Berk and C. Scott Ananian</COMMENT>
<COMMENT></COMMENT>
<COMMENT>  Permission to use, copy, modify, and distribute this software and its</COMMENT>
<COMMENT>  documentation for any purpose and without fee is hereby granted,</COMMENT>
<COMMENT>  provided that the above copyright notice appear in all copies and that</COMMENT>
<COMMENT>  both the copyright notice and this permission notice and warranty</COMMENT>
<COMMENT>  disclaimer appear in supporting documentation, and that the name of</COMMENT>
<COMMENT>  the authors or their employers not be used in advertising or publicity</COMMENT>
<COMMENT>  pertaining to distribution of the software without specific, written</COMMENT>
<COMMENT>  prior permission.</COMMENT>
<COMMENT></COMMENT>
<COMMENT>  The authors and their employers disclaim all warranties with regard to</COMMENT>
<COMMENT>  this software, including all implied warranties of merchantability and</COMMENT>
<COMMENT>  fitness. In no event shall the authors or their employers be liable</COMMENT>
<COMMENT>  for any special, indirect or consequential damages or any damages</COMMENT>
<COMMENT>  whatsoever resulting from loss of use, data or profits, whether in an</COMMENT>
<COMMENT>  action of contract, negligence or other tortious action, arising out</COMMENT>
<COMMENT>  of or in connection with the use or performance of this software.</COMMENT>
<COMMENT>  **************************************************************/</COMMENT>

<COMMENT>/***************************************************************</COMMENT>
<COMMENT>  Package Declaration</COMMENT>
<COMMENT>  **************************************************************/</COMMENT>
<KEYWORD>package</KEYWORD> JLex;

<COMMENT>/***************************************************************</COMMENT>
<COMMENT>  Imported Packages</COMMENT>
<COMMENT>  **************************************************************/</COMMENT>
<KEYWORD>import</KEYWORD> <OBJ>java</OBJ>.<OO>lang</OO>.<OO>System</OO>;
<KEYWORD>import</KEYWORD> <OBJ>java</OBJ>.<OO>lang</OO>.<OO>Integer</OO>;
<KEYWORD>import</KEYWORD> <OBJ>java</OBJ>.<OO>lang</OO>.<OO>Character</OO>;

<KEYWORD>import</KEYWORD> <OBJ>java</OBJ>.<OO>util</OO>.<OO>Enumeration</OO>;
<KEYWORD>import</KEYWORD> <OBJ>java</OBJ>.<OO>util</OO>.<OO>Stack</OO>;
<KEYWORD>import</KEYWORD> <OBJ>java</OBJ>.<OO>util</OO>.<OO>Hashtable</OO>;
<KEYWORD>import</KEYWORD> <OBJ>java</OBJ>.<OO>util</OO>.<OO>Vector</OO>;

<COMMENT>/******************************</COMMENT>
<COMMENT>  Questions:</COMMENT>
<COMMENT>  2) How should I use the Java package system</COMMENT>
<COMMENT>  to make my tool more modularized and</COMMENT>
<COMMENT>  coherent?</COMMENT>
<COMMENT></COMMENT>
<COMMENT>  Unimplemented:</COMMENT>
<COMMENT>  !) Fix BitSet issues -- expand only when necessary.</COMMENT>
<COMMENT>  2) Repeated accept rules.</COMMENT>
<COMMENT>  6) Clean up the CAlloc class and use buffered</COMMENT>
<COMMENT>  allocation.</COMMENT>
<COMMENT>  9) Add to spec about extending character set.</COMMENT>
<COMMENT>  11) m_verbose -- what should be done with it?</COMMENT>
<COMMENT>  12) turn lexical analyzer into a coherent</COMMENT>
<COMMENT>  Java package</COMMENT>
<COMMENT>  13) turn lexical analyzer generator into a</COMMENT>
<COMMENT>  coherent Java package</COMMENT>
<COMMENT>  16) pretty up generated code</COMMENT>
<COMMENT>  17) make it possible to have white space in</COMMENT>
<COMMENT>  regular expressions</COMMENT>
<COMMENT>  18) clean up all of the class files the lexer</COMMENT>
<COMMENT>  generator produces when it is compiled,</COMMENT>
<COMMENT>  and reduce this number in some way.</COMMENT>
<COMMENT>  24) character format to and from file: writeup</COMMENT>
<COMMENT>  and implementation</COMMENT>
<COMMENT>  25) Debug by testing all arcane regular expression cases.</COMMENT>
<COMMENT>  26) Look for and fix all UNDONE comments below.</COMMENT>
<COMMENT>  27) Fix package system.</COMMENT>
<COMMENT>  28) Clean up unnecessary classes.</COMMENT>
<COMMENT>  *****************************/</COMMENT>

<COMMENT>/***************************************************************</COMMENT>
<COMMENT>  Class: CSpec</COMMENT>
<COMMENT> **************************************************************/</COMMENT>
<KEYWORD>class</KEYWORD> CSpec
{
  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Member Variables</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>

  <COMMENT>/* Lexical States. */</COMMENT>
  <TYPE>Hashtable</TYPE> m_states; <COMMENT>/* Hashtable taking state indices (Integer)</COMMENT>
<COMMENT>                         to state name (String). */</COMMENT>

  <COMMENT>/* Regular Expression Macros. */</COMMENT>
  <TYPE>Hashtable</TYPE> m_macros; <COMMENT>/* Hashtable taking macro name (String)</COMMENT>
<COMMENT>                                to corresponding char buffer that</COMMENT>
<COMMENT>                                holds macro definition. */</COMMENT>

  <COMMENT>/* NFA Machine. */</COMMENT>
  CNfa m_nfa_start; <COMMENT>/* Start state of NFA machine. */</COMMENT>
  <TYPE>Vector</TYPE> m_nfa_states; <COMMENT>/* Vector of states, with index</COMMENT>
<COMMENT>                                 corresponding to label. */</COMMENT>

  <TYPE>Vector</TYPE> m_state_rules[]; <COMMENT>/* An array of Vectors of Integers.</COMMENT>
<COMMENT>                                    The ith Vector represents the lexical state</COMMENT>
<COMMENT>                                    with index i.  The contents of the ith</COMMENT>
<COMMENT>                                    Vector are the indices of the NFA start</COMMENT>
<COMMENT>                                    states that can be matched while in</COMMENT>
<COMMENT>                                    the ith lexical state. */</COMMENT>


  <TYPE>int</TYPE> m_state_dtrans[];

  <COMMENT>/* DFA Machine. */</COMMENT>
  <TYPE>Vector</TYPE> m_dfa_states; <COMMENT>/* Vector of states, with index</COMMENT>
<COMMENT>                                 corresponding to label. */</COMMENT>
  <TYPE>Hashtable</TYPE> m_dfa_sets; <COMMENT>/* Hashtable taking set of NFA states</COMMENT>
<COMMENT>                                  to corresponding DFA state,</COMMENT>
<COMMENT>                                  if the latter exists. */</COMMENT>

  <COMMENT>/* Accept States and Corresponding Anchors. */</COMMENT>
  <TYPE>Vector</TYPE> m_accept_vector;
  <TYPE>int</TYPE> m_anchor_array[];

  <COMMENT>/* Transition Table. */</COMMENT>
  <TYPE>Vector</TYPE> m_dtrans_vector;
  <TYPE>int</TYPE> m_dtrans_ncols;
  <TYPE>int</TYPE> m_row_map[];
  <TYPE>int</TYPE> m_col_map[];

  <COMMENT>/* Special pseudo-characters for beginning-of-line and end-of-file. */</COMMENT>
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>NUM_PSEUDO</CONSTANT><OPERATOR>=</OPERATOR><NUMERIC>2</NUMERIC>;
  <TYPE>int</TYPE> BOL; <COMMENT>// beginning-of-line</COMMENT>
  <TYPE>int</TYPE> EOF; <COMMENT>// end-of-line</COMMENT>

  <DOCCOMMENT>/** NFA character class minimization map. */</DOCCOMMENT>
  <TYPE>int</TYPE> m_ccls_map[];

  <COMMENT>/* Regular expression token variables. */</COMMENT>
  <TYPE>int</TYPE> m_current_token;
  <TYPE>char</TYPE> m_lexeme;
  <TYPE>boolean</TYPE> m_in_quote;
  <TYPE>boolean</TYPE> m_in_ccl;

  <COMMENT>/* Verbose execution flag. */</COMMENT>
  <TYPE>boolean</TYPE> m_verbose;

  <COMMENT>/* JLex directives flags. */</COMMENT>
  <TYPE>boolean</TYPE> m_integer_type;
  <TYPE>boolean</TYPE> m_intwrap_type;
  <TYPE>boolean</TYPE> m_yyeof;
  <TYPE>boolean</TYPE> m_count_chars;
  <TYPE>boolean</TYPE> m_count_lines;
  <TYPE>boolean</TYPE> m_cup_compatible;
  <TYPE>boolean</TYPE> m_unix;
  <TYPE>boolean</TYPE> m_public;
  <TYPE>boolean</TYPE> m_ignorecase;

  <TYPE>char</TYPE> m_init_code[];
  <TYPE>int</TYPE> m_init_read;

  <TYPE>char</TYPE> m_init_throw_code[];
  <TYPE>int</TYPE> m_init_throw_read;

  <TYPE>char</TYPE> m_class_code[];
  <TYPE>int</TYPE> m_class_read;

  <TYPE>char</TYPE> m_eof_code[];
  <TYPE>int</TYPE> m_eof_read;

  <TYPE>char</TYPE> m_eof_value_code[];
  <TYPE>int</TYPE> m_eof_value_read;

  <TYPE>char</TYPE> m_eof_throw_code[];
  <TYPE>int</TYPE> m_eof_throw_read;

  <TYPE>char</TYPE> m_yylex_throw_code[];
  <TYPE>int</TYPE> m_yylex_throw_read;

  <COMMENT>/* Class, function, type names. */</COMMENT>
  <TYPE>char</TYPE> m_class_name[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'Y'</CHARACTER>, <CHARACTER>'y'</CHARACTER>, <CHARACTER>'l'</CHARACTER>,
    <CHARACTER>'e'</CHARACTER>, <CHARACTER>'x'</CHARACTER>
    };
  <TYPE>char</TYPE> m_implements_name[] <OPERATOR>=</OPERATOR> {};
  <TYPE>char</TYPE> m_function_name[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'y'</CHARACTER>, <CHARACTER>'y'</CHARACTER>, <CHARACTER>'l'</CHARACTER>,
    <CHARACTER>'e'</CHARACTER>, <CHARACTER>'x'</CHARACTER>
    };
  <TYPE>char</TYPE> m_type_name[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'Y'</CHARACTER>, <CHARACTER>'y'</CHARACTER>, <CHARACTER>'t'</CHARACTER>,
    <CHARACTER>'o'</CHARACTER>, <CHARACTER>'k'</CHARACTER>, <CHARACTER>'e'</CHARACTER>,
    <CHARACTER>'n'</CHARACTER>
    };

  <COMMENT>/* Lexical Generator. */</COMMENT>
  <KEYWORD>private</KEYWORD> CLexGen m_lexGen;

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Constants</COMMENT>
<COMMENT>    ***********************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>NONE</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>START</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> END <OPERATOR>=</OPERATOR> <NUMERIC>2</NUMERIC>;

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: CSpec</COMMENT>
<COMMENT>    Description: Constructor.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  CSpec
    (
     CLexGen lexGen
     )
      {
        m_lexGen <OPERATOR>=</OPERATOR> lexGen;

        <COMMENT>/* Initialize regular expression token variables. */</COMMENT>
        m_current_token <OPERATOR>=</OPERATOR> <OBJ>m_lexGen</OBJ>.<OO>EOS</OO>;
        m_lexeme <OPERATOR>=</OPERATOR> <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>;
        m_in_quote <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
        m_in_ccl <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;

        <COMMENT>/* Initialize hashtable for lexer states. */</COMMENT>
        m_states <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Hashtable</TYPE>();
        <OBJ>m_states</OBJ>.<OO>put</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<STRING>"YYINITIAL"</STRING>),<KEYWORD>new</KEYWORD> <TYPE>Integer</TYPE>(<OBJ>m_states</OBJ>.<OO>size</OO>()));

        <COMMENT>/* Initialize hashtable for lexical macros. */</COMMENT>
        m_macros <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Hashtable</TYPE>();

        <COMMENT>/* Initialize variables for lexer options. */</COMMENT>
        m_integer_type <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
        m_intwrap_type <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
        m_count_lines <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
        m_count_chars <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
        m_cup_compatible <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
        m_unix <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
        m_public <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
        m_yyeof <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
        m_ignorecase <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;

        <COMMENT>/* Initialize variables for JLex runtime options. */</COMMENT>
        m_verbose <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;

        m_nfa_start <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_nfa_states <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Vector</TYPE>();

        m_dfa_states <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Vector</TYPE>();
        m_dfa_sets <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Hashtable</TYPE>();

        m_dtrans_vector <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Vector</TYPE>();
        m_dtrans_ncols <OPERATOR>=</OPERATOR> <OBJ>CUtility</OBJ>.<OO>MAX_SEVEN_BIT</OO> <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>;
        m_row_map <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_col_map <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;

        m_accept_vector <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_anchor_array <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;

        m_init_code <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_init_read <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;

        m_init_throw_code <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_init_throw_read <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;

        m_yylex_throw_code <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_yylex_throw_read <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;

        m_class_code <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_class_read <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;

        m_eof_code <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_eof_read <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;

        m_eof_value_code <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_eof_value_read <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;

        m_eof_throw_code <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_eof_throw_read <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;

        m_state_dtrans <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;

        m_state_rules <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
      }
}

<COMMENT>/***************************************************************</COMMENT>
<COMMENT>  Class: CEmit</COMMENT>
<COMMENT>  **************************************************************/</COMMENT>
<KEYWORD>class</KEYWORD> CEmit
{
  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Member Variables</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> CSpec m_spec;
  <KEYWORD>private</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>PrintWriter</OO> m_outstream;

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Constants: Anchor Types</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>START</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC>;
  <KEYWORD>private</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> END <OPERATOR>=</OPERATOR> <NUMERIC>2</NUMERIC>;
  <KEYWORD>private</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>NONE</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>4</NUMERIC>;

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Constants</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>boolean</TYPE> <CONSTANT>EDBG</CONSTANT> <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
  <KEYWORD>private</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>boolean</TYPE> <CONSTANT>NOT_EDBG</CONSTANT> <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: CEmit</COMMENT>
<COMMENT>    Description: Constructor.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  CEmit
    (
     )
      {
        reset();
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: reset</COMMENT>
<COMMENT>    Description: Clears member variables.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> reset
    (
     )
      {
        m_spec <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_outstream <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: set</COMMENT>
<COMMENT>    Description: Initializes member variables.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> set
    (
     CSpec spec,
     <OBJ>java</OBJ>.<OO>io</OO>.<OO>PrintWriter</OO> outstream
     )
      {
        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> spec);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> outstream);
          }

        m_spec <OPERATOR>=</OPERATOR> spec;
        m_outstream <OPERATOR>=</OPERATOR> outstream;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: emit_imports</COMMENT>
<COMMENT>    Description: Emits import packages at top of</COMMENT>
<COMMENT>    generated source file.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <COMMENT>/*void emit_imports</COMMENT>
<COMMENT>    (</COMMENT>
<COMMENT>     CSpec spec,</COMMENT>
<COMMENT>     OutputStream outstream</COMMENT>
<COMMENT>     )</COMMENT>
<COMMENT>      throws java.io.IOException</COMMENT>
<COMMENT>        {</COMMENT>
<COMMENT>          set(spec,outstream);</COMMENT>
<COMMENT></COMMENT>
<COMMENT>          if (CUtility.DEBUG)</COMMENT>
<COMMENT>            {</COMMENT>
<COMMENT>              CUtility.ASSERT(null != m_spec);</COMMENT>
<COMMENT>              CUtility.ASSERT(null != m_outstream);</COMMENT>
<COMMENT>            }*/</COMMENT>

          <COMMENT>/*m_outstream.println("import java.lang.String;");</COMMENT>
<COMMENT>          m_outstream.println("import java.lang.System;");</COMMENT>
<COMMENT>          m_outstream.println("import java.io.BufferedReader;");</COMMENT>
<COMMENT>          m_outstream.println("import java.io.InputStream;");*/</COMMENT>
        <COMMENT>/*</COMMENT>
<COMMENT>          reset();</COMMENT>
<COMMENT>        }*/</COMMENT>

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: print_details</COMMENT>
<COMMENT>    Description: Debugging output.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> print_details
    (
     )
      {
        <TYPE>int</TYPE> i;
        <TYPE>int</TYPE> j;
        <TYPE>int</TYPE> next;
        <TYPE>int</TYPE> state;
        CDTrans dtrans;
        CAccept accept;
        <TYPE>boolean</TYPE> tr;

        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"---------------------- Transition Table "</STRING>
                           <OPERATOR>+</OPERATOR> <STRING>"----------------------"</STRING>);

        <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_row_map</OO>.<OO>length</OO>; <OPERATOR>++</OPERATOR>i)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>"State "</STRING> <OPERATOR>+</OPERATOR> i);

            accept <OPERATOR>=</OPERATOR> (CAccept) <OBJ>m_spec</OBJ>.<OO>m_accept_vector</OO>.<OO>elementAt</OO>(i);
            <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>==</OPERATOR> accept)
              {
                <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>" [nonaccepting]"</STRING>);
              }
            <KEYWORD>else</KEYWORD>
              {
                <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>" [accepting, line "</STRING>
                                 <OPERATOR>+</OPERATOR> <OBJ>accept</OBJ>.<OO>m_line_number</OO>
                                 <OPERATOR>+</OPERATOR> <STRING>" &lt;"</STRING>
                                 <OPERATOR>+</OPERATOR> (<KEYWORD>new</KEYWORD> <OBJ>java</OBJ>.<OO>lang</OO>.<OO>String</OO>(<OBJ>accept</OBJ>.<OO>m_action</OO>,<NUMERIC>0</NUMERIC>,
                                               <OBJ>accept</OBJ>.<OO>m_action_read</OO>))
                                 <OPERATOR>+</OPERATOR> <STRING>"&gt;]"</STRING>);
              }
            dtrans <OPERATOR>=</OPERATOR> (CDTrans) <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>elementAt</OO>(<OBJ>m_spec</OBJ>.<OO>m_row_map</OO>[i]);

            tr <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
            state <OPERATOR>=</OPERATOR> <OBJ>dtrans</OBJ>.<OO>m_dtrans</OO>[<OBJ>m_spec</OBJ>.<OO>m_col_map</OO>[<NUMERIC>0</NUMERIC>]];
            <KEYWORD>if</KEYWORD> (<OBJ>CDTrans</OBJ>.<OO>F</OO> <OPERATOR>!=</OPERATOR> state)
              {
                tr <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
                <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>"<ESC>\t</ESC>goto "</STRING> <OPERATOR>+</OPERATOR> state <OPERATOR>+</OPERATOR> <STRING>" on ["</STRING> <OPERATOR>+</OPERATOR> ((<TYPE>char</TYPE>) <NUMERIC>0</NUMERIC>));
              }
            <KEYWORD>for</KEYWORD> (j <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC>; j <OPERATOR>&lt;</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dtrans_ncols</OO>; <OPERATOR>++</OPERATOR>j)
              {
                next <OPERATOR>=</OPERATOR> <OBJ>dtrans</OBJ>.<OO>m_dtrans</OO>[<OBJ>m_spec</OBJ>.<OO>m_col_map</OO>[j]];
                <KEYWORD>if</KEYWORD> (state <OPERATOR>==</OPERATOR> next)
                  {
                    <KEYWORD>if</KEYWORD> (<OBJ>CDTrans</OBJ>.<OO>F</OO> <OPERATOR>!=</OPERATOR> state)
                      {
                        <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>((<TYPE>char</TYPE>) j);
                      }
                  }
                <KEYWORD>else</KEYWORD>
                  {
                    state <OPERATOR>=</OPERATOR> next;
                    <KEYWORD>if</KEYWORD> (tr)
                      {
                        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"]"</STRING>);
                        tr <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
                      }
                    <KEYWORD>if</KEYWORD> (<OBJ>CDTrans</OBJ>.<OO>F</OO> <OPERATOR>!=</OPERATOR> state)
                      {
                        tr <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
                        <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>"<ESC>\t</ESC>goto "</STRING> <OPERATOR>+</OPERATOR> state <OPERATOR>+</OPERATOR> <STRING>" on ["</STRING> <OPERATOR>+</OPERATOR> ((<TYPE>char</TYPE>) j));
                      }
                  }
              }
            <KEYWORD>if</KEYWORD> (tr)
              {
                <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"]"</STRING>);
              }
          }

        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"---------------------- Transition Table "</STRING>
                           <OPERATOR>+</OPERATOR> <STRING>"----------------------"</STRING>);
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: emit</COMMENT>
<COMMENT>    Description: High-level access function to module.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <TYPE>void</TYPE> emit
    (
     CSpec spec,
     <OBJ>java</OBJ>.<OO>io</OO>.<OO>PrintWriter</OO> outstream
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
        {
          set(spec,outstream);

          <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
            {
              <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_spec);
              <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_outstream);
            }

          <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>OLD_DEBUG</OO>) {
            print_details();
          }

          emit_header();
          emit_construct();
          emit_helpers();
          emit_driver();
          emit_footer();

          reset();
        }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: emit_construct</COMMENT>
<COMMENT>    Description: Emits constructor, member variables,</COMMENT>
<COMMENT>    and constants.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> emit_construct
    (
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
        {
          <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_spec);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_outstream);
          }

          <COMMENT>/* Constants */</COMMENT>
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private final int YY_BUFFER_SIZE = 512;"</STRING>);

          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private final int YY_F = -1;"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private final int YY_NO_STATE = -1;"</STRING>);

          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private final int YY_NOT_ACCEPT = 0;"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private final int YY_START = 1;"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private final int YY_END = 2;"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private final int YY_NO_ANCHOR = 4;"</STRING>);

          <COMMENT>// internal</COMMENT>
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private final int YY_BOL = "</STRING><OPERATOR>+</OPERATOR><OBJ>m_spec</OBJ>.<OO>BOL</OO><OPERATOR>+</OPERATOR><STRING>";"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private final int YY_EOF = "</STRING><OPERATOR>+</OPERATOR><OBJ>m_spec</OBJ>.<OO>EOF</OO><OPERATOR>+</OPERATOR><STRING>";"</STRING>);
          <COMMENT>// external</COMMENT>
          <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_integer_type</OO> <OPERATOR>||</OPERATOR> <KEYWORD>true</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_yyeof</OO>)
            <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>public final int YYEOF = -1;"</STRING>);

          <COMMENT>/* User specified class code. */</COMMENT>
          <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_class_code</OO>)
            {
              <OBJ>m_outstream</OBJ>.<OO>print</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_spec</OBJ>.<OO>m_class_code</OO>,<NUMERIC>0</NUMERIC>,
                                                <OBJ>m_spec</OBJ>.<OO>m_class_read</OO>));
            }

          <COMMENT>/* Member Variables */</COMMENT>
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private java.io.BufferedReader yy_reader;"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private int yy_buffer_index;"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private int yy_buffer_read;"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private int yy_buffer_start;"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private int yy_buffer_end;"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private char yy_buffer[];"</STRING>);
          <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_count_chars</OO>)
            {
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private int yychar;"</STRING>);
            }
          <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_count_lines</OO>)
            {
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private int yyline;"</STRING>);
            }
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private boolean yy_at_bol;"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private int yy_lexical_state;"</STRING>);
          <COMMENT>/*if (m_spec.m_count_lines || true == m_spec.m_count_chars)</COMMENT>
<COMMENT>            {</COMMENT>
<COMMENT>              m_outstream.println("\tprivate int yy_buffer_prev_start;");</COMMENT>
<COMMENT>            }*/</COMMENT>
          <OBJ>m_outstream</OBJ>.<OO>println</OO>();


          <COMMENT>/* Function: first constructor (Reader) */</COMMENT>
          <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"<ESC>\t</ESC>"</STRING>);
          <KEYWORD>if</KEYWORD> (<KEYWORD>true</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_public</OO>) {
            <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"public "</STRING>);
          }
          <OBJ>m_outstream</OBJ>.<OO>print</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_spec</OBJ>.<OO>m_class_name</OO>));
          <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>" (java.io.Reader reader)"</STRING>);

          <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_init_throw_code</OO>)
            {
              <OBJ>m_outstream</OBJ>.<OO>println</OO>();
              <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>throws "</STRING>);
              <OBJ>m_outstream</OBJ>.<OO>print</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_spec</OBJ>.<OO>m_init_throw_code</OO>,<NUMERIC>0</NUMERIC>,
                                                <OBJ>m_spec</OBJ>.<OO>m_init_throw_read</OO>));
              <OBJ>m_outstream</OBJ>.<OO>println</OO>();
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>{"</STRING>);
            }
          <KEYWORD>else</KEYWORD>
            {
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>" {"</STRING>);
            }

          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>this ();"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>if (null == reader) {"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>throw (new Error(<ESC>\"</ESC>Error: Bad input "</STRING>
                                 <OPERATOR>+</OPERATOR> <STRING>"stream initializer.<ESC>\"</ESC>));"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>yy_reader = new java.io.BufferedReader(reader);"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>}"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>();


          <COMMENT>/* Function: second constructor (InputStream) */</COMMENT>
          <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"<ESC>\t</ESC>"</STRING>);
          <KEYWORD>if</KEYWORD> (<KEYWORD>true</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_public</OO>) {
            <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"public "</STRING>);
          }
          <OBJ>m_outstream</OBJ>.<OO>print</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_spec</OBJ>.<OO>m_class_name</OO>));
          <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>" (java.io.InputStream instream)"</STRING>);

          <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_init_throw_code</OO>)
            {
              <OBJ>m_outstream</OBJ>.<OO>println</OO>();
              <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>throws "</STRING>);
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_spec</OBJ>.<OO>m_init_throw_code</OO>,<NUMERIC>0</NUMERIC>,
                                                <OBJ>m_spec</OBJ>.<OO>m_init_throw_read</OO>));
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>{"</STRING>);
            }
          <KEYWORD>else</KEYWORD>
            {
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>" {"</STRING>);
            }

          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>this ();"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>if (null == instream) {"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>throw (new Error(<ESC>\"</ESC>Error: Bad input "</STRING>
                                 <OPERATOR>+</OPERATOR> <STRING>"stream initializer.<ESC>\"</ESC>));"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>yy_reader = new java.io.BufferedReader(new java.io.InputStreamReader(instream));"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>}"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>();


          <COMMENT>/* Function: third, private constructor - only for internal use */</COMMENT>
          <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"<ESC>\t</ESC>private "</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>print</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_spec</OBJ>.<OO>m_class_name</OO>));
          <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>" ()"</STRING>);

          <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_init_throw_code</OO>)
            {
              <OBJ>m_outstream</OBJ>.<OO>println</OO>();
              <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>throws "</STRING>);
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_spec</OBJ>.<OO>m_init_throw_code</OO>,<NUMERIC>0</NUMERIC>,
                                                <OBJ>m_spec</OBJ>.<OO>m_init_throw_read</OO>));
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>{"</STRING>);
            }
          <KEYWORD>else</KEYWORD>
            {
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>" {"</STRING>);
            }

          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>yy_buffer = new char[YY_BUFFER_SIZE];"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>yy_buffer_read = 0;"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>yy_buffer_index = 0;"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>yy_buffer_start = 0;"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>yy_buffer_end = 0;"</STRING>);
          <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_count_chars</OO>)
            {
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>yychar = 0;"</STRING>);
            }
          <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_count_lines</OO>)
            {
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>yyline = 0;"</STRING>);
            }
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>yy_at_bol = true;"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>yy_lexical_state = YYINITIAL;"</STRING>);
          <COMMENT>/*if (m_spec.m_count_lines || true == m_spec.m_count_chars)</COMMENT>
<COMMENT>            {</COMMENT>
<COMMENT>              m_outstream.println("\t\tyy_buffer_prev_start = 0;");</COMMENT>
<COMMENT>            }*/</COMMENT>

          <COMMENT>/* User specified constructor code. */</COMMENT>
          <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_init_code</OO>)
            {
              <OBJ>m_outstream</OBJ>.<OO>print</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_spec</OBJ>.<OO>m_init_code</OO>,<NUMERIC>0</NUMERIC>,
                                                <OBJ>m_spec</OBJ>.<OO>m_init_read</OO>));
            }

          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>}"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>();

        }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: emit_states</COMMENT>
<COMMENT>    Description: Emits constants that serve as lexical states,</COMMENT>
<COMMENT>    including YYINITIAL.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> emit_states
    (
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
        {
          <TYPE>Enumeration</TYPE> states;
          <TYPE>String</TYPE> state;
          <TYPE>int</TYPE> index;

          states <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_states</OO>.<OO>keys</OO>();
          <COMMENT>/*index = 0;*/</COMMENT>
          <KEYWORD>while</KEYWORD> (<OBJ>states</OBJ>.<OO>hasMoreElements</OO>())
            {
              state <OPERATOR>=</OPERATOR> (<TYPE>String</TYPE>) <OBJ>states</OBJ>.<OO>nextElement</OO>();

              <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
                {
                  <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> state);
                }

              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private final int "</STRING>
                                     <OPERATOR>+</OPERATOR> state
                                     <OPERATOR>+</OPERATOR> <STRING>" = "</STRING>
                                     <OPERATOR>+</OPERATOR> (<OBJ>m_spec</OBJ>.<OO>m_states</OO>.<OO>get</OO>(state)).toString()
                                     <OPERATOR>+</OPERATOR> <STRING>";"</STRING>);
              <COMMENT>/*++index;*/</COMMENT>
            }

          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private final int yy_state_dtrans[] = {"</STRING>);
          <KEYWORD>for</KEYWORD> (index <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; index <OPERATOR>&lt;</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_state_dtrans</OO>.<OO>length</OO>; <OPERATOR>++</OPERATOR>index)
            {
              <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>"</STRING> <OPERATOR>+</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_state_dtrans</OO>[index]);
              <KEYWORD>if</KEYWORD> (index <OPERATOR>&lt;</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_state_dtrans</OO>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>)
                {
                  <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>","</STRING>);
                }
              <KEYWORD>else</KEYWORD>
                {
                  <OBJ>m_outstream</OBJ>.<OO>println</OO>();
                }
            }
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>};"</STRING>);
        }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: emit_helpers</COMMENT>
<COMMENT>    Description: Emits helper functions, particularly</COMMENT>
<COMMENT>    error handling and input buffering.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> emit_helpers
    (
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
      {
        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_spec);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_outstream);
          }

        <COMMENT>/* Function: yy_do_eof */</COMMENT>
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private boolean yy_eof_done = false;"</STRING>);
        <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_eof_code</OO>)
          {
            <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"<ESC>\t</ESC>private void yy_do_eof ()"</STRING>);

            <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_eof_throw_code</OO>)
              {
                <OBJ>m_outstream</OBJ>.<OO>println</OO>();
                <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>throws "</STRING>);
                <OBJ>m_outstream</OBJ>.<OO>println</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_spec</OBJ>.<OO>m_eof_throw_code</OO>,<NUMERIC>0</NUMERIC>,
                                                  <OBJ>m_spec</OBJ>.<OO>m_eof_throw_read</OO>));
                <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>{"</STRING>);
              }
            <KEYWORD>else</KEYWORD>
              {
                <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>" {"</STRING>);
              }

            <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>if (false == yy_eof_done) {"</STRING>);
            <OBJ>m_outstream</OBJ>.<OO>print</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_spec</OBJ>.<OO>m_eof_code</OO>,<NUMERIC>0</NUMERIC>,
                                              <OBJ>m_spec</OBJ>.<OO>m_eof_read</OO>));
            <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);
            <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>yy_eof_done = true;"</STRING>);
            <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>}"</STRING>);
          }

        emit_states();

        <COMMENT>/* Function: yybegin */</COMMENT>
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private void yybegin (int state) {"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>yy_lexical_state = state;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>}"</STRING>);

        <COMMENT>/* Function: yy_initial_dtrans */</COMMENT>
        <COMMENT>/*m_outstream.println("\tprivate int yy_initial_dtrans (int state) {");</COMMENT>
<COMMENT>        m_outstream.println("\t\treturn yy_state_dtrans[state];");</COMMENT>
<COMMENT>        m_outstream.println("\t}");*/</COMMENT>

        <COMMENT>/* Function: yy_advance */</COMMENT>
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private int yy_advance ()"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>throws java.io.IOException {"</STRING>);
        <COMMENT>/*m_outstream.println("\t\t{");*/</COMMENT>
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>int next_read;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>int i;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>int j;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>();

        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>if (yy_buffer_index &lt; yy_buffer_read) {"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>return yy_buffer[yy_buffer_index++];"</STRING>);
        <COMMENT>/*m_outstream.println("\t\t\t++yy_buffer_index;");*/</COMMENT>
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>();

        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>if (0 != yy_buffer_start) {"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>i = yy_buffer_start;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>j = 0;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>while (i &lt; yy_buffer_read) {"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_buffer[j] = yy_buffer[i];"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>++i;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>++j;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_buffer_end = yy_buffer_end - yy_buffer_start;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_buffer_start = 0;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_buffer_read = j;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_buffer_index = j;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>next_read = yy_reader.read(yy_buffer,"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_buffer_read,"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_buffer.length - yy_buffer_read);"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>if (-1 == next_read) {"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>return YY_EOF;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_buffer_read = yy_buffer_read + next_read;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>();

        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>while (yy_buffer_index &gt;= yy_buffer_read) {"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>if (yy_buffer_index &gt;= yy_buffer.length) {"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_buffer = yy_double(yy_buffer);"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>next_read = yy_reader.read(yy_buffer,"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_buffer_read,"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_buffer.length - yy_buffer_read);"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>if (-1 == next_read) {"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>return YY_EOF;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_buffer_read = yy_buffer_read + next_read;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);

        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>return yy_buffer[yy_buffer_index++];"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>}"</STRING>);

        <COMMENT>/* Function: yy_move_end */</COMMENT>
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private void yy_move_end () {"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>if (yy_buffer_end &gt; yy_buffer_start &amp;&amp;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>    '<ESC>\\</ESC>n' == yy_buffer[yy_buffer_end-1])"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_buffer_end--;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>if (yy_buffer_end &gt; yy_buffer_start &amp;&amp;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>    '<ESC>\\</ESC>r' == yy_buffer[yy_buffer_end-1])"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_buffer_end--;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>}"</STRING>);

        <COMMENT>/* Function: yy_mark_start */</COMMENT>
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private boolean yy_last_was_cr=false;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private void yy_mark_start () {"</STRING>);
        <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_count_lines</OO> <OPERATOR>||</OPERATOR> <KEYWORD>true</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_count_chars</OO>)
          {
            <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_count_lines</OO>)
              {
                <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>int i;"</STRING>);
                <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>for (i = yy_buffer_start; "</STRING>
                                       <OPERATOR>+</OPERATOR> <STRING>"i &lt; yy_buffer_index; ++i) {"</STRING>);
                <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>if ('<ESC>\\</ESC>n' == yy_buffer[i] &amp;&amp; !yy_last_was_cr) {"</STRING>);
                <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>++yyline;"</STRING>);
                <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);
                <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>if ('<ESC>\\</ESC>r' == yy_buffer[i]) {"</STRING>);
                <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>++yyline;"</STRING>);
                <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_last_was_cr=true;"</STRING>);
                <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>} else yy_last_was_cr=false;"</STRING>);
                <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);
              }
            <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_count_chars</OO>)
              {
                <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>yychar = yychar"</STRING>);
                <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>+ yy_buffer_index - yy_buffer_start;"</STRING>);
              }
          }
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>yy_buffer_start = yy_buffer_index;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>}"</STRING>);

        <COMMENT>/* Function: yy_mark_end */</COMMENT>
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private void yy_mark_end () {"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>yy_buffer_end = yy_buffer_index;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>}"</STRING>);

        <COMMENT>/* Function: yy_to_mark */</COMMENT>
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private void yy_to_mark () {"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>yy_buffer_index = yy_buffer_end;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>yy_at_bol = "</STRING><OPERATOR>+</OPERATOR>
                            <STRING>"(yy_buffer_end &gt; yy_buffer_start) &amp;&amp;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>            "</STRING><OPERATOR>+</OPERATOR>
                            <STRING>"('<ESC>\\</ESC>r' == yy_buffer[yy_buffer_end-1] ||"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>            "</STRING><OPERATOR>+</OPERATOR>
                            <STRING>" '<ESC>\\</ESC>n' == yy_buffer[yy_buffer_end-1] ||"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>            "</STRING><OPERATOR>+</OPERATOR> <COMMENT>/* unicode LS */</COMMENT>
                            <STRING>" 2028/*LS*/ == yy_buffer[yy_buffer_end-1] ||"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>            "</STRING><OPERATOR>+</OPERATOR> <COMMENT>/* unicode PS */</COMMENT>
                            <STRING>" 2029/*PS*/ == yy_buffer[yy_buffer_end-1]);"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>}"</STRING>);

        <COMMENT>/* Function: yytext */</COMMENT>
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private java.lang.String yytext () {"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>return (new java.lang.String(yy_buffer,"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_buffer_start,"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_buffer_end - yy_buffer_start));"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>}"</STRING>);

        <COMMENT>/* Function: yylength */</COMMENT>
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private int yylength () {"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>return yy_buffer_end - yy_buffer_start;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>}"</STRING>);

        <COMMENT>/* Function: yy_double */</COMMENT>
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private char[] yy_double (char buf[]) {"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>int i;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>char newbuf[];"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>newbuf = new char[2*buf.length];"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>for (i = 0; i &lt; buf.length; ++i) {"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>newbuf[i] = buf[i];"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>return newbuf;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>}"</STRING>);

        <COMMENT>/* Function: yy_error */</COMMENT>
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private final int YY_E_INTERNAL = 0;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private final int YY_E_MATCH = 1;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private java.lang.String yy_error_string[] = {"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\"</ESC>Error: Internal error.<ESC>\\</ESC>n<ESC>\"</ESC>,"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\"</ESC>Error: Unmatched input.<ESC>\\</ESC>n<ESC>\"</ESC>"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>};"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private void yy_error (int code,boolean fatal) {"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>java.lang.System.out.print(yy_error_string[code]);"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>java.lang.System.out.flush();"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>if (fatal) {"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>throw new Error(<ESC>\"</ESC>Fatal Error.<ESC>\\</ESC>n<ESC>\"</ESC>);"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>}"</STRING>);

        <COMMENT>/* Function: yy_next */</COMMENT>
        <COMMENT>/*m_outstream.println("\tprivate int yy_next (int current,char lookahead) {");</COMMENT>
<COMMENT>        m_outstream.println("\t\treturn yy_nxt[yy_rmap[current]][yy_cmap[lookahead]];");</COMMENT>
<COMMENT>        m_outstream.println("\t}");*/</COMMENT>

        <COMMENT>/* Function: yy_accept */</COMMENT>
        <COMMENT>/*m_outstream.println("\tprivate int yy_accept (int current) {");</COMMENT>
<COMMENT>        m_outstream.println("\t\treturn yy_acpt[current];");</COMMENT>
<COMMENT>        m_outstream.println("\t}");*/</COMMENT>


        <COMMENT>// Function: private int [][] unpackFromString(int size1, int size2, String st)</COMMENT>
        <COMMENT>// Added 6/24/98 Raimondas Lencevicius</COMMENT>
        <COMMENT>// May be made more efficient by replacing String operations</COMMENT>
        <COMMENT>// Assumes correctly formed input String. Performs no error checking</COMMENT>
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private int[][] unpackFromString"</STRING><OPERATOR>+</OPERATOR>
                            <STRING>"(int size1, int size2, String st) {"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>int colonIndex = -1;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>String lengthString;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>int sequenceLength = 0;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>int sequenceInteger = 0;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>();
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>int commaIndex;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>String workString;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>();
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>int res[][] = new int[size1][size2];"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>for (int i= 0; i &lt; size1; i++) {"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>for (int j= 0; j &lt; size2; j++) {"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>if (sequenceLength != 0) {"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>res[i][j] = sequenceInteger;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>sequenceLength--;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>continue;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>commaIndex = st.indexOf(',');"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>workString = (commaIndex==-1) ? st :"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>st.substring(0, commaIndex);"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>st = st.substring(commaIndex+1);"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>colonIndex = workString.indexOf(':');"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>if (colonIndex == -1) {"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>res[i][j]=Integer.parseInt(workString);"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>continue;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>lengthString ="</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>workString.substring(colonIndex+1);"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>sequenceLength="</STRING><OPERATOR>+</OPERATOR>
                            <STRING>"Integer.parseInt(lengthString);"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>workString="</STRING><OPERATOR>+</OPERATOR>
                            <STRING>"workString.substring(0,colonIndex);"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>sequenceInteger="</STRING><OPERATOR>+</OPERATOR>
                            <STRING>"Integer.parseInt(workString);"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>res[i][j] = sequenceInteger;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>sequenceLength--;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>return res;"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>}"</STRING>);
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: emit_header</COMMENT>
<COMMENT>    Description: Emits class header.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> emit_header
    (
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
      {
        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_spec);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_outstream);
          }

        <OBJ>m_outstream</OBJ>.<OO>println</OO>();
        <OBJ>m_outstream</OBJ>.<OO>println</OO>();
        <KEYWORD>if</KEYWORD> (<KEYWORD>true</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_public</OO>) {
          <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"public "</STRING>);
        }
        <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"class "</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>print</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_spec</OBJ>.<OO>m_class_name</OO>,<NUMERIC>0</NUMERIC>,
                                          <OBJ>m_spec</OBJ>.<OO>m_class_name</OO>.<OO>length</OO>));
        <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_implements_name</OO>.<OO>length</OO> <OPERATOR>&gt;</OPERATOR> <NUMERIC>0</NUMERIC>) {
           <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>" implements "</STRING>);
           <OBJ>m_outstream</OBJ>.<OO>print</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_spec</OBJ>.<OO>m_implements_name</OO>,<NUMERIC>0</NUMERIC>,
                                          <OBJ>m_spec</OBJ>.<OO>m_implements_name</OO>.<OO>length</OO>));
        }
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>" {"</STRING>);
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: emit_table</COMMENT>
<COMMENT>    Description: Emits transition table.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> emit_table
    (
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
      {
        <TYPE>int</TYPE> i;
        <TYPE>int</TYPE> elem;
        <TYPE>int</TYPE> size;
        CDTrans dtrans;
        <TYPE>boolean</TYPE> is_start;
        <TYPE>boolean</TYPE> is_end;
        CAccept accept;

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_spec);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_outstream);
          }

        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>private int yy_acpt[] = {"</STRING>);
        size <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_accept_vector</OO>.<OO>size</OO>();
        <KEYWORD>for</KEYWORD> (elem <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; elem <OPERATOR>&lt;</OPERATOR> size; <OPERATOR>++</OPERATOR>elem)
          {
            accept <OPERATOR>=</OPERATOR> (CAccept) <OBJ>m_spec</OBJ>.<OO>m_accept_vector</OO>.<OO>elementAt</OO>(elem);

            <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>/* "</STRING><OPERATOR>+</OPERATOR>elem<OPERATOR>+</OPERATOR><STRING>" */ "</STRING>);
            <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> accept)
              {
                is_start <OPERATOR>=</OPERATOR> (<NUMERIC>0</NUMERIC> <OPERATOR>!=</OPERATOR> (<OBJ>m_spec</OBJ>.<OO>m_anchor_array</OO>[elem] <OPERATOR>&amp;</OPERATOR> <OBJ>CSpec</OBJ>.<OO>START</OO>));
                is_end <OPERATOR>=</OPERATOR> (<NUMERIC>0</NUMERIC> <OPERATOR>!=</OPERATOR> (<OBJ>m_spec</OBJ>.<OO>m_anchor_array</OO>[elem] <OPERATOR>&amp;</OPERATOR> <OBJ>CSpec</OBJ>.<OO>END</OO>));

                <KEYWORD>if</KEYWORD> (is_start <OPERATOR>&amp;&amp;</OPERATOR> <KEYWORD>true</KEYWORD> <OPERATOR>==</OPERATOR> is_end)
                  {
                    <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"YY_START | YY_END"</STRING>);
                  }
                <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (is_start)
                  {
                    <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"YY_START"</STRING>);
                  }
                <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (is_end)
                  {
                    <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"YY_END"</STRING>);
                  }
                <KEYWORD>else</KEYWORD>
                  {
                    <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"YY_NO_ANCHOR"</STRING>);
                  }
              }
            <KEYWORD>else</KEYWORD>
              {
                <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"YY_NOT_ACCEPT"</STRING>);
              }

            <KEYWORD>if</KEYWORD> (elem <OPERATOR>&lt;</OPERATOR> size <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>)
              {
                <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>","</STRING>);
              }

            <OBJ>m_outstream</OBJ>.<OO>println</OO>();
          }
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>};"</STRING>);

        <COMMENT>// CSA: modified yy_cmap to use string packing 9-Aug-1999</COMMENT>
        <TYPE>int</TYPE>[] yy_cmap <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>int</TYPE>[<OBJ>m_spec</OBJ>.<OO>m_ccls_map</OO>.<OO>length</OO>];
        <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_ccls_map</OO>.<OO>length</OO>; <OPERATOR>++</OPERATOR>i)
            yy_cmap[i] <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_col_map</OO>[<OBJ>m_spec</OBJ>.<OO>m_ccls_map</OO>[i]];
        <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"<ESC>\t</ESC>private int yy_cmap[] = unpackFromString("</STRING>);
        emit_table_as_string(<KEYWORD>new</KEYWORD> <TYPE>int</TYPE>[][] { yy_cmap });
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>")[0];"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>();

        <COMMENT>// CSA: modified yy_rmap to use string packing 9-Aug-1999</COMMENT>
        <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"<ESC>\t</ESC>private int yy_rmap[] = unpackFromString("</STRING>);
        emit_table_as_string(<KEYWORD>new</KEYWORD> <TYPE>int</TYPE>[][] { <OBJ>m_spec</OBJ>.<OO>m_row_map</OO> });
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>")[0];"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>();

        <COMMENT>// 6/24/98 Raimondas Lencevicius</COMMENT>
        <COMMENT>// modified to use</COMMENT>
        <COMMENT>//    int[][] unpackFromString(int size1, int size2, String st)</COMMENT>
        size <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>size</OO>();
        <TYPE>int</TYPE>[][] yy_nxt <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>int</TYPE>[size][];
        <KEYWORD>for</KEYWORD> (elem<OPERATOR>=</OPERATOR><NUMERIC>0</NUMERIC>; elem<OPERATOR>&lt;</OPERATOR>size; elem<OPERATOR>++</OPERATOR>) {
            dtrans <OPERATOR>=</OPERATOR> (CDTrans) <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>elementAt</OO>(elem);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>dtrans</OBJ>.<OO>m_dtrans</OO>.<OO>length</OO><OPERATOR>==</OPERATOR><OBJ>m_spec</OBJ>.<OO>m_dtrans_ncols</OO>);
            yy_nxt[elem] <OPERATOR>=</OPERATOR> <OBJ>dtrans</OBJ>.<OO>m_dtrans</OO>;
        }
        <OBJ>m_outstream</OBJ>.<OO>print</OO>
          (<STRING>"<ESC>\t</ESC>private int yy_nxt[][] = unpackFromString("</STRING>);
        emit_table_as_string(yy_nxt);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>");"</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>();
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: emit_driver</COMMENT>
<COMMENT>    Description: Output an integer table as a string.  Written by</COMMENT>
<COMMENT>    Raimondas Lencevicius 6/24/98; reorganized by CSA 9-Aug-1999.</COMMENT>
<COMMENT>    From his original comments:</COMMENT>
<COMMENT>           yy_nxt[][] values are coded into a string</COMMENT>
<COMMENT>           by printing integers and representing</COMMENT>
<COMMENT>           integer sequences as "value:length" pairs.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> emit_table_as_string(<TYPE>int</TYPE>[][] ia) {
        <TYPE>int</TYPE> sequenceLength <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; <COMMENT>// RL - length of the number sequence</COMMENT>
        <TYPE>boolean</TYPE> sequenceStarted <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>; <COMMENT>// RL - has number sequence started?</COMMENT>
        <TYPE>int</TYPE> previousInt <OPERATOR>=</OPERATOR> <OPERATOR>-</OPERATOR><NUMERIC>20</NUMERIC>; <COMMENT>// RL - Bogus -20 state.</COMMENT>

        <COMMENT>// RL - Output matrix size</COMMENT>
        <OBJ>m_outstream</OBJ>.<OO>print</OO>(<OBJ>ia</OBJ>.<OO>length</OO>);
        <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>","</STRING>);
        <OBJ>m_outstream</OBJ>.<OO>print</OO>(<OBJ>ia</OBJ>.<OO>length</OO><OPERATOR>&gt;</OPERATOR><NUMERIC>0</NUMERIC><OPERATOR>?</OPERATOR>ia[<NUMERIC>0</NUMERIC>].length<OPERATOR>:</OPERATOR><NUMERIC>0</NUMERIC>);
        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>","</STRING>);

        <TYPE>StringBuffer</TYPE> outstr <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>StringBuffer</TYPE>();

        <COMMENT>//  RL - Output matrix</COMMENT>
        <KEYWORD>for</KEYWORD> (<TYPE>int</TYPE> elem <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; elem <OPERATOR>&lt;</OPERATOR> <OBJ>ia</OBJ>.<OO>length</OO>; <OPERATOR>++</OPERATOR>elem)
          {
            <KEYWORD>for</KEYWORD> (<TYPE>int</TYPE> i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> ia[elem].length; <OPERATOR>++</OPERATOR>i)
              {
                <TYPE>int</TYPE> writeInt <OPERATOR>=</OPERATOR> ia[elem][i];
                <KEYWORD>if</KEYWORD> (writeInt <OPERATOR>==</OPERATOR> previousInt) <COMMENT>// RL - sequence?</COMMENT>
                  {
                    <KEYWORD>if</KEYWORD> (sequenceStarted)
                      {
                        sequenceLength<OPERATOR>++</OPERATOR>;
                      }
                    <KEYWORD>else</KEYWORD>
                      {
                        <OBJ>outstr</OBJ>.<OO>append</OO>(writeInt);
                        <OBJ>outstr</OBJ>.<OO>append</OO>(<STRING>":"</STRING>);
                        sequenceLength <OPERATOR>=</OPERATOR> <NUMERIC>2</NUMERIC>;
                        sequenceStarted <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
                      }
                  }
                <KEYWORD>else</KEYWORD> <COMMENT>// RL - no sequence or end sequence</COMMENT>
                  {
                    <KEYWORD>if</KEYWORD> (sequenceStarted)
                      {
                        <OBJ>outstr</OBJ>.<OO>append</OO>(sequenceLength);
                        <OBJ>outstr</OBJ>.<OO>append</OO>(<STRING>","</STRING>);
                        sequenceLength <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
                        sequenceStarted <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
                      }
                    <KEYWORD>else</KEYWORD>
                      {
                        <KEYWORD>if</KEYWORD> (previousInt <OPERATOR>!=</OPERATOR> <OPERATOR>-</OPERATOR><NUMERIC>20</NUMERIC>)
                          {
                            <OBJ>outstr</OBJ>.<OO>append</OO>(previousInt);
                            <OBJ>outstr</OBJ>.<OO>append</OO>(<STRING>","</STRING>);
                          }
                      }
                  }
                previousInt <OPERATOR>=</OPERATOR> writeInt;
                <COMMENT>// CSA: output in 75 character chunks.</COMMENT>
                <KEYWORD>if</KEYWORD> (<OBJ>outstr</OBJ>.<OO>length</OO>() <OPERATOR>&gt;</OPERATOR> <NUMERIC>75</NUMERIC>) {
                  <TYPE>String</TYPE> s <OPERATOR>=</OPERATOR> <OBJ>outstr</OBJ>.<OO>toString</OO>();
                  <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\"</ESC>"</STRING><OPERATOR>+</OPERATOR><OBJ>s</OBJ>.<OO>substring</OO>(<NUMERIC>0</NUMERIC>,<NUMERIC>75</NUMERIC>)<OPERATOR>+</OPERATOR><STRING>"<ESC>\"</ESC> +"</STRING>);
                  outstr <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>StringBuffer</TYPE>(<OBJ>s</OBJ>.<OO>substring</OO>(<NUMERIC>75</NUMERIC>));
                }
              }
          }
        <KEYWORD>if</KEYWORD> (sequenceStarted)
          {
            <OBJ>outstr</OBJ>.<OO>append</OO>(sequenceLength);
          }
        <KEYWORD>else</KEYWORD>
          {
            <OBJ>outstr</OBJ>.<OO>append</OO>(previousInt);
          }
        <COMMENT>// CSA: output in 75 character chunks.</COMMENT>
        <KEYWORD>if</KEYWORD> (<OBJ>outstr</OBJ>.<OO>length</OO>() <OPERATOR>&gt;</OPERATOR> <NUMERIC>75</NUMERIC>) {
          <TYPE>String</TYPE> s <OPERATOR>=</OPERATOR> <OBJ>outstr</OBJ>.<OO>toString</OO>();
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\"</ESC>"</STRING><OPERATOR>+</OPERATOR><OBJ>s</OBJ>.<OO>substring</OO>(<NUMERIC>0</NUMERIC>,<NUMERIC>75</NUMERIC>)<OPERATOR>+</OPERATOR><STRING>"<ESC>\"</ESC> +"</STRING>);
          outstr <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>StringBuffer</TYPE>(<OBJ>s</OBJ>.<OO>substring</OO>(<NUMERIC>75</NUMERIC>));
        }
        <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"<ESC>\"</ESC>"</STRING><OPERATOR>+</OPERATOR>outstr<OPERATOR>+</OPERATOR><STRING>"<ESC>\"</ESC>"</STRING>);
  }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: emit_driver</COMMENT>
<COMMENT>    Description:</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> emit_driver
    (
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
        {
          <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
            {
              <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_spec);
              <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_outstream);
            }

          emit_table();

          <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_integer_type</OO>)
            {
              <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"<ESC>\t</ESC>public int "</STRING>);
              <OBJ>m_outstream</OBJ>.<OO>print</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_spec</OBJ>.<OO>m_function_name</OO>));
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>" ()"</STRING>);
            }
          <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_intwrap_type</OO>)
            {
              <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"<ESC>\t</ESC>public java.lang.Integer "</STRING>);
              <OBJ>m_outstream</OBJ>.<OO>print</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_spec</OBJ>.<OO>m_function_name</OO>));
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>" ()"</STRING>);
            }
          <KEYWORD>else</KEYWORD>
            {
              <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"<ESC>\t</ESC>public "</STRING>);
              <OBJ>m_outstream</OBJ>.<OO>print</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_spec</OBJ>.<OO>m_type_name</OO>));
              <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>" "</STRING>);
              <OBJ>m_outstream</OBJ>.<OO>print</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_spec</OBJ>.<OO>m_function_name</OO>));
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>" ()"</STRING>);
            }

          <COMMENT>/*m_outstream.println("\t\tthrows java.io.IOException {");*/</COMMENT>
          <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>throws java.io.IOException"</STRING>);
          <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_yylex_throw_code</OO>)
            {
              <OBJ>m_outstream</OBJ>.<OO>print</OO>(<STRING>", "</STRING>);
              <OBJ>m_outstream</OBJ>.<OO>print</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_spec</OBJ>.<OO>m_yylex_throw_code</OO>,<NUMERIC>0</NUMERIC>,
                                                <OBJ>m_spec</OBJ>.<OO>m_yylex_throw_read</OO>));
              <OBJ>m_outstream</OBJ>.<OO>println</OO>();
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>{"</STRING>);
            }
          <KEYWORD>else</KEYWORD>
            {
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>" {"</STRING>);
            }

          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>int yy_lookahead;"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>int yy_anchor = YY_NO_ANCHOR;"</STRING>);
          <COMMENT>/*m_outstream.println("\t\tint yy_state "</COMMENT>
<COMMENT>            + "= yy_initial_dtrans(yy_lexical_state);");*/</COMMENT>
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>int yy_state "</STRING>
                                 <OPERATOR>+</OPERATOR> <STRING>"= yy_state_dtrans[yy_lexical_state];"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>int yy_next_state = YY_NO_STATE;"</STRING>);
          <COMMENT>/*m_outstream.println("\t\tint yy_prev_stave = YY_NO_STATE;");*/</COMMENT>
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>int yy_last_accept_state = YY_NO_STATE;"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>boolean yy_initial = true;"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>int yy_this_accept;"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>();

          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>yy_mark_start();"</STRING>);
          <COMMENT>/*m_outstream.println("\t\tyy_this_accept = yy_accept(yy_state);");*/</COMMENT>
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>yy_this_accept = yy_acpt[yy_state];"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>if (YY_NOT_ACCEPT != yy_this_accept) {"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_last_accept_state = yy_state;"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_mark_end();"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);

          <KEYWORD>if</KEYWORD> (<CONSTANT>NOT_EDBG</CONSTANT>)
            {
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>java.lang.System.out.println(<ESC>\"</ESC>Begin<ESC>\"</ESC>);"</STRING>);
            }

          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>while (true) {"</STRING>);

          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>if (yy_initial &amp;&amp; yy_at_bol) "</STRING><OPERATOR>+</OPERATOR>
                                         <STRING>"yy_lookahead = YY_BOL;"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>else yy_lookahead = yy_advance();"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_next_state = YY_F;"</STRING>);
          <COMMENT>/*m_outstream.println("\t\t\t\tyy_next_state = "</COMMENT>
<COMMENT>                                 + "yy_next(yy_state,yy_lookahead);");*/</COMMENT>
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_next_state = "</STRING>
           <OPERATOR>+</OPERATOR> <STRING>"yy_nxt[yy_rmap[yy_state]][yy_cmap[yy_lookahead]];"</STRING>);

          <KEYWORD>if</KEYWORD> (<CONSTANT>NOT_EDBG</CONSTANT>)
            {
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"java.lang.System.out.println(<ESC>\"</ESC>Current state: <ESC>\"</ESC>"</STRING>
                                     <OPERATOR>+</OPERATOR> <STRING>" + yy_state"</STRING>);
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"+ <ESC>\"</ESC><ESC>\t</ESC>Current input: <ESC>\"</ESC>"</STRING>);
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>" + ((char) yy_lookahead));"</STRING>);
            }
          <KEYWORD>if</KEYWORD> (<CONSTANT>NOT_EDBG</CONSTANT>)
            {
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>java.lang.System.out.println(<ESC>\"</ESC>State = <ESC>\"</ESC>"</STRING>
                                     <OPERATOR>+</OPERATOR> <STRING>"+ yy_state);"</STRING>);
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>java.lang.System.out.println(<ESC>\"</ESC>Accepting status = <ESC>\"</ESC>"</STRING>
                                     <OPERATOR>+</OPERATOR> <STRING>"+ yy_this_accept);"</STRING>);
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>java.lang.System.out.println(<ESC>\"</ESC>Last accepting state = <ESC>\"</ESC>"</STRING>
                                     <OPERATOR>+</OPERATOR> <STRING>"+ yy_last_accept_state);"</STRING>);
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>java.lang.System.out.println(<ESC>\"</ESC>Next state = <ESC>\"</ESC>"</STRING>
                                     <OPERATOR>+</OPERATOR> <STRING>"+ yy_next_state);"</STRING>);
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>java.lang.System.out.println(<ESC>\"</ESC>Lookahead input = <ESC>\"</ESC>"</STRING>
                                     <OPERATOR>+</OPERATOR> <STRING>"+ ((char) yy_lookahead));"</STRING>);
            }

          <COMMENT>// handle bare EOF.</COMMENT>
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>if (YY_EOF == yy_lookahead "</STRING>
                                 <OPERATOR>+</OPERATOR> <STRING>"&amp;&amp; true == yy_initial) {"</STRING>);
          <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_eof_code</OO>)
            {
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_do_eof();"</STRING>);
            }
          <KEYWORD>if</KEYWORD> (<KEYWORD>true</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_integer_type</OO>)
            {
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>return YYEOF;"</STRING>);
            }
          <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_eof_value_code</OO>)
            {
              <OBJ>m_outstream</OBJ>.<OO>print</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_spec</OBJ>.<OO>m_eof_value_code</OO>,<NUMERIC>0</NUMERIC>,
                                                <OBJ>m_spec</OBJ>.<OO>m_eof_value_read</OO>));
            }
          <KEYWORD>else</KEYWORD>
            {
              <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>return null;"</STRING>);
            }
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);

          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>if (YY_F != yy_next_state) {"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_state = yy_next_state;"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_initial = false;"</STRING>);
          <COMMENT>/*m_outstream.println("\t\t\t\tyy_this_accept = yy_accept(yy_state);");*/</COMMENT>
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_this_accept = yy_acpt[yy_state];"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>if (YY_NOT_ACCEPT != yy_this_accept) {"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_last_accept_state = yy_state;"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_mark_end();"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);
          <COMMENT>/*m_outstream.println("\t\t\t\tyy_prev_state = yy_state;");*/</COMMENT>
          <COMMENT>/*m_outstream.println("\t\t\t\tyy_state = yy_next_state;");*/</COMMENT>
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);

          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>else {"</STRING>);

          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>if (YY_NO_STATE == yy_last_accept_state) {"</STRING>);


          <COMMENT>/*m_outstream.println("\t\t\t\t\tyy_error(YY_E_MATCH,false);");</COMMENT>
<COMMENT>          m_outstream.println("\t\t\t\t\tyy_initial = true;");</COMMENT>
<COMMENT>          m_outstream.println("\t\t\t\t\tyy_state "</COMMENT>
<COMMENT>                                 + "= yy_state_dtrans[yy_lexical_state];");</COMMENT>
<COMMENT>          m_outstream.println("\t\t\t\t\tyy_next_state = YY_NO_STATE;");*/</COMMENT>
          <COMMENT>/*m_outstream.println("\t\t\t\t\tyy_prev_state = YY_NO_STATE;");*/</COMMENT>
          <COMMENT>/*m_outstream.println("\t\t\t\t\tyy_last_accept_state = YY_NO_STATE;");</COMMENT>
<COMMENT>          m_outstream.println("\t\t\t\t\tyy_mark_start();");*/</COMMENT>
          <COMMENT>/*m_outstream.println("\t\t\t\t\tyy_this_accept = yy_accept(yy_state);");*/</COMMENT>
          <COMMENT>/*m_outstream.println("\t\t\t\t\tyy_this_accept = yy_acpt[yy_state];");</COMMENT>
<COMMENT>          m_outstream.println("\t\t\t\t\tif (YY_NOT_ACCEPT != yy_this_accept) {");</COMMENT>
<COMMENT>          m_outstream.println("\t\t\t\t\t\tyy_last_accept_state = yy_state;");</COMMENT>
<COMMENT>          m_outstream.println("\t\t\t\t\t}");*/</COMMENT>

          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>throw (new Error(<ESC>\"</ESC>Lexical Error: Unmatched Input.<ESC>\"</ESC>));"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);

          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>else {"</STRING>);

          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_anchor = yy_acpt[yy_last_accept_state];"</STRING>);
          <COMMENT>/*m_outstream.println("\t\t\t\t\tyy_anchor "</COMMENT>
<COMMENT>            + "= yy_accept(yy_last_accept_state);");*/</COMMENT>
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>if (0 != (YY_END &amp; yy_anchor)) {"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_move_end();"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_to_mark();"</STRING>);

          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>switch (yy_last_accept_state) {"</STRING>);

          emit_actions(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>"</STRING>);

          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>default:"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_error(YY_E_INTERNAL,false);"</STRING>);
          <COMMENT>/*m_outstream.println("\t\t\t\t\t\treturn null;");*/</COMMENT>
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>case -1:"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);

          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_initial = true;"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_state "</STRING>
                                 <OPERATOR>+</OPERATOR> <STRING>"= yy_state_dtrans[yy_lexical_state];"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_next_state = YY_NO_STATE;"</STRING>);
          <COMMENT>/*m_outstream.println("\t\t\t\t\tyy_prev_state = YY_NO_STATE;");*/</COMMENT>
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_last_accept_state = YY_NO_STATE;"</STRING>);

          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_mark_start();"</STRING>);

          <COMMENT>/*m_outstream.println("\t\t\t\t\tyy_this_accept = yy_accept(yy_state);");*/</COMMENT>
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_this_accept = yy_acpt[yy_state];"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>if (YY_NOT_ACCEPT != yy_this_accept) {"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_last_accept_state = yy_state;"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>yy_mark_end();"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);

          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC><ESC>\t</ESC>}"</STRING>);
          <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>}"</STRING>);

          <COMMENT>/*m_outstream.println("\t\t\t\t");</COMMENT>
<COMMENT>          m_outstream.println("\t\t\t");</COMMENT>
<COMMENT>          m_outstream.println("\t\t\t");</COMMENT>
<COMMENT>          m_outstream.println("\t\t\t");</COMMENT>
<COMMENT>          m_outstream.println("\t\t\t");</COMMENT>
<COMMENT>          m_outstream.println("\t\t}");*/</COMMENT>
        }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: emit_actions</COMMENT>
<COMMENT>    Description:</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> emit_actions
    (
     <TYPE>String</TYPE> tabs
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
        {
          <TYPE>int</TYPE> elem;
          <TYPE>int</TYPE> size;
          <TYPE>int</TYPE> bogus_index;
          CAccept accept;

          <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
            {
              <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>m_spec</OBJ>.<OO>m_accept_vector</OO>.<OO>size</OO>()
                              <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_anchor_array</OO>.<OO>length</OO>);
            }

          bogus_index <OPERATOR>=</OPERATOR> <OPERATOR>-</OPERATOR><NUMERIC>2</NUMERIC>;
          size <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_accept_vector</OO>.<OO>size</OO>();
          <KEYWORD>for</KEYWORD> (elem <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; elem <OPERATOR>&lt;</OPERATOR> size; <OPERATOR>++</OPERATOR>elem)
            {
              accept <OPERATOR>=</OPERATOR> (CAccept) <OBJ>m_spec</OBJ>.<OO>m_accept_vector</OO>.<OO>elementAt</OO>(elem);
              <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> accept)
                {
                  <OBJ>m_outstream</OBJ>.<OO>println</OO>(tabs <OPERATOR>+</OPERATOR> <STRING>"case "</STRING> <OPERATOR>+</OPERATOR> elem
                                         <OPERATOR>+</OPERATOR> <STRING>":"</STRING>);
                  <OBJ>m_outstream</OBJ>.<OO>print</OO>(tabs <OPERATOR>+</OPERATOR> <STRING>"<ESC>\t</ESC>"</STRING>);
                  <OBJ>m_outstream</OBJ>.<OO>print</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>accept</OBJ>.<OO>m_action</OO>,<NUMERIC>0</NUMERIC>,
                                                    <OBJ>accept</OBJ>.<OO>m_action_read</OO>));
                  <OBJ>m_outstream</OBJ>.<OO>println</OO>();
                  <OBJ>m_outstream</OBJ>.<OO>println</OO>(tabs <OPERATOR>+</OPERATOR> <STRING>"case "</STRING> <OPERATOR>+</OPERATOR> bogus_index <OPERATOR>+</OPERATOR> <STRING>":"</STRING>);
                  <OBJ>m_outstream</OBJ>.<OO>println</OO>(tabs <OPERATOR>+</OPERATOR> <STRING>"<ESC>\t</ESC>break;"</STRING>);
                  <OPERATOR>--</OPERATOR>bogus_index;
                }
            }
        }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: emit_footer</COMMENT>
<COMMENT>    Description:</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> emit_footer
    (
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
      {
        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_spec);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_outstream);
          }

        <OBJ>m_outstream</OBJ>.<OO>println</OO>(<STRING>"}"</STRING>);
      }
}

<COMMENT>/***************************************************************</COMMENT>
<COMMENT>  Class: CBunch</COMMENT>
<COMMENT>  **************************************************************/</COMMENT>
<KEYWORD>class</KEYWORD> CBunch
{
  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Member Variables</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <TYPE>Vector</TYPE> m_nfa_set; <COMMENT>/* Vector of CNfa states in dfa state. */</COMMENT>
  SparseBitSet m_nfa_bit; <COMMENT>/* BitSet representation of CNfa labels. */</COMMENT>
  CAccept m_accept; <COMMENT>/* Accepting actions, or null if nonaccepting state. */</COMMENT>
  <TYPE>int</TYPE> m_anchor; <COMMENT>/* Anchors on regular expression. */</COMMENT>
  <TYPE>int</TYPE> m_accept_index; <COMMENT>/* CNfa index corresponding to accepting actions. */</COMMENT>

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: CBunch</COMMENT>
<COMMENT>    Description: Constructor.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  CBunch
    (
     )
      {
        m_nfa_set <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_nfa_bit <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_accept <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_anchor <OPERATOR>=</OPERATOR> <OBJ>CSpec</OBJ>.<OO>NONE</OO>;
        m_accept_index <OPERATOR>=</OPERATOR> <OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC>;
      }
}

<COMMENT>/***************************************************************</COMMENT>
<COMMENT>  Class: CMakeNfa</COMMENT>
<COMMENT>  **************************************************************/</COMMENT>
<KEYWORD>class</KEYWORD> CMakeNfa
{
  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Member Variables</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> CSpec m_spec;
  <KEYWORD>private</KEYWORD> CLexGen m_lexGen;
  <KEYWORD>private</KEYWORD> CInput m_input;

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: CMakeNfa</COMMENT>
<COMMENT>    Description: Constructor.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  CMakeNfa
    (
     )
      {
        reset();
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: reset</COMMENT>
<COMMENT>    Description: Resets CMakeNfa member variables.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> reset
    (
     )
      {
        m_input <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_lexGen <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_spec <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: set</COMMENT>
<COMMENT>    Description: Sets CMakeNfa member variables.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> set
    (
     CLexGen lexGen,
     CSpec spec,
     CInput input
     )
      {
        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> input);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> lexGen);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> spec);
          }

        m_input <OPERATOR>=</OPERATOR> input;
        m_lexGen <OPERATOR>=</OPERATOR> lexGen;
        m_spec <OPERATOR>=</OPERATOR> spec;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: allocate_BOL_EOF</COMMENT>
<COMMENT>    Description: Expands character class to include special BOL and</COMMENT>
<COMMENT>    EOF characters.  Puts numeric index of these characters in</COMMENT>
<COMMENT>    input CSpec.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <TYPE>void</TYPE> allocate_BOL_EOF
    (
     CSpec spec
     )
        {
          <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>CSpec</OBJ>.<OO>NUM_PSEUDO</OO><OPERATOR>==</OPERATOR><NUMERIC>2</NUMERIC>);
          <OBJ>spec</OBJ>.<OO>BOL</OO> <OPERATOR>=</OPERATOR> <OBJ>spec</OBJ>.<OO>m_dtrans_ncols</OO><OPERATOR>++</OPERATOR>;
          <OBJ>spec</OBJ>.<OO>EOF</OO> <OPERATOR>=</OPERATOR> <OBJ>spec</OBJ>.<OO>m_dtrans_ncols</OO><OPERATOR>++</OPERATOR>;
        }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: thompson</COMMENT>
<COMMENT>    Description: High level access function to module.</COMMENT>
<COMMENT>    Deposits result in input CSpec.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <TYPE>void</TYPE> thompson
    (
     CLexGen lexGen,
     CSpec spec,
     CInput input
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
        {
          <TYPE>int</TYPE> i;
          CNfa elem;
          <TYPE>int</TYPE> size;

          <COMMENT>/* Set member variables. */</COMMENT>
          reset();
          set(lexGen,spec,input);

          size <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_states</OO>.<OO>size</OO>();
          <OBJ>m_spec</OBJ>.<OO>m_state_rules</OO> <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Vector</TYPE>[size];
          <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> size; <OPERATOR>++</OPERATOR>i)
            {
              <OBJ>m_spec</OBJ>.<OO>m_state_rules</OO>[i] <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Vector</TYPE>();
            }

          <COMMENT>/* Initialize current token variable</COMMENT>
<COMMENT>             and create nfa. */</COMMENT>
          <COMMENT>/*m_spec.m_current_token = m_lexGen.EOS;</COMMENT>
<COMMENT>          m_lexGen.advance();*/</COMMENT>

          <OBJ>m_spec</OBJ>.<OO>m_nfa_start</OO> <OPERATOR>=</OPERATOR> machine();

          <COMMENT>/* Set labels in created nfa machine. */</COMMENT>
          size <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_nfa_states</OO>.<OO>size</OO>();
          <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> size; <OPERATOR>++</OPERATOR>i)
            {
              elem <OPERATOR>=</OPERATOR> (CNfa) <OBJ>m_spec</OBJ>.<OO>m_nfa_states</OO>.<OO>elementAt</OO>(i);
              <OBJ>elem</OBJ>.<OO>m_label</OO> <OPERATOR>=</OPERATOR> i;
            }

          <COMMENT>/* Debugging output. */</COMMENT>
          <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DO_DEBUG</OO>)
            {
              <OBJ>m_lexGen</OBJ>.<OO>print_nfa</OO>();
            }

          <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_verbose</OO>)
            {
              <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"NFA comprised of "</STRING>
                                 <OPERATOR>+</OPERATOR> (<OBJ>m_spec</OBJ>.<OO>m_nfa_states</OO>.<OO>size</OO>() <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>)
                                 <OPERATOR>+</OPERATOR> <STRING>" states."</STRING>);
            }

          reset();
        }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: discardCNfa</COMMENT>
<COMMENT>    Description:</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> discardCNfa
    (
     CNfa nfa
     )
      {
        <OBJ>m_spec</OBJ>.<OO>m_nfa_states</OO>.<OO>removeElement</OO>(nfa);
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: processStates</COMMENT>
<COMMENT>    Description:</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> processStates
    (
     SparseBitSet states,
     CNfa current
     )
      {
        <TYPE>int</TYPE> size;
        <TYPE>int</TYPE> i;

        size <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_states</OO>.<OO>size</OO>();
        <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR>  size; <OPERATOR>++</OPERATOR>i)
          {
            <KEYWORD>if</KEYWORD> (<OBJ>states</OBJ>.<OO>get</OO>(i))
              {
                <OBJ>m_spec</OBJ>.<OO>m_state_rules</OO>[i].addElement(current);
              }
          }
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: machine</COMMENT>
<COMMENT>    Description: Recursive descent regular expression parser.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> CNfa machine
    (
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
      {
        CNfa start;
        CNfa p;
        SparseBitSet states;

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DESCENT_DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>enter</OO>(<STRING>"machine"</STRING>,<OBJ>m_spec</OBJ>.<OO>m_lexeme</OO>,<OBJ>m_spec</OBJ>.<OO>m_current_token</OO>);
          }

        start <OPERATOR>=</OPERATOR> <OBJ>CAlloc</OBJ>.<OO>newCNfa</OO>(m_spec);
        p <OPERATOR>=</OPERATOR> start;

        states <OPERATOR>=</OPERATOR> <OBJ>m_lexGen</OBJ>.<OO>getStates</OO>();

        <COMMENT>/* Begin: Added for states. */</COMMENT>
        <OBJ>m_spec</OBJ>.<OO>m_current_token</OO> <OPERATOR>=</OPERATOR> <OBJ>m_lexGen</OBJ>.<OO>EOS</OO>;
        <OBJ>m_lexGen</OBJ>.<OO>advance</OO>();
        <COMMENT>/* End: Added for states. */</COMMENT>

        <KEYWORD>if</KEYWORD> (<OBJ>m_lexGen</OBJ>.<OO>END_OF_INPUT</OO> <OPERATOR>!=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>) <COMMENT>// CSA fix.</COMMENT>
          {
            <OBJ>p</OBJ>.<OO>m_next</OO> <OPERATOR>=</OPERATOR> rule();

            processStates(states,<OBJ>p</OBJ>.<OO>m_next</OO>);
          }

        <KEYWORD>while</KEYWORD> (<OBJ>m_lexGen</OBJ>.<OO>END_OF_INPUT</OO> <OPERATOR>!=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>)
          {
            <COMMENT>/* Make state changes HERE. */</COMMENT>
            states <OPERATOR>=</OPERATOR> <OBJ>m_lexGen</OBJ>.<OO>getStates</OO>();

            <COMMENT>/* Begin: Added for states. */</COMMENT>
            <OBJ>m_lexGen</OBJ>.<OO>advance</OO>();
            <KEYWORD>if</KEYWORD> (<OBJ>m_lexGen</OBJ>.<OO>END_OF_INPUT</OO> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>)
              {
                <KEYWORD>break</KEYWORD>;
              }
            <COMMENT>/* End: Added for states. */</COMMENT>

            <OBJ>p</OBJ>.<OO>m_next2</OO> <OPERATOR>=</OPERATOR> <OBJ>CAlloc</OBJ>.<OO>newCNfa</OO>(m_spec);
            p <OPERATOR>=</OPERATOR> <OBJ>p</OBJ>.<OO>m_next2</OO>;
            <OBJ>p</OBJ>.<OO>m_next</OO> <OPERATOR>=</OPERATOR> rule();

            processStates(states,<OBJ>p</OBJ>.<OO>m_next</OO>);
          }

        <COMMENT>// CSA: add pseudo-rules for BOL and EOF</COMMENT>
        SparseBitSet all_states <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> SparseBitSet();
        <KEYWORD>for</KEYWORD> (<TYPE>int</TYPE> i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_states</OO>.<OO>size</OO>(); <OPERATOR>++</OPERATOR>i)
                <OBJ>all_states</OBJ>.<OO>set</OO>(i);
        <OBJ>p</OBJ>.<OO>m_next2</OO> <OPERATOR>=</OPERATOR> <OBJ>CAlloc</OBJ>.<OO>newCNfa</OO>(m_spec);
        p <OPERATOR>=</OPERATOR> <OBJ>p</OBJ>.<OO>m_next2</OO>;
        <OBJ>p</OBJ>.<OO>m_next</OO> <OPERATOR>=</OPERATOR> <OBJ>CAlloc</OBJ>.<OO>newCNfa</OO>(m_spec);
        <OBJ>p</OBJ>.<OO>m_next</OO>.<OO>m_edge</OO> <OPERATOR>=</OPERATOR> <OBJ>CNfa</OBJ>.<OO>CCL</OO>;
        <OBJ>p</OBJ>.<OO>m_next</OO>.<OO>m_next</OO> <OPERATOR>=</OPERATOR> <OBJ>CAlloc</OBJ>.<OO>newCNfa</OO>(m_spec);
        <OBJ>p</OBJ>.<OO>m_next</OO>.<OO>m_set</OO> <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> CSet();
        <OBJ>p</OBJ>.<OO>m_next</OO>.<OO>m_set</OO>.<OO>add</OO>(<OBJ>m_spec</OBJ>.<OO>BOL</OO>);
        <OBJ>p</OBJ>.<OO>m_next</OO>.<OO>m_set</OO>.<OO>add</OO>(<OBJ>m_spec</OBJ>.<OO>EOF</OO>);
        <OBJ>p</OBJ>.<OO>m_next</OO>.<OO>m_next</OO>.<OO>m_accept</OO> <OPERATOR>=</OPERATOR> <COMMENT>// do-nothing accept rule</COMMENT>
            <KEYWORD>new</KEYWORD> CAccept(<KEYWORD>new</KEYWORD> <TYPE>char</TYPE>[<NUMERIC>0</NUMERIC>], <NUMERIC>0</NUMERIC>, <OBJ>m_input</OBJ>.<OO>m_line_number</OO><OPERATOR>+</OPERATOR><NUMERIC>1</NUMERIC>);
        processStates(all_states,<OBJ>p</OBJ>.<OO>m_next</OO>);
        <COMMENT>// CSA: done.</COMMENT>

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DESCENT_DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>leave</OO>(<STRING>"machine"</STRING>,<OBJ>m_spec</OBJ>.<OO>m_lexeme</OO>,<OBJ>m_spec</OBJ>.<OO>m_current_token</OO>);
          }

        <KEYWORD>return</KEYWORD> start;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: rule</COMMENT>
<COMMENT>    Description: Recursive descent regular expression parser.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> CNfa rule
    (
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
      {
        CNfaPair pair;
        CNfa p;
        CNfa start <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        CNfa end <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        <TYPE>int</TYPE> anchor <OPERATOR>=</OPERATOR> <OBJ>CSpec</OBJ>.<OO>NONE</OO>;

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DESCENT_DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>enter</OO>(<STRING>"rule"</STRING>,<OBJ>m_spec</OBJ>.<OO>m_lexeme</OO>,<OBJ>m_spec</OBJ>.<OO>m_current_token</OO>);
          }

        pair <OPERATOR>=</OPERATOR> <OBJ>CAlloc</OBJ>.<OO>newCNfaPair</OO>();

        <KEYWORD>if</KEYWORD> (<OBJ>m_lexGen</OBJ>.<OO>AT_BOL</OO> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>)
          {
            anchor <OPERATOR>=</OPERATOR> anchor <OPERATOR>|</OPERATOR> <OBJ>CSpec</OBJ>.<OO>START</OO>;
            <OBJ>m_lexGen</OBJ>.<OO>advance</OO>();
            expr(pair);

            <COMMENT>// CSA: fixed beginning-of-line operator. 8-aug-1999</COMMENT>
            start <OPERATOR>=</OPERATOR> <OBJ>CAlloc</OBJ>.<OO>newCNfa</OO>(m_spec);
            <OBJ>start</OBJ>.<OO>m_edge</OO> <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>BOL</OO>;
            <OBJ>start</OBJ>.<OO>m_next</OO> <OPERATOR>=</OPERATOR> <OBJ>pair</OBJ>.<OO>m_start</OO>;
            end <OPERATOR>=</OPERATOR> <OBJ>pair</OBJ>.<OO>m_end</OO>;
          }
        <KEYWORD>else</KEYWORD>
          {
            expr(pair);
            start <OPERATOR>=</OPERATOR> <OBJ>pair</OBJ>.<OO>m_start</OO>;
            end <OPERATOR>=</OPERATOR> <OBJ>pair</OBJ>.<OO>m_end</OO>;
          }

        <KEYWORD>if</KEYWORD> (<OBJ>m_lexGen</OBJ>.<OO>AT_EOL</OO> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>)
          {
            <OBJ>m_lexGen</OBJ>.<OO>advance</OO>();
            <COMMENT>// CSA: fixed end-of-line operator. 8-aug-1999</COMMENT>
            CNfaPair nlpair <OPERATOR>=</OPERATOR> <OBJ>CAlloc</OBJ>.<OO>newNLPair</OO>(m_spec);
            <OBJ>end</OBJ>.<OO>m_next</OO> <OPERATOR>=</OPERATOR> <OBJ>CAlloc</OBJ>.<OO>newCNfa</OO>(m_spec);
            <OBJ>end</OBJ>.<OO>m_next</OO>.<OO>m_next</OO> <OPERATOR>=</OPERATOR> <OBJ>nlpair</OBJ>.<OO>m_start</OO>;
            <OBJ>end</OBJ>.<OO>m_next</OO>.<OO>m_next2</OO> <OPERATOR>=</OPERATOR> <OBJ>CAlloc</OBJ>.<OO>newCNfa</OO>(m_spec);
            <OBJ>end</OBJ>.<OO>m_next</OO>.<OO>m_next2</OO>.<OO>m_edge</OO> <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>EOF</OO>;
            <OBJ>end</OBJ>.<OO>m_next</OO>.<OO>m_next2</OO>.<OO>m_next</OO> <OPERATOR>=</OPERATOR> <OBJ>nlpair</OBJ>.<OO>m_end</OO>;
            end <OPERATOR>=</OPERATOR> <OBJ>nlpair</OBJ>.<OO>m_end</OO>;
            anchor <OPERATOR>=</OPERATOR> anchor <OPERATOR>|</OPERATOR> <OBJ>CSpec</OBJ>.<OO>END</OO>;
          }

        <COMMENT>/* Check for null rules. Charles Fischer found this bug. [CSA] */</COMMENT>
        <KEYWORD>if</KEYWORD> (end<OPERATOR>==</OPERATOR><KEYWORD>null</KEYWORD>)
            <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_ZERO</OO>, <OBJ>m_input</OBJ>.<OO>m_line_number</OO>);

        <COMMENT>/* Handle end of regular expression.  See page 103. */</COMMENT>
        <OBJ>end</OBJ>.<OO>m_accept</OO> <OPERATOR>=</OPERATOR> <OBJ>m_lexGen</OBJ>.<OO>packAccept</OO>();
        <OBJ>end</OBJ>.<OO>m_anchor</OO> <OPERATOR>=</OPERATOR> anchor;

        <COMMENT>/* Begin: Removed for states. */</COMMENT>
        <COMMENT>/*m_lexGen.advance();*/</COMMENT>
        <COMMENT>/* End: Removed for states. */</COMMENT>

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DESCENT_DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>leave</OO>(<STRING>"rule"</STRING>,<OBJ>m_spec</OBJ>.<OO>m_lexeme</OO>,<OBJ>m_spec</OBJ>.<OO>m_current_token</OO>);
          }

        <KEYWORD>return</KEYWORD> start;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: expr</COMMENT>
<COMMENT>    Description: Recursive descent regular expression parser.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> expr
    (
     CNfaPair pair
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
      {
        CNfaPair e2_pair;
        CNfa p;

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DESCENT_DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>enter</OO>(<STRING>"expr"</STRING>,<OBJ>m_spec</OBJ>.<OO>m_lexeme</OO>,<OBJ>m_spec</OBJ>.<OO>m_current_token</OO>);
          }

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> pair);
          }

        e2_pair <OPERATOR>=</OPERATOR> <OBJ>CAlloc</OBJ>.<OO>newCNfaPair</OO>();

        cat_expr(pair);

        <KEYWORD>while</KEYWORD> (<OBJ>m_lexGen</OBJ>.<OO>OR</OO> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>)
          {
            <OBJ>m_lexGen</OBJ>.<OO>advance</OO>();
            cat_expr(e2_pair);

            p <OPERATOR>=</OPERATOR> <OBJ>CAlloc</OBJ>.<OO>newCNfa</OO>(m_spec);
            <OBJ>p</OBJ>.<OO>m_next2</OO> <OPERATOR>=</OPERATOR> <OBJ>e2_pair</OBJ>.<OO>m_start</OO>;
            <OBJ>p</OBJ>.<OO>m_next</OO> <OPERATOR>=</OPERATOR> <OBJ>pair</OBJ>.<OO>m_start</OO>;
            <OBJ>pair</OBJ>.<OO>m_start</OO> <OPERATOR>=</OPERATOR> p;

            p <OPERATOR>=</OPERATOR> <OBJ>CAlloc</OBJ>.<OO>newCNfa</OO>(m_spec);
            <OBJ>pair</OBJ>.<OO>m_end</OO>.<OO>m_next</OO> <OPERATOR>=</OPERATOR> p;
            <OBJ>e2_pair</OBJ>.<OO>m_end</OO>.<OO>m_next</OO> <OPERATOR>=</OPERATOR> p;
            <OBJ>pair</OBJ>.<OO>m_end</OO> <OPERATOR>=</OPERATOR> p;
          }

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DESCENT_DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>leave</OO>(<STRING>"expr"</STRING>,<OBJ>m_spec</OBJ>.<OO>m_lexeme</OO>,<OBJ>m_spec</OBJ>.<OO>m_current_token</OO>);
          }
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: cat_expr</COMMENT>
<COMMENT>    Description: Recursive descent regular expression parser.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> cat_expr
    (
     CNfaPair pair
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
      {
        CNfaPair e2_pair;

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DESCENT_DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>enter</OO>(<STRING>"cat_expr"</STRING>,<OBJ>m_spec</OBJ>.<OO>m_lexeme</OO>,<OBJ>m_spec</OBJ>.<OO>m_current_token</OO>);
          }

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> pair);
          }

        e2_pair <OPERATOR>=</OPERATOR> <OBJ>CAlloc</OBJ>.<OO>newCNfaPair</OO>();

        <KEYWORD>if</KEYWORD> (first_in_cat(<OBJ>m_spec</OBJ>.<OO>m_current_token</OO>))
          {
            factor(pair);
          }

        <KEYWORD>while</KEYWORD> (first_in_cat(<OBJ>m_spec</OBJ>.<OO>m_current_token</OO>))
          {
            factor(e2_pair);

            <COMMENT>/* Destroy */</COMMENT>
            <OBJ>pair</OBJ>.<OO>m_end</OO>.<OO>mimic</OO>(<OBJ>e2_pair</OBJ>.<OO>m_start</OO>);
            discardCNfa(<OBJ>e2_pair</OBJ>.<OO>m_start</OO>);

            <OBJ>pair</OBJ>.<OO>m_end</OO> <OPERATOR>=</OPERATOR> <OBJ>e2_pair</OBJ>.<OO>m_end</OO>;
          }

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DESCENT_DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>leave</OO>(<STRING>"cat_expr"</STRING>,<OBJ>m_spec</OBJ>.<OO>m_lexeme</OO>,<OBJ>m_spec</OBJ>.<OO>m_current_token</OO>);
          }
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: first_in_cat</COMMENT>
<COMMENT>    Description: Recursive descent regular expression parser.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>boolean</TYPE> first_in_cat
    (
     <TYPE>int</TYPE> token
     )
      {
        <KEYWORD>switch</KEYWORD> (token)
          {
          <KEYWORD>case</KEYWORD> <OBJ>CLexGen</OBJ>.<OO>CLOSE_PAREN</OO><OPERATOR>:</OPERATOR>
          <KEYWORD>case</KEYWORD> <OBJ>CLexGen</OBJ>.<OO>AT_EOL</OO><OPERATOR>:</OPERATOR>
          <KEYWORD>case</KEYWORD> <OBJ>CLexGen</OBJ>.<OO>OR</OO><OPERATOR>:</OPERATOR>
          <KEYWORD>case</KEYWORD> <OBJ>CLexGen</OBJ>.<OO>EOS</OO><OPERATOR>:</OPERATOR>
            <KEYWORD>return</KEYWORD> <KEYWORD>false</KEYWORD>;

          <KEYWORD>case</KEYWORD> <OBJ>CLexGen</OBJ>.<OO>CLOSURE</OO><OPERATOR>:</OPERATOR>
          <KEYWORD>case</KEYWORD> <OBJ>CLexGen</OBJ>.<OO>PLUS_CLOSE</OO><OPERATOR>:</OPERATOR>
          <KEYWORD>case</KEYWORD> <OBJ>CLexGen</OBJ>.<OO>OPTIONAL</OO><OPERATOR>:</OPERATOR>
            <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_CLOSE</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
            <KEYWORD>return</KEYWORD> <KEYWORD>false</KEYWORD>;

          <KEYWORD>case</KEYWORD> <OBJ>CLexGen</OBJ>.<OO>CCL_END</OO><OPERATOR>:</OPERATOR>
            <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_BRACKET</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
            <KEYWORD>return</KEYWORD> <KEYWORD>false</KEYWORD>;

          <KEYWORD>case</KEYWORD> <OBJ>CLexGen</OBJ>.<OO>AT_BOL</OO><OPERATOR>:</OPERATOR>
            <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_BOL</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
            <KEYWORD>return</KEYWORD> <KEYWORD>false</KEYWORD>;

          <KEYWORD>default</KEYWORD><OPERATOR>:</OPERATOR>
            <KEYWORD>break</KEYWORD>;
          }

        <KEYWORD>return</KEYWORD> <KEYWORD>true</KEYWORD>;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: factor</COMMENT>
<COMMENT>    Description: Recursive descent regular expression parser.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> factor
    (
     CNfaPair pair
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
      {
        CNfa start <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        CNfa end <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DESCENT_DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>enter</OO>(<STRING>"factor"</STRING>,<OBJ>m_spec</OBJ>.<OO>m_lexeme</OO>,<OBJ>m_spec</OBJ>.<OO>m_current_token</OO>);
          }

        term(pair);

        <KEYWORD>if</KEYWORD> (<OBJ>m_lexGen</OBJ>.<OO>CLOSURE</OO> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>
            <OPERATOR>||</OPERATOR> <OBJ>m_lexGen</OBJ>.<OO>PLUS_CLOSE</OO> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>
            <OPERATOR>||</OPERATOR> <OBJ>m_lexGen</OBJ>.<OO>OPTIONAL</OO> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>)
          {
            start <OPERATOR>=</OPERATOR> <OBJ>CAlloc</OBJ>.<OO>newCNfa</OO>(m_spec);
            end <OPERATOR>=</OPERATOR> <OBJ>CAlloc</OBJ>.<OO>newCNfa</OO>(m_spec);

            <OBJ>start</OBJ>.<OO>m_next</OO> <OPERATOR>=</OPERATOR> <OBJ>pair</OBJ>.<OO>m_start</OO>;
            <OBJ>pair</OBJ>.<OO>m_end</OO>.<OO>m_next</OO> <OPERATOR>=</OPERATOR> end;

            <KEYWORD>if</KEYWORD> (<OBJ>m_lexGen</OBJ>.<OO>CLOSURE</OO> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>
                <OPERATOR>||</OPERATOR> <OBJ>m_lexGen</OBJ>.<OO>OPTIONAL</OO> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>)
              {
                <OBJ>start</OBJ>.<OO>m_next2</OO> <OPERATOR>=</OPERATOR> end;
              }

            <KEYWORD>if</KEYWORD> (<OBJ>m_lexGen</OBJ>.<OO>CLOSURE</OO> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>
                <OPERATOR>||</OPERATOR> <OBJ>m_lexGen</OBJ>.<OO>PLUS_CLOSE</OO> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>)
              {
                <OBJ>pair</OBJ>.<OO>m_end</OO>.<OO>m_next2</OO> <OPERATOR>=</OPERATOR> <OBJ>pair</OBJ>.<OO>m_start</OO>;
              }

            <OBJ>pair</OBJ>.<OO>m_start</OO> <OPERATOR>=</OPERATOR> start;
            <OBJ>pair</OBJ>.<OO>m_end</OO> <OPERATOR>=</OPERATOR> end;
            <OBJ>m_lexGen</OBJ>.<OO>advance</OO>();
          }

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DESCENT_DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>leave</OO>(<STRING>"factor"</STRING>,<OBJ>m_spec</OBJ>.<OO>m_lexeme</OO>,<OBJ>m_spec</OBJ>.<OO>m_current_token</OO>);
          }
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: term</COMMENT>
<COMMENT>    Description: Recursive descent regular expression parser.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> term
    (
     CNfaPair pair
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
      {
        CNfa start;
        <TYPE>boolean</TYPE> isAlphaL;
        <TYPE>int</TYPE> c;

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DESCENT_DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>enter</OO>(<STRING>"term"</STRING>,<OBJ>m_spec</OBJ>.<OO>m_lexeme</OO>,<OBJ>m_spec</OBJ>.<OO>m_current_token</OO>);
          }

        <KEYWORD>if</KEYWORD> (<OBJ>m_lexGen</OBJ>.<OO>OPEN_PAREN</OO> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>)
          {
            <OBJ>m_lexGen</OBJ>.<OO>advance</OO>();
            expr(pair);

            <KEYWORD>if</KEYWORD> (<OBJ>m_lexGen</OBJ>.<OO>CLOSE_PAREN</OO> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>)
              {
                <OBJ>m_lexGen</OBJ>.<OO>advance</OO>();
              }
            <KEYWORD>else</KEYWORD>
              {
                <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_SYNTAX</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
              }
          }
        <KEYWORD>else</KEYWORD>
          {
            start <OPERATOR>=</OPERATOR> <OBJ>CAlloc</OBJ>.<OO>newCNfa</OO>(m_spec);
            <OBJ>pair</OBJ>.<OO>m_start</OO> <OPERATOR>=</OPERATOR> start;

            <OBJ>start</OBJ>.<OO>m_next</OO> <OPERATOR>=</OPERATOR> <OBJ>CAlloc</OBJ>.<OO>newCNfa</OO>(m_spec);
            <OBJ>pair</OBJ>.<OO>m_end</OO> <OPERATOR>=</OPERATOR> <OBJ>start</OBJ>.<OO>m_next</OO>;

            <KEYWORD>if</KEYWORD> (<OBJ>m_lexGen</OBJ>.<OO>L</OO> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO> <OPERATOR>&amp;&amp;</OPERATOR>
                <OBJ>Character</OBJ>.<OO>isLetter</OO>(<OBJ>m_spec</OBJ>.<OO>m_lexeme</OO>))
              {
                isAlphaL <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
              }
            <KEYWORD>else</KEYWORD>
              {
                isAlphaL <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
              }
            <KEYWORD>if</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> (<OBJ>m_lexGen</OBJ>.<OO>ANY</OO> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>
                          <OPERATOR>||</OPERATOR> <OBJ>m_lexGen</OBJ>.<OO>CCL_START</OO> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>
                          <OPERATOR>||</OPERATOR> (<OBJ>m_spec</OBJ>.<OO>m_ignorecase</OO> <OPERATOR>&amp;&amp;</OPERATOR> isAlphaL)))
              {
                <OBJ>start</OBJ>.<OO>m_edge</OO> <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_lexeme</OO>;
                <OBJ>m_lexGen</OBJ>.<OO>advance</OO>();
              }
            <KEYWORD>else</KEYWORD>
              {
                <OBJ>start</OBJ>.<OO>m_edge</OO> <OPERATOR>=</OPERATOR> <OBJ>CNfa</OBJ>.<OO>CCL</OO>;

                <OBJ>start</OBJ>.<OO>m_set</OO> <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> CSet();

                <COMMENT>/* Match case-insensitive letters using character class. */</COMMENT>
                <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_ignorecase</OO> <OPERATOR>&amp;&amp;</OPERATOR> isAlphaL)
                  {
                    <OBJ>start</OBJ>.<OO>m_set</OO>.<OO>addncase</OO>(<OBJ>m_spec</OBJ>.<OO>m_lexeme</OO>);
                  }
                <COMMENT>/* Match dot (.) using character class. */</COMMENT>
                <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (<OBJ>m_lexGen</OBJ>.<OO>ANY</OO> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>)
                  {
                    <OBJ>start</OBJ>.<OO>m_set</OO>.<OO>add</OO>(<CHARACTER>'<ESC>\n</ESC>'</CHARACTER>);
                    <OBJ>start</OBJ>.<OO>m_set</OO>.<OO>add</OO>(<CHARACTER>'<ESC>\r</ESC>'</CHARACTER>);
                    <COMMENT>// CSA: exclude BOL and EOF from character classes</COMMENT>
                    <OBJ>start</OBJ>.<OO>m_set</OO>.<OO>add</OO>(<OBJ>m_spec</OBJ>.<OO>BOL</OO>);
                    <OBJ>start</OBJ>.<OO>m_set</OO>.<OO>add</OO>(<OBJ>m_spec</OBJ>.<OO>EOF</OO>);
                    <OBJ>start</OBJ>.<OO>m_set</OO>.<OO>complement</OO>();
                  }
                <KEYWORD>else</KEYWORD>
                  {
                    <OBJ>m_lexGen</OBJ>.<OO>advance</OO>();
                    <KEYWORD>if</KEYWORD> (<OBJ>m_lexGen</OBJ>.<OO>AT_BOL</OO> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>)
                      {
                        <OBJ>m_lexGen</OBJ>.<OO>advance</OO>();

                        <COMMENT>// CSA: exclude BOL and EOF from character classes</COMMENT>
                        <OBJ>start</OBJ>.<OO>m_set</OO>.<OO>add</OO>(<OBJ>m_spec</OBJ>.<OO>BOL</OO>);
                        <OBJ>start</OBJ>.<OO>m_set</OO>.<OO>add</OO>(<OBJ>m_spec</OBJ>.<OO>EOF</OO>);
                        <OBJ>start</OBJ>.<OO>m_set</OO>.<OO>complement</OO>();
                      }
                    <KEYWORD>if</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> (<OBJ>m_lexGen</OBJ>.<OO>CCL_END</OO> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>))
                      {
                        dodash(<OBJ>start</OBJ>.<OO>m_set</OO>);
                      }
                    <COMMENT>/*else</COMMENT>
<COMMENT>                      {</COMMENT>
<COMMENT>                        for (c = 0; c &lt;= ' '; ++c)</COMMENT>
<COMMENT>                          {</COMMENT>
<COMMENT>                            start.m_set.add((byte) c);</COMMENT>
<COMMENT>                          }</COMMENT>
<COMMENT>                      }*/</COMMENT>
                  }
                <OBJ>m_lexGen</OBJ>.<OO>advance</OO>();
              }
          }

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DESCENT_DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>leave</OO>(<STRING>"term"</STRING>,<OBJ>m_spec</OBJ>.<OO>m_lexeme</OO>,<OBJ>m_spec</OBJ>.<OO>m_current_token</OO>);
          }
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: dodash</COMMENT>
<COMMENT>    Description: Recursive descent regular expression parser.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> dodash
    (
     CSet set
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
        {
          <TYPE>int</TYPE> first <OPERATOR>=</OPERATOR> <OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC>;

          <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DESCENT_DEBUG</OO>)
            {
              <OBJ>CUtility</OBJ>.<OO>enter</OO>(<STRING>"dodash"</STRING>,<OBJ>m_spec</OBJ>.<OO>m_lexeme</OO>,<OBJ>m_spec</OBJ>.<OO>m_current_token</OO>);
            }

          <KEYWORD>while</KEYWORD> (<OBJ>m_lexGen</OBJ>.<OO>EOS</OO> <OPERATOR>!=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>
                 <OPERATOR>&amp;&amp;</OPERATOR> <OBJ>m_lexGen</OBJ>.<OO>CCL_END</OO> <OPERATOR>!=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>)
            {
              <COMMENT>// DASH loses its special meaning if it is first in class.</COMMENT>
              <KEYWORD>if</KEYWORD> (<OBJ>m_lexGen</OBJ>.<OO>DASH</OO> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO> <OPERATOR>&amp;&amp;</OPERATOR> <OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC> <OPERATOR>!=</OPERATOR> first)
                {
                  <OBJ>m_lexGen</OBJ>.<OO>advance</OO>();
                  <COMMENT>// DASH loses its special meaning if it is last in class.</COMMENT>
                  <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_current_token</OO> <OPERATOR>==</OPERATOR> <OBJ>m_lexGen</OBJ>.<OO>CCL_END</OO>)
                    {
                      <COMMENT>// 'first' already in set.</COMMENT>
                      <OBJ>set</OBJ>.<OO>add</OO>(<CHARACTER>'-'</CHARACTER>);
                      <KEYWORD>break</KEYWORD>;
                    }
                  <KEYWORD>for</KEYWORD> ( ; first <OPERATOR>&lt;=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_lexeme</OO>; <OPERATOR>++</OPERATOR>first)
                    {
                      <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_ignorecase</OO>)
                        <OBJ>set</OBJ>.<OO>addncase</OO>((<TYPE>char</TYPE>)first);
                      <KEYWORD>else</KEYWORD>
                        <OBJ>set</OBJ>.<OO>add</OO>(first);
                    }
                }
              <KEYWORD>else</KEYWORD>
                {
                  first <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_lexeme</OO>;
                  <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_ignorecase</OO>)
                    <OBJ>set</OBJ>.<OO>addncase</OO>(<OBJ>m_spec</OBJ>.<OO>m_lexeme</OO>);
                  <KEYWORD>else</KEYWORD>
                    <OBJ>set</OBJ>.<OO>add</OO>(<OBJ>m_spec</OBJ>.<OO>m_lexeme</OO>);
                }

              <OBJ>m_lexGen</OBJ>.<OO>advance</OO>();
            }

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DESCENT_DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>leave</OO>(<STRING>"dodash"</STRING>,<OBJ>m_spec</OBJ>.<OO>m_lexeme</OO>,<OBJ>m_spec</OBJ>.<OO>m_current_token</OO>);
          }
      }
}

<DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT> * Extract character classes from NFA and simplify.</DOCCOMMENT>
<DOCCOMMENT> * <DOCTAG>@author</DOCTAG> C. Scott Ananian 25-Jul-1999</DOCCOMMENT>
<DOCCOMMENT> */</DOCCOMMENT>
<KEYWORD>class</KEYWORD> CSimplifyNfa
{
  <KEYWORD>private</KEYWORD> <TYPE>int</TYPE>[] ccls; <COMMENT>// character class mapping.</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>int</TYPE> original_charset_size; <COMMENT>// original charset size</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>int</TYPE> mapped_charset_size; <COMMENT>// reduced charset size</COMMENT>

  <TYPE>void</TYPE> simplify(CSpec m_spec) {
    computeClasses(m_spec); <COMMENT>// initialize fields.</COMMENT>

    <COMMENT>// now rewrite the NFA using our character class mapping.</COMMENT>
    <KEYWORD>for</KEYWORD> (<TYPE>Enumeration</TYPE> e<OPERATOR>=</OPERATOR><OBJ>m_spec</OBJ>.<OO>m_nfa_states</OO>.<OO>elements</OO>(); <OBJ>e</OBJ>.<OO>hasMoreElements</OO>(); ) {
      CNfa nfa <OPERATOR>=</OPERATOR> (CNfa) <OBJ>e</OBJ>.<OO>nextElement</OO>();
      <KEYWORD>if</KEYWORD> (<OBJ>nfa</OBJ>.<OO>m_edge</OO><OPERATOR>==</OPERATOR><OBJ>CNfa</OBJ>.<OO>EMPTY</OO> <OPERATOR>||</OPERATOR> <OBJ>nfa</OBJ>.<OO>m_edge</OO><OPERATOR>==</OPERATOR><OBJ>CNfa</OBJ>.<OO>EPSILON</OO>)
        <KEYWORD>continue</KEYWORD>; <COMMENT>// no change.</COMMENT>
      <KEYWORD>if</KEYWORD> (<OBJ>nfa</OBJ>.<OO>m_edge</OO><OPERATOR>==</OPERATOR><OBJ>CNfa</OBJ>.<OO>CCL</OO>) {
        CSet ncset <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> CSet();
        <OBJ>ncset</OBJ>.<OO>map</OO>(<OBJ>nfa</OBJ>.<OO>m_set</OO>, ccls); <COMMENT>// map it.</COMMENT>
        <OBJ>nfa</OBJ>.<OO>m_set</OO> <OPERATOR>=</OPERATOR> ncset;
      } <KEYWORD>else</KEYWORD> { <COMMENT>// single character</COMMENT>
        <OBJ>nfa</OBJ>.<OO>m_edge</OO> <OPERATOR>=</OPERATOR> ccls[<OBJ>nfa</OBJ>.<OO>m_edge</OO>]; <COMMENT>// map it.</COMMENT>
      }
    }

    <COMMENT>// now update m_spec with the mapping.</COMMENT>
    <OBJ>m_spec</OBJ>.<OO>m_ccls_map</OO> <OPERATOR>=</OPERATOR> ccls;
    <OBJ>m_spec</OBJ>.<OO>m_dtrans_ncols</OO> <OPERATOR>=</OPERATOR> mapped_charset_size;
  }
  <DOCCOMMENT>/** Compute minimum set of character classes needed to disambiguate</DOCCOMMENT>
<DOCCOMMENT>   *  edges.  We optimistically assume that every character belongs to</DOCCOMMENT>
<DOCCOMMENT>   *  a single character class, and then incrementally split classes</DOCCOMMENT>
<DOCCOMMENT>   *  as we see edges that require discrimination between characters in</DOCCOMMENT>
<DOCCOMMENT>   *  the class. [CSA, 25-Jul-1999] */</DOCCOMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> computeClasses(CSpec m_spec) {
    <OBJ>this</OBJ>.<OO>original_charset_size</OO> <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dtrans_ncols</OO>;
    <OBJ>this</OBJ>.<OO>ccls</OO> <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>int</TYPE>[original_charset_size]; <COMMENT>// initially all zero.</COMMENT>

    <TYPE>int</TYPE> nextcls <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC>;
    SparseBitSet clsA <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> SparseBitSet(), clsB <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> SparseBitSet();
    <TYPE>Hashtable</TYPE> h <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Hashtable</TYPE>();

    <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>"Working on character classes."</STRING>);
    <KEYWORD>for</KEYWORD> (<TYPE>Enumeration</TYPE> e<OPERATOR>=</OPERATOR><OBJ>m_spec</OBJ>.<OO>m_nfa_states</OO>.<OO>elements</OO>(); <OBJ>e</OBJ>.<OO>hasMoreElements</OO>(); ) {
      CNfa nfa <OPERATOR>=</OPERATOR> (CNfa) <OBJ>e</OBJ>.<OO>nextElement</OO>();
      <KEYWORD>if</KEYWORD> (<OBJ>nfa</OBJ>.<OO>m_edge</OO><OPERATOR>==</OPERATOR><OBJ>CNfa</OBJ>.<OO>EMPTY</OO> <OPERATOR>||</OPERATOR> <OBJ>nfa</OBJ>.<OO>m_edge</OO><OPERATOR>==</OPERATOR><OBJ>CNfa</OBJ>.<OO>EPSILON</OO>)
        <KEYWORD>continue</KEYWORD>; <COMMENT>// no discriminatory information.</COMMENT>
      <OBJ>clsA</OBJ>.<OO>clearAll</OO>(); <OBJ>clsB</OBJ>.<OO>clearAll</OO>();
      <KEYWORD>for</KEYWORD> (<TYPE>int</TYPE> i<OPERATOR>=</OPERATOR><NUMERIC>0</NUMERIC>; i<OPERATOR>&lt;</OPERATOR><OBJ>ccls</OBJ>.<OO>length</OO>; i<OPERATOR>++</OPERATOR>)
        <KEYWORD>if</KEYWORD> (<OBJ>nfa</OBJ>.<OO>m_edge</OO><OPERATOR>==</OPERATOR>i <OPERATOR>||</OPERATOR> <COMMENT>// edge labeled with a character</COMMENT>
            <OBJ>nfa</OBJ>.<OO>m_edge</OO><OPERATOR>==</OPERATOR><OBJ>CNfa</OBJ>.<OO>CCL</OO> <OPERATOR>&amp;&amp;</OPERATOR> <OBJ>nfa</OBJ>.<OO>m_set</OO>.<OO>contains</OO>(i)) <COMMENT>// set of characters</COMMENT>
          <OBJ>clsA</OBJ>.<OO>set</OO>(ccls[i]);
        <KEYWORD>else</KEYWORD>
          <OBJ>clsB</OBJ>.<OO>set</OO>(ccls[i]);
      <COMMENT>// now figure out which character classes we need to split.</COMMENT>
      <OBJ>clsA</OBJ>.<OO>and</OO>(clsB); <COMMENT>// split the classes which show up on both sides of edge</COMMENT>
      <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<OBJ>clsA</OBJ>.<OO>size</OO>()<OPERATOR>==</OPERATOR><NUMERIC>0</NUMERIC><OPERATOR>?</OPERATOR><STRING>"."</STRING><OPERATOR>:</OPERATOR><STRING>":"</STRING>);
      <KEYWORD>if</KEYWORD> (<OBJ>clsA</OBJ>.<OO>size</OO>()<OPERATOR>==</OPERATOR><NUMERIC>0</NUMERIC>) <KEYWORD>continue</KEYWORD>; <COMMENT>// nothing to do.</COMMENT>
      <COMMENT>// and split them.</COMMENT>
      <OBJ>h</OBJ>.<OO>clear</OO>(); <COMMENT>// h will map old to new class name</COMMENT>
      <KEYWORD>for</KEYWORD> (<TYPE>int</TYPE> i<OPERATOR>=</OPERATOR><NUMERIC>0</NUMERIC>; i<OPERATOR>&lt;</OPERATOR><OBJ>ccls</OBJ>.<OO>length</OO>; i<OPERATOR>++</OPERATOR>)
        <KEYWORD>if</KEYWORD> (<OBJ>clsA</OBJ>.<OO>get</OO>(ccls[i])) <COMMENT>// a split class</COMMENT>
          <KEYWORD>if</KEYWORD> (<OBJ>nfa</OBJ>.<OO>m_edge</OO><OPERATOR>==</OPERATOR>i <OPERATOR>||</OPERATOR>
              <OBJ>nfa</OBJ>.<OO>m_edge</OO><OPERATOR>==</OPERATOR><OBJ>CNfa</OBJ>.<OO>CCL</OO> <OPERATOR>&amp;&amp;</OPERATOR> <OBJ>nfa</OBJ>.<OO>m_set</OO>.<OO>contains</OO>(i)) { <COMMENT>// on A side</COMMENT>
            <TYPE>Integer</TYPE> split <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Integer</TYPE>(ccls[i]);
            <KEYWORD>if</KEYWORD> (<OPERATOR>!</OPERATOR><OBJ>h</OBJ>.<OO>containsKey</OO>(split))
              <OBJ>h</OBJ>.<OO>put</OO>(split, <KEYWORD>new</KEYWORD> <TYPE>Integer</TYPE>(nextcls<OPERATOR>++</OPERATOR>)); <COMMENT>// make new class</COMMENT>
            ccls[i] <OPERATOR>=</OPERATOR> ((<TYPE>Integer</TYPE>)<OBJ>h</OBJ>.<OO>get</OO>(split)).intValue();
          }
    }
    <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>();
    <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"NFA has "</STRING><OPERATOR>+</OPERATOR>nextcls<OPERATOR>+</OPERATOR><STRING>" distinct character classes."</STRING>);

    <OBJ>this</OBJ>.<OO>mapped_charset_size</OO> <OPERATOR>=</OPERATOR> nextcls;
  }
}

<COMMENT>/***************************************************************</COMMENT>
<COMMENT>  Class: CMinimize</COMMENT>
<COMMENT> **************************************************************/</COMMENT>
<KEYWORD>class</KEYWORD> CMinimize
{
  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Member Variables</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  CSpec m_spec;
  <TYPE>Vector</TYPE> m_group;
  <TYPE>int</TYPE> m_ingroup[];

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: CMinimize</COMMENT>
<COMMENT>    Description: Constructor.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  CMinimize
    (
     )
      {
        reset();
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: reset</COMMENT>
<COMMENT>    Description: Resets member variables.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> reset
    (
     )
      {
        m_spec <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_group <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_ingroup <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: set</COMMENT>
<COMMENT>    Description: Sets member variables.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> set
    (
     CSpec spec
     )
      {
        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> spec);
          }

        m_spec <OPERATOR>=</OPERATOR> spec;
        m_group <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_ingroup <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: min_dfa</COMMENT>
<COMMENT>    Description: High-level access function to module.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <TYPE>void</TYPE> min_dfa
    (
     CSpec spec
     )
      {
        set(spec);

        <COMMENT>/* Remove redundant states. */</COMMENT>
        minimize();

        <COMMENT>/* Column and row compression.</COMMENT>
<COMMENT>           Save accept states in auxilary vector. */</COMMENT>
        reduce();

        reset();
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: col_copy</COMMENT>
<COMMENT>    Description: Copies source column into destination column.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> col_copy
    (
     <TYPE>int</TYPE> dest,
     <TYPE>int</TYPE> src
     )
      {
        <TYPE>int</TYPE> n;
        <TYPE>int</TYPE> i;
        CDTrans dtrans;

        n <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>size</OO>();
        <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> n; <OPERATOR>++</OPERATOR>i)
          {
            dtrans <OPERATOR>=</OPERATOR> (CDTrans) <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>elementAt</OO>(i);
            <OBJ>dtrans</OBJ>.<OO>m_dtrans</OO>[dest] <OPERATOR>=</OPERATOR> <OBJ>dtrans</OBJ>.<OO>m_dtrans</OO>[src];
          }
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: trunc_col</COMMENT>
<COMMENT>    Description: Truncates each column to the 'correct' length.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> trunc_col
    (
     )
      {
        <TYPE>int</TYPE> n;
        <TYPE>int</TYPE> i;
        CDTrans dtrans;

        n <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>size</OO>();
        <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> n; <OPERATOR>++</OPERATOR>i)
          {
            <TYPE>int</TYPE>[] ndtrans <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>int</TYPE>[<OBJ>m_spec</OBJ>.<OO>m_dtrans_ncols</OO>];
            dtrans <OPERATOR>=</OPERATOR> (CDTrans) <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>elementAt</OO>(i);
            <OBJ>System</OBJ>.<OO>arraycopy</OO>(<OBJ>dtrans</OBJ>.<OO>m_dtrans</OO>, <NUMERIC>0</NUMERIC>, ndtrans, <NUMERIC>0</NUMERIC>, <OBJ>ndtrans</OBJ>.<OO>length</OO>);
            <OBJ>dtrans</OBJ>.<OO>m_dtrans</OO> <OPERATOR>=</OPERATOR> ndtrans;
          }
      }
  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: row_copy</COMMENT>
<COMMENT>    Description: Copies source row into destination row.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> row_copy
    (
     <TYPE>int</TYPE> dest,
     <TYPE>int</TYPE> src
     )
      {
        CDTrans dtrans;

        dtrans <OPERATOR>=</OPERATOR> (CDTrans) <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>elementAt</OO>(src);
        <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>setElementAt</OO>(dtrans,dest);
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: col_equiv</COMMENT>
<COMMENT>    Description:</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>boolean</TYPE> col_equiv
    (
     <TYPE>int</TYPE> col1,
     <TYPE>int</TYPE> col2
     )
      {
        <TYPE>int</TYPE> n;
        <TYPE>int</TYPE> i;
        CDTrans dtrans;

        n <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>size</OO>();
        <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> n; <OPERATOR>++</OPERATOR>i)
          {
            dtrans <OPERATOR>=</OPERATOR> (CDTrans) <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>elementAt</OO>(i);
            <KEYWORD>if</KEYWORD> (<OBJ>dtrans</OBJ>.<OO>m_dtrans</OO>[col1] <OPERATOR>!=</OPERATOR> <OBJ>dtrans</OBJ>.<OO>m_dtrans</OO>[col2])
              {
                <KEYWORD>return</KEYWORD> <KEYWORD>false</KEYWORD>;
              }
          }

        <KEYWORD>return</KEYWORD> <KEYWORD>true</KEYWORD>;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: row_equiv</COMMENT>
<COMMENT>    Description:</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>boolean</TYPE> row_equiv
    (
     <TYPE>int</TYPE> row1,
     <TYPE>int</TYPE> row2
     )
      {
        <TYPE>int</TYPE> i;
        CDTrans dtrans1;
        CDTrans dtrans2;

        dtrans1 <OPERATOR>=</OPERATOR> (CDTrans) <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>elementAt</OO>(row1);
        dtrans2 <OPERATOR>=</OPERATOR> (CDTrans) <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>elementAt</OO>(row2);

        <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dtrans_ncols</OO>; <OPERATOR>++</OPERATOR>i)
          {
            <KEYWORD>if</KEYWORD> (<OBJ>dtrans1</OBJ>.<OO>m_dtrans</OO>[i] <OPERATOR>!=</OPERATOR> <OBJ>dtrans2</OBJ>.<OO>m_dtrans</OO>[i])
              {
                <KEYWORD>return</KEYWORD> <KEYWORD>false</KEYWORD>;
              }
          }

        <KEYWORD>return</KEYWORD> <KEYWORD>true</KEYWORD>;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: reduce</COMMENT>
<COMMENT>    Description:</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> reduce
    (
     )
      {
        <TYPE>int</TYPE> i;
        <TYPE>int</TYPE> j;
        <TYPE>int</TYPE> k;
        <TYPE>int</TYPE> nrows;
        <TYPE>int</TYPE> reduced_ncols;
        <TYPE>int</TYPE> reduced_nrows;
        SparseBitSet set;
        CDTrans dtrans;
        <TYPE>int</TYPE> size;

        set <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> SparseBitSet();

        <COMMENT>/* Save accept nodes and anchor entries. */</COMMENT>
        size <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>size</OO>();
        <OBJ>m_spec</OBJ>.<OO>m_anchor_array</OO> <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>int</TYPE>[size];
        <OBJ>m_spec</OBJ>.<OO>m_accept_vector</OO> <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Vector</TYPE>();
        <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> size; <OPERATOR>++</OPERATOR>i)
          {
            dtrans <OPERATOR>=</OPERATOR> (CDTrans) <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>elementAt</OO>(i);
            <OBJ>m_spec</OBJ>.<OO>m_accept_vector</OO>.<OO>addElement</OO>(<OBJ>dtrans</OBJ>.<OO>m_accept</OO>);
            <OBJ>m_spec</OBJ>.<OO>m_anchor_array</OO>[i] <OPERATOR>=</OPERATOR> <OBJ>dtrans</OBJ>.<OO>m_anchor</OO>;
            <OBJ>dtrans</OBJ>.<OO>m_accept</OO> <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
          }

        <COMMENT>/* Allocate column map. */</COMMENT>
        <OBJ>m_spec</OBJ>.<OO>m_col_map</OO> <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>int</TYPE>[<OBJ>m_spec</OBJ>.<OO>m_dtrans_ncols</OO>];
        <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dtrans_ncols</OO>; <OPERATOR>++</OPERATOR>i)
          {
            <OBJ>m_spec</OBJ>.<OO>m_col_map</OO>[i] <OPERATOR>=</OPERATOR> <OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC>;
          }

        <COMMENT>/* Process columns for reduction. */</COMMENT>
        <KEYWORD>for</KEYWORD> (reduced_ncols <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; ; <OPERATOR>++</OPERATOR>reduced_ncols)
          {
            <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
              {
                <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> reduced_ncols; <OPERATOR>++</OPERATOR>i)
                  {
                    <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC> <OPERATOR>!=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_col_map</OO>[i]);
                  }
              }

            <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> reduced_ncols; i <OPERATOR>&lt;</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dtrans_ncols</OO>; <OPERATOR>++</OPERATOR>i)
              {
                <KEYWORD>if</KEYWORD> (<OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_col_map</OO>[i])
                  {
                    <KEYWORD>break</KEYWORD>;
                  }
              }

            <KEYWORD>if</KEYWORD> (i <OPERATOR>&gt;=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dtrans_ncols</OO>)
              {
                <KEYWORD>break</KEYWORD>;
              }

            <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
              {
                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>set</OBJ>.<OO>get</OO>(i));
                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_col_map</OO>[i]);
              }

            <OBJ>set</OBJ>.<OO>set</OO>(i);

            <OBJ>m_spec</OBJ>.<OO>m_col_map</OO>[i] <OPERATOR>=</OPERATOR> reduced_ncols;

            <COMMENT>/* UNDONE: Optimize by doing all comparisons in one batch. */</COMMENT>
            <KEYWORD>for</KEYWORD> (j <OPERATOR>=</OPERATOR> i <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>; j <OPERATOR>&lt;</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dtrans_ncols</OO>; <OPERATOR>++</OPERATOR>j)
              {
                <KEYWORD>if</KEYWORD> (<OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_col_map</OO>[j] <OPERATOR>&amp;&amp;</OPERATOR> <KEYWORD>true</KEYWORD> <OPERATOR>==</OPERATOR> col_equiv(i,j))
                  {
                    <OBJ>m_spec</OBJ>.<OO>m_col_map</OO>[j] <OPERATOR>=</OPERATOR> reduced_ncols;
                  }
              }
          }

        <COMMENT>/* Reduce columns. */</COMMENT>
        k <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
        <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dtrans_ncols</OO>; <OPERATOR>++</OPERATOR>i)
          {
            <KEYWORD>if</KEYWORD> (<OBJ>set</OBJ>.<OO>get</OO>(i))
              {
                <OPERATOR>++</OPERATOR>k;

                <OBJ>set</OBJ>.<OO>clear</OO>(i);

                j <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_col_map</OO>[i];

                <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
                  {
                    <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(j <OPERATOR>&lt;=</OPERATOR> i);
                  }

                <KEYWORD>if</KEYWORD> (j <OPERATOR>==</OPERATOR> i)
                  {
                    <KEYWORD>continue</KEYWORD>;
                  }

                col_copy(j,i);
              }
          }
        <OBJ>m_spec</OBJ>.<OO>m_dtrans_ncols</OO> <OPERATOR>=</OPERATOR> reduced_ncols;
        <COMMENT>/* truncate m_dtrans at proper length (freeing extra) */</COMMENT>
        trunc_col();

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(k <OPERATOR>==</OPERATOR> reduced_ncols);
          }

        <COMMENT>/* Allocate row map. */</COMMENT>
        nrows <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>size</OO>();
        <OBJ>m_spec</OBJ>.<OO>m_row_map</OO> <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>int</TYPE>[nrows];
        <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> nrows; <OPERATOR>++</OPERATOR>i)
          {
            <OBJ>m_spec</OBJ>.<OO>m_row_map</OO>[i] <OPERATOR>=</OPERATOR> <OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC>;
          }

        <COMMENT>/* Process rows to reduce. */</COMMENT>
        <KEYWORD>for</KEYWORD> (reduced_nrows <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; ; <OPERATOR>++</OPERATOR>reduced_nrows)
          {
            <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
              {
                <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> reduced_nrows; <OPERATOR>++</OPERATOR>i)
                  {
                    <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC> <OPERATOR>!=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_row_map</OO>[i]);
                  }
              }

            <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> reduced_nrows; i <OPERATOR>&lt;</OPERATOR> nrows; <OPERATOR>++</OPERATOR>i)
              {
                <KEYWORD>if</KEYWORD> (<OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_row_map</OO>[i])
                  {
                    <KEYWORD>break</KEYWORD>;
                  }
              }

            <KEYWORD>if</KEYWORD> (i <OPERATOR>&gt;=</OPERATOR> nrows)
              {
                <KEYWORD>break</KEYWORD>;
              }

            <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
              {
                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>set</OBJ>.<OO>get</OO>(i));
                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_row_map</OO>[i]);
              }

            <OBJ>set</OBJ>.<OO>set</OO>(i);

            <OBJ>m_spec</OBJ>.<OO>m_row_map</OO>[i] <OPERATOR>=</OPERATOR> reduced_nrows;

            <COMMENT>/* UNDONE: Optimize by doing all comparisons in one batch. */</COMMENT>
            <KEYWORD>for</KEYWORD> (j <OPERATOR>=</OPERATOR> i <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>; j <OPERATOR>&lt;</OPERATOR> nrows; <OPERATOR>++</OPERATOR>j)
              {
                <KEYWORD>if</KEYWORD> (<OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_row_map</OO>[j] <OPERATOR>&amp;&amp;</OPERATOR> <KEYWORD>true</KEYWORD> <OPERATOR>==</OPERATOR> row_equiv(i,j))
                  {
                    <OBJ>m_spec</OBJ>.<OO>m_row_map</OO>[j] <OPERATOR>=</OPERATOR> reduced_nrows;
                  }
              }
          }

        <COMMENT>/* Reduce rows. */</COMMENT>
        k <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
        <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> nrows; <OPERATOR>++</OPERATOR>i)
          {
            <KEYWORD>if</KEYWORD> (<OBJ>set</OBJ>.<OO>get</OO>(i))
              {
                <OPERATOR>++</OPERATOR>k;

                <OBJ>set</OBJ>.<OO>clear</OO>(i);

                j <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_row_map</OO>[i];

                <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
                  {
                    <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(j <OPERATOR>&lt;=</OPERATOR> i);
                  }

                <KEYWORD>if</KEYWORD> (j <OPERATOR>==</OPERATOR> i)
                  {
                    <KEYWORD>continue</KEYWORD>;
                  }

                row_copy(j,i);
              }
          }
        <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>setSize</OO>(reduced_nrows);

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <COMMENT>/*System.out.println("k = " + k + "\nreduced_nrows = " + reduced_nrows + "");*/</COMMENT>
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(k <OPERATOR>==</OPERATOR> reduced_nrows);
          }
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: fix_dtrans</COMMENT>
<COMMENT>    Description: Updates CDTrans table after minimization</COMMENT>
<COMMENT>    using groups, removing redundant transition table states.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> fix_dtrans
    (
     )
      {
        <TYPE>Vector</TYPE> new_vector;
        <TYPE>int</TYPE> i;
        <TYPE>int</TYPE> size;
        <TYPE>Vector</TYPE> dtrans_group;
        CDTrans first;
        <TYPE>int</TYPE> c;

        new_vector <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Vector</TYPE>();

        size <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_state_dtrans</OO>.<OO>length</OO>;
        <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> size; <OPERATOR>++</OPERATOR>i)
          {
            <KEYWORD>if</KEYWORD> (<OBJ>CDTrans</OBJ>.<OO>F</OO> <OPERATOR>!=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_state_dtrans</OO>[i])
              {
                <OBJ>m_spec</OBJ>.<OO>m_state_dtrans</OO>[i] <OPERATOR>=</OPERATOR> m_ingroup[<OBJ>m_spec</OBJ>.<OO>m_state_dtrans</OO>[i]];
              }
          }

        size <OPERATOR>=</OPERATOR> <OBJ>m_group</OBJ>.<OO>size</OO>();
        <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> size; <OPERATOR>++</OPERATOR>i)
          {
            dtrans_group <OPERATOR>=</OPERATOR> (<TYPE>Vector</TYPE>) <OBJ>m_group</OBJ>.<OO>elementAt</OO>(i);
            first <OPERATOR>=</OPERATOR> (CDTrans) <OBJ>dtrans_group</OBJ>.<OO>elementAt</OO>(<NUMERIC>0</NUMERIC>);
            <OBJ>new_vector</OBJ>.<OO>addElement</OO>(first);

            <KEYWORD>for</KEYWORD> (c <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; c <OPERATOR>&lt;</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dtrans_ncols</OO>; <OPERATOR>++</OPERATOR>c)
              {
                <KEYWORD>if</KEYWORD> (<OBJ>CDTrans</OBJ>.<OO>F</OO> <OPERATOR>!=</OPERATOR> <OBJ>first</OBJ>.<OO>m_dtrans</OO>[c])
                  {
                    <OBJ>first</OBJ>.<OO>m_dtrans</OO>[c] <OPERATOR>=</OPERATOR> m_ingroup[<OBJ>first</OBJ>.<OO>m_dtrans</OO>[c]];
                  }
              }
          }

        m_group <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO> <OPERATOR>=</OPERATOR> new_vector;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: minimize</COMMENT>
<COMMENT>    Description: Removes redundant transition table states.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> minimize
    (
     )
      {
        <TYPE>Vector</TYPE> dtrans_group;
        <TYPE>Vector</TYPE> new_group;
        <TYPE>int</TYPE> i;
        <TYPE>int</TYPE> j;
        <TYPE>int</TYPE> old_group_count;
        <TYPE>int</TYPE> group_count;
        CDTrans next;
        CDTrans first;
        <TYPE>int</TYPE> goto_first;
        <TYPE>int</TYPE> goto_next;
        <TYPE>int</TYPE> c;
        <TYPE>int</TYPE> group_size;
        <TYPE>boolean</TYPE> added;

        init_groups();

        group_count <OPERATOR>=</OPERATOR> <OBJ>m_group</OBJ>.<OO>size</OO>();
        old_group_count <OPERATOR>=</OPERATOR> group_count <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>;

        <KEYWORD>while</KEYWORD> (old_group_count <OPERATOR>!=</OPERATOR> group_count)
          {
            old_group_count <OPERATOR>=</OPERATOR> group_count;

            <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
              {
                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>m_group</OBJ>.<OO>size</OO>() <OPERATOR>==</OPERATOR> group_count);
              }

            <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> group_count; <OPERATOR>++</OPERATOR>i)
              {
                dtrans_group <OPERATOR>=</OPERATOR> (<TYPE>Vector</TYPE>) <OBJ>m_group</OBJ>.<OO>elementAt</OO>(i);

                group_size <OPERATOR>=</OPERATOR> <OBJ>dtrans_group</OBJ>.<OO>size</OO>();
                <KEYWORD>if</KEYWORD> (group_size <OPERATOR>&lt;=</OPERATOR> <NUMERIC>1</NUMERIC>)
                  {
                    <KEYWORD>continue</KEYWORD>;
                  }

                new_group <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Vector</TYPE>();
                added <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;

                first <OPERATOR>=</OPERATOR> (CDTrans) <OBJ>dtrans_group</OBJ>.<OO>elementAt</OO>(<NUMERIC>0</NUMERIC>);
                <KEYWORD>for</KEYWORD> (j <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC>; j <OPERATOR>&lt;</OPERATOR> group_size; <OPERATOR>++</OPERATOR>j)
                  {
                    next <OPERATOR>=</OPERATOR> (CDTrans) <OBJ>dtrans_group</OBJ>.<OO>elementAt</OO>(j);

                    <KEYWORD>for</KEYWORD> (c <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; c <OPERATOR>&lt;</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dtrans_ncols</OO>; <OPERATOR>++</OPERATOR>c)
                      {
                        goto_first <OPERATOR>=</OPERATOR> <OBJ>first</OBJ>.<OO>m_dtrans</OO>[c];
                        goto_next <OPERATOR>=</OPERATOR> <OBJ>next</OBJ>.<OO>m_dtrans</OO>[c];

                        <KEYWORD>if</KEYWORD> (goto_first <OPERATOR>!=</OPERATOR> goto_next
                            <OPERATOR>&amp;&amp;</OPERATOR> (goto_first <OPERATOR>==</OPERATOR> <OBJ>CDTrans</OBJ>.<OO>F</OO>
                                <OPERATOR>||</OPERATOR> goto_next <OPERATOR>==</OPERATOR> <OBJ>CDTrans</OBJ>.<OO>F</OO>
                                <OPERATOR>||</OPERATOR> m_ingroup[goto_next] <OPERATOR>!=</OPERATOR> m_ingroup[goto_first]))
                          {
                            <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
                              {
                                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>dtrans_group</OBJ>.<OO>elementAt</OO>(j) <OPERATOR>==</OPERATOR> next);
                              }

                            <OBJ>dtrans_group</OBJ>.<OO>removeElementAt</OO>(j);
                            <OPERATOR>--</OPERATOR>j;
                            <OPERATOR>--</OPERATOR>group_size;
                            <OBJ>new_group</OBJ>.<OO>addElement</OO>(next);
                            <KEYWORD>if</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> added)
                              {
                                added <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
                                <OPERATOR>++</OPERATOR>group_count;
                                <OBJ>m_group</OBJ>.<OO>addElement</OO>(new_group);
                              }
                            m_ingroup[<OBJ>next</OBJ>.<OO>m_label</OO>] <OPERATOR>=</OPERATOR> <OBJ>m_group</OBJ>.<OO>size</OO>() <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>;

                            <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
                              {
                                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>m_group</OBJ>.<OO>contains</OO>(new_group)
                                                <OPERATOR>==</OPERATOR> <KEYWORD>true</KEYWORD>);
                                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>m_group</OBJ>.<OO>contains</OO>(dtrans_group)
                                                <OPERATOR>==</OPERATOR> <KEYWORD>true</KEYWORD>);
                                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>dtrans_group</OBJ>.<OO>contains</OO>(first)
                                                <OPERATOR>==</OPERATOR> <KEYWORD>true</KEYWORD>);
                                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>dtrans_group</OBJ>.<OO>contains</OO>(next)
                                                <OPERATOR>==</OPERATOR> <KEYWORD>false</KEYWORD>);
                                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>new_group</OBJ>.<OO>contains</OO>(first)
                                                <OPERATOR>==</OPERATOR> <KEYWORD>false</KEYWORD>);
                                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>new_group</OBJ>.<OO>contains</OO>(next)
                                                <OPERATOR>==</OPERATOR> <KEYWORD>true</KEYWORD>);
                                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>dtrans_group</OBJ>.<OO>size</OO>() <OPERATOR>==</OPERATOR> group_size);
                                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(i <OPERATOR>==</OPERATOR> m_ingroup[<OBJ>first</OBJ>.<OO>m_label</OO>]);
                                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>((<OBJ>m_group</OBJ>.<OO>size</OO>() <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>)
                                                <OPERATOR>==</OPERATOR> m_ingroup[<OBJ>next</OBJ>.<OO>m_label</OO>]);
                              }

                            <KEYWORD>break</KEYWORD>;
                          }
                      }
                  }
              }
          }

        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<OBJ>m_group</OBJ>.<OO>size</OO>() <OPERATOR>+</OPERATOR> <STRING>" states after removal of redundant states."</STRING>);

        <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_verbose</OO>
            <OPERATOR>&amp;&amp;</OPERATOR> <KEYWORD>true</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>OLD_DUMP_DEBUG</OO>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>();
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"States grouped as follows after minimization"</STRING>);
            pgroups();
          }

        fix_dtrans();
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: init_groups</COMMENT>
<COMMENT>    Description:</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> init_groups
    (
     )
      {
        <TYPE>int</TYPE> i;
        <TYPE>int</TYPE> j;
        <TYPE>int</TYPE> group_count;
        <TYPE>int</TYPE> size;
        CAccept accept;
        CDTrans dtrans;
        <TYPE>Vector</TYPE> dtrans_group;
        CDTrans first;
        <TYPE>boolean</TYPE> group_found;

        m_group <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Vector</TYPE>();
        group_count <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;

        size <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>size</OO>();
        m_ingroup <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>int</TYPE>[size];

        <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> size; <OPERATOR>++</OPERATOR>i)
          {
            group_found <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
            dtrans <OPERATOR>=</OPERATOR> (CDTrans) <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>elementAt</OO>(i);

            <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
              {
                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(i <OPERATOR>==</OPERATOR> <OBJ>dtrans</OBJ>.<OO>m_label</OO>);
                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> group_found);
                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(group_count <OPERATOR>==</OPERATOR> <OBJ>m_group</OBJ>.<OO>size</OO>());
              }

            <KEYWORD>for</KEYWORD> (j <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; j <OPERATOR>&lt;</OPERATOR> group_count; <OPERATOR>++</OPERATOR>j)
              {
                dtrans_group <OPERATOR>=</OPERATOR> (<TYPE>Vector</TYPE>) <OBJ>m_group</OBJ>.<OO>elementAt</OO>(j);

                <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
                  {
                    <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> group_found);
                    <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<NUMERIC>0</NUMERIC> <OPERATOR>&lt;</OPERATOR> <OBJ>dtrans_group</OBJ>.<OO>size</OO>());
                  }

                first <OPERATOR>=</OPERATOR> (CDTrans) <OBJ>dtrans_group</OBJ>.<OO>elementAt</OO>(<NUMERIC>0</NUMERIC>);

                <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>SLOW_DEBUG</OO>)
                  {
                    CDTrans check;
                    <TYPE>int</TYPE> k;
                    <TYPE>int</TYPE> s;

                    s <OPERATOR>=</OPERATOR> <OBJ>dtrans_group</OBJ>.<OO>size</OO>();
                    <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<NUMERIC>0</NUMERIC> <OPERATOR>&lt;</OPERATOR> s);

                    <KEYWORD>for</KEYWORD> (k <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC>; k <OPERATOR>&lt;</OPERATOR> s; <OPERATOR>++</OPERATOR>k)
                      {
                        check <OPERATOR>=</OPERATOR> (CDTrans) <OBJ>dtrans_group</OBJ>.<OO>elementAt</OO>(k);
                        <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>check</OBJ>.<OO>m_accept</OO> <OPERATOR>==</OPERATOR> <OBJ>first</OBJ>.<OO>m_accept</OO>);
                      }
                  }

                <KEYWORD>if</KEYWORD> (<OBJ>first</OBJ>.<OO>m_accept</OO> <OPERATOR>==</OPERATOR> <OBJ>dtrans</OBJ>.<OO>m_accept</OO>)
                  {
                    <OBJ>dtrans_group</OBJ>.<OO>addElement</OO>(dtrans);
                    m_ingroup[i] <OPERATOR>=</OPERATOR> j;
                    group_found <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;

                    <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
                      {
                        <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(j <OPERATOR>==</OPERATOR> m_ingroup[<OBJ>dtrans</OBJ>.<OO>m_label</OO>]);
                      }

                    <KEYWORD>break</KEYWORD>;
                  }
              }

            <KEYWORD>if</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> group_found)
              {
                dtrans_group <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Vector</TYPE>();
                <OBJ>dtrans_group</OBJ>.<OO>addElement</OO>(dtrans);
                m_ingroup[i] <OPERATOR>=</OPERATOR> <OBJ>m_group</OBJ>.<OO>size</OO>();
                <OBJ>m_group</OBJ>.<OO>addElement</OO>(dtrans_group);
                <OPERATOR>++</OPERATOR>group_count;
              }
          }

        <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_verbose</OO>
            <OPERATOR>&amp;&amp;</OPERATOR> <KEYWORD>true</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>OLD_DUMP_DEBUG</OO>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Initial grouping:"</STRING>);
            pgroups();
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>();
          }
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: pset</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> pset
    (
     <TYPE>Vector</TYPE> dtrans_group
     )
      {
        <TYPE>int</TYPE> i;
        <TYPE>int</TYPE> size;
        CDTrans dtrans;

        size <OPERATOR>=</OPERATOR> <OBJ>dtrans_group</OBJ>.<OO>size</OO>();
        <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> size; <OPERATOR>++</OPERATOR>i)
          {
            dtrans <OPERATOR>=</OPERATOR> (CDTrans) <OBJ>dtrans_group</OBJ>.<OO>elementAt</OO>(i);
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<OBJ>dtrans</OBJ>.<OO>m_label</OO> <OPERATOR>+</OPERATOR> <STRING>" "</STRING>);
          }
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: pgroups</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> pgroups
    (
     )
      {
        <TYPE>int</TYPE> i;
        <TYPE>int</TYPE> dtrans_size;
        <TYPE>int</TYPE> group_size;

        group_size <OPERATOR>=</OPERATOR> <OBJ>m_group</OBJ>.<OO>size</OO>();
        <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> group_size; <OPERATOR>++</OPERATOR>i)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>"<ESC>\t</ESC>Group "</STRING> <OPERATOR>+</OPERATOR> i <OPERATOR>+</OPERATOR> <STRING>" {"</STRING>);
            pset((<TYPE>Vector</TYPE>) <OBJ>m_group</OBJ>.<OO>elementAt</OO>(i));
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"}"</STRING>);
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>();
          }

        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>();
        dtrans_size <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>size</OO>();
        <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> dtrans_size; <OPERATOR>++</OPERATOR>i)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>state "</STRING> <OPERATOR>+</OPERATOR> i
                               <OPERATOR>+</OPERATOR> <STRING>" is in group "</STRING>
                               <OPERATOR>+</OPERATOR> m_ingroup[i]);
          }
      }
}

<COMMENT>/***************************************************************</COMMENT>
<COMMENT>  Class: CNfa2Dfa</COMMENT>
<COMMENT> **************************************************************/</COMMENT>
<KEYWORD>class</KEYWORD> CNfa2Dfa
{
  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Member Variables</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> CSpec m_spec;
  <KEYWORD>private</KEYWORD> <TYPE>int</TYPE> m_unmarked_dfa;
  <KEYWORD>private</KEYWORD> CLexGen m_lexGen;

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Constants</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>NOT_IN_DSTATES</CONSTANT> <OPERATOR>=</OPERATOR> <OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC>;

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: CNfa2Dfa</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  CNfa2Dfa
    (
     )
      {
        reset();
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: set</COMMENT>
<COMMENT>    Description:</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> set
    (
     CLexGen lexGen,
     CSpec spec
     )
      {
        m_lexGen <OPERATOR>=</OPERATOR> lexGen;
        m_spec <OPERATOR>=</OPERATOR> spec;
        m_unmarked_dfa <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: reset</COMMENT>
<COMMENT>    Description:</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> reset
    (
     )
      {
        m_lexGen <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_spec <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_unmarked_dfa <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: make_dfa</COMMENT>
<COMMENT>    Description: High-level access function to module.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <TYPE>void</TYPE> make_dfa
    (
     CLexGen lexGen,
     CSpec spec
     )
      {
        <TYPE>int</TYPE> i;

        reset();
        set(lexGen,spec);

        make_dtrans();
        free_nfa_states();

        <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_verbose</OO> <OPERATOR>&amp;&amp;</OPERATOR> <KEYWORD>true</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>OLD_DUMP_DEBUG</OO>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<OBJ>m_spec</OBJ>.<OO>m_dfa_states</OO>.<OO>size</OO>()
                               <OPERATOR>+</OPERATOR> <STRING>" DFA states in original machine."</STRING>);
          }

        free_dfa_states();
      }

   <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: make_dtrans</COMMENT>
<COMMENT>    Description: Creates uncompressed CDTrans transition table.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> make_dtrans
    (
     )
     <COMMENT>/* throws java.lang.CloneNotSupportedException*/</COMMENT>
      {
        CDfa next;
        CDfa dfa;
        CBunch bunch;
        <TYPE>int</TYPE> i;
        <TYPE>int</TYPE> nextstate;
        <TYPE>int</TYPE> size;
        CDTrans dtrans;
        CNfa nfa;
        <TYPE>int</TYPE> istate;
        <TYPE>int</TYPE> nstates;

        <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>"Working on DFA states."</STRING>);

        <COMMENT>/* Reference passing type and initializations. */</COMMENT>
        bunch <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> CBunch();
        m_unmarked_dfa <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;

        <COMMENT>/* Allocate mapping array. */</COMMENT>
        nstates <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_state_rules</OO>.<OO>length</OO>;
        <OBJ>m_spec</OBJ>.<OO>m_state_dtrans</OO> <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>int</TYPE>[nstates];

        <KEYWORD>for</KEYWORD> (istate <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; nstates <OPERATOR>&gt;</OPERATOR> istate; <OPERATOR>++</OPERATOR>istate)
          {
            <COMMENT>/* CSA bugfix: if we skip all zero size rules, then</COMMENT>
<COMMENT>               an specification with no rules produces an illegal</COMMENT>
<COMMENT>               lexer (0 states) instead of a lexer that rejects</COMMENT>
<COMMENT>               everything (1 nonaccepting state). [27-Jul-1999]</COMMENT>
<COMMENT>            if (0 == m_spec.m_state_rules[istate].size())</COMMENT>
<COMMENT>              {</COMMENT>
<COMMENT>                m_spec.m_state_dtrans[istate] = CDTrans.F;</COMMENT>
<COMMENT>                continue;</COMMENT>
<COMMENT>              }</COMMENT>
<COMMENT>            */</COMMENT>

            <COMMENT>/* Create start state and initialize fields. */</COMMENT>
            <OBJ>bunch</OBJ>.<OO>m_nfa_set</OO> <OPERATOR>=</OPERATOR> (<TYPE>Vector</TYPE>) <OBJ>m_spec</OBJ>.<OO>m_state_rules</OO>[istate].clone();
            sortStates(<OBJ>bunch</OBJ>.<OO>m_nfa_set</OO>);

            <OBJ>bunch</OBJ>.<OO>m_nfa_bit</OO> <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> SparseBitSet();

            <COMMENT>/* Initialize bit set. */</COMMENT>
            size <OPERATOR>=</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_nfa_set</OO>.<OO>size</OO>();
            <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; size <OPERATOR>&gt;</OPERATOR> i; <OPERATOR>++</OPERATOR>i)
              {
                nfa <OPERATOR>=</OPERATOR> (CNfa) <OBJ>bunch</OBJ>.<OO>m_nfa_set</OO>.<OO>elementAt</OO>(i);
                <OBJ>bunch</OBJ>.<OO>m_nfa_bit</OO>.<OO>set</OO>(<OBJ>nfa</OBJ>.<OO>m_label</OO>);
              }

            <OBJ>bunch</OBJ>.<OO>m_accept</OO> <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
            <OBJ>bunch</OBJ>.<OO>m_anchor</OO> <OPERATOR>=</OPERATOR> <OBJ>CSpec</OBJ>.<OO>NONE</OO>;
            <OBJ>bunch</OBJ>.<OO>m_accept_index</OO> <OPERATOR>=</OPERATOR> <OBJ>CUtility</OBJ>.<OO>INT_MAX</OO>;

            e_closure(bunch);
            add_to_dstates(bunch);

            <OBJ>m_spec</OBJ>.<OO>m_state_dtrans</OO>[istate] <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>size</OO>();

            <COMMENT>/* Main loop of CDTrans creation. */</COMMENT>
            <KEYWORD>while</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> (dfa <OPERATOR>=</OPERATOR> get_unmarked()))
              {
                <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>"."</STRING>);
                <OBJ>System</OBJ>.<OO>out</OO>.<OO>flush</OO>();

                <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
                  {
                    <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>dfa</OBJ>.<OO>m_mark</OO>);
                  }

                <COMMENT>/* Get first unmarked node, then mark it. */</COMMENT>
                <OBJ>dfa</OBJ>.<OO>m_mark</OO> <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;

                <COMMENT>/* Allocate new CDTrans, then initialize fields. */</COMMENT>
                dtrans <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> CDTrans(<OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>size</OO>(),m_spec);
                <OBJ>dtrans</OBJ>.<OO>m_accept</OO> <OPERATOR>=</OPERATOR> <OBJ>dfa</OBJ>.<OO>m_accept</OO>;
                <OBJ>dtrans</OBJ>.<OO>m_anchor</OO> <OPERATOR>=</OPERATOR> <OBJ>dfa</OBJ>.<OO>m_anchor</OO>;

                <COMMENT>/* Set CDTrans array for each character transition. */</COMMENT>
                <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dtrans_ncols</OO>; <OPERATOR>++</OPERATOR>i)
                  {
                    <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
                      {
                        <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<NUMERIC>0</NUMERIC> <OPERATOR>&lt;=</OPERATOR> i);
                        <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>m_spec</OBJ>.<OO>m_dtrans_ncols</OO> <OPERATOR>&gt;</OPERATOR> i);
                      }

                    <COMMENT>/* Create new dfa set by attempting character transition. */</COMMENT>
                    move(<OBJ>dfa</OBJ>.<OO>m_nfa_set</OO>,<OBJ>dfa</OBJ>.<OO>m_nfa_bit</OO>,i,bunch);
                    <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_nfa_set</OO>)
                      {
                        e_closure(bunch);
                      }

                    <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
                      {
                        <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>((<KEYWORD>null</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_nfa_set</OO>
                                         <OPERATOR>&amp;&amp;</OPERATOR> <KEYWORD>null</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_nfa_bit</OO>)
                                        <OPERATOR>||</OPERATOR> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_nfa_set</OO>
                                            <OPERATOR>&amp;&amp;</OPERATOR> <KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_nfa_bit</OO>));
                      }

                    <COMMENT>/* Create new state or set state to empty. */</COMMENT>
                    <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_nfa_set</OO>)
                      {
                        nextstate <OPERATOR>=</OPERATOR> <OBJ>CDTrans</OBJ>.<OO>F</OO>;
                      }
                    <KEYWORD>else</KEYWORD>
                      {
                        nextstate <OPERATOR>=</OPERATOR> in_dstates(bunch);

                        <KEYWORD>if</KEYWORD> (<CONSTANT>NOT_IN_DSTATES</CONSTANT> <OPERATOR>==</OPERATOR> nextstate)
                          {
                            nextstate <OPERATOR>=</OPERATOR> add_to_dstates(bunch);
                          }
                      }

                    <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
                      {
                        <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(nextstate <OPERATOR>&lt;</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dfa_states</OO>.<OO>size</OO>());
                      }

                    <OBJ>dtrans</OBJ>.<OO>m_dtrans</OO>[i] <OPERATOR>=</OPERATOR> nextstate;
                  }

                <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
                  {
                    <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>size</OO>() <OPERATOR>==</OPERATOR> <OBJ>dfa</OBJ>.<OO>m_label</OO>);
                  }

                <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>addElement</OO>(dtrans);
              }
          }

        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>();
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: free_dfa_states</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> free_dfa_states
    (
     )
      {
        <OBJ>m_spec</OBJ>.<OO>m_dfa_states</OO> <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        <OBJ>m_spec</OBJ>.<OO>m_dfa_sets</OO> <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: free_nfa_states</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> free_nfa_states
    (
     )
      {
        <COMMENT>/* UNDONE: Remove references to nfas from within dfas. */</COMMENT>
        <COMMENT>/* UNDONE: Don't free CAccepts. */</COMMENT>

        <OBJ>m_spec</OBJ>.<OO>m_nfa_states</OO> <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        <OBJ>m_spec</OBJ>.<OO>m_nfa_start</OO> <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        <OBJ>m_spec</OBJ>.<OO>m_state_rules</OO> <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: e_closure</COMMENT>
<COMMENT>    Description: Alters and returns input set.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> e_closure
    (
     CBunch bunch
     )
      {
        <TYPE>Stack</TYPE> nfa_stack;
        <TYPE>int</TYPE> size;
        <TYPE>int</TYPE> i;
        CNfa state;

        <COMMENT>/* Debug checks. */</COMMENT>
        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> bunch);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_nfa_set</OO>);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_nfa_bit</OO>);
          }

        <OBJ>bunch</OBJ>.<OO>m_accept</OO> <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        <OBJ>bunch</OBJ>.<OO>m_anchor</OO> <OPERATOR>=</OPERATOR> <OBJ>CSpec</OBJ>.<OO>NONE</OO>;
        <OBJ>bunch</OBJ>.<OO>m_accept_index</OO> <OPERATOR>=</OPERATOR> <OBJ>CUtility</OBJ>.<OO>INT_MAX</OO>;

        <COMMENT>/* Create initial stack. */</COMMENT>
        nfa_stack <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Stack</TYPE>();
        size <OPERATOR>=</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_nfa_set</OO>.<OO>size</OO>();
        <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> size; <OPERATOR>++</OPERATOR>i)
          {
            state <OPERATOR>=</OPERATOR> (CNfa) <OBJ>bunch</OBJ>.<OO>m_nfa_set</OO>.<OO>elementAt</OO>(i);

            <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
              {
                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>bunch</OBJ>.<OO>m_nfa_bit</OO>.<OO>get</OO>(<OBJ>state</OBJ>.<OO>m_label</OO>));
              }

            <OBJ>nfa_stack</OBJ>.<OO>push</OO>(state);
          }

        <COMMENT>/* Main loop. */</COMMENT>
        <KEYWORD>while</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>nfa_stack</OBJ>.<OO>empty</OO>())
          {
            state <OPERATOR>=</OPERATOR> (CNfa) <OBJ>nfa_stack</OBJ>.<OO>pop</OO>();

            <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>OLD_DUMP_DEBUG</OO>)
              {
                <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>state</OBJ>.<OO>m_accept</OO>)
                  {
                    <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Looking at accepting state "</STRING> <OPERATOR>+</OPERATOR> <OBJ>state</OBJ>.<OO>m_label</OO>
                                       <OPERATOR>+</OPERATOR> <STRING>" with &lt;"</STRING>
                                       <OPERATOR>+</OPERATOR> (<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>state</OBJ>.<OO>m_accept</OO>.<OO>m_action</OO>,<NUMERIC>0</NUMERIC>,
                                                     <OBJ>state</OBJ>.<OO>m_accept</OO>.<OO>m_action_read</OO>))
                                       <OPERATOR>+</OPERATOR> <STRING>"&gt;"</STRING>);
                  }
              }

            <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>state</OBJ>.<OO>m_accept</OO>
                <OPERATOR>&amp;&amp;</OPERATOR> <OBJ>state</OBJ>.<OO>m_label</OO> <OPERATOR>&lt;</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_accept_index</OO>)
              {
                <OBJ>bunch</OBJ>.<OO>m_accept_index</OO> <OPERATOR>=</OPERATOR> <OBJ>state</OBJ>.<OO>m_label</OO>;
                <OBJ>bunch</OBJ>.<OO>m_accept</OO> <OPERATOR>=</OPERATOR> <OBJ>state</OBJ>.<OO>m_accept</OO>;
                <OBJ>bunch</OBJ>.<OO>m_anchor</OO> <OPERATOR>=</OPERATOR> <OBJ>state</OBJ>.<OO>m_anchor</OO>;

                <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>OLD_DUMP_DEBUG</OO>)
                  {
                    <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Found accepting state "</STRING> <OPERATOR>+</OPERATOR> <OBJ>state</OBJ>.<OO>m_label</OO>
                                       <OPERATOR>+</OPERATOR> <STRING>" with &lt;"</STRING>
                                       <OPERATOR>+</OPERATOR> (<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>state</OBJ>.<OO>m_accept</OO>.<OO>m_action</OO>,<NUMERIC>0</NUMERIC>,
                                                     <OBJ>state</OBJ>.<OO>m_accept</OO>.<OO>m_action_read</OO>))
                                       <OPERATOR>+</OPERATOR> <STRING>"&gt;"</STRING>);
                  }

                <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
                  {
                    <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_accept</OO>);
                    <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>CSpec</OBJ>.<OO>NONE</OO> <OPERATOR>==</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_anchor</OO>
                                    <OPERATOR>||</OPERATOR> <NUMERIC>0</NUMERIC> <OPERATOR>!=</OPERATOR> (<OBJ>bunch</OBJ>.<OO>m_anchor</OO> <OPERATOR>&amp;</OPERATOR> <OBJ>CSpec</OBJ>.<OO>END</OO>)
                                    <OPERATOR>||</OPERATOR> <NUMERIC>0</NUMERIC> <OPERATOR>!=</OPERATOR> (<OBJ>bunch</OBJ>.<OO>m_anchor</OO> <OPERATOR>&amp;</OPERATOR> <OBJ>CSpec</OBJ>.<OO>START</OO>));
                  }
              }

            <KEYWORD>if</KEYWORD> (<OBJ>CNfa</OBJ>.<OO>EPSILON</OO> <OPERATOR>==</OPERATOR> <OBJ>state</OBJ>.<OO>m_edge</OO>)
              {
                <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>state</OBJ>.<OO>m_next</OO>)
                  {
                    <KEYWORD>if</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_nfa_set</OO>.<OO>contains</OO>(<OBJ>state</OBJ>.<OO>m_next</OO>))
                      {
                        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
                          {
                            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_nfa_bit</OO>.<OO>get</OO>(<OBJ>state</OBJ>.<OO>m_next</OO>.<OO>m_label</OO>));
                          }

                        <OBJ>bunch</OBJ>.<OO>m_nfa_bit</OO>.<OO>set</OO>(<OBJ>state</OBJ>.<OO>m_next</OO>.<OO>m_label</OO>);
                        <OBJ>bunch</OBJ>.<OO>m_nfa_set</OO>.<OO>addElement</OO>(<OBJ>state</OBJ>.<OO>m_next</OO>);
                        <OBJ>nfa_stack</OBJ>.<OO>push</OO>(<OBJ>state</OBJ>.<OO>m_next</OO>);
                      }
                  }

                <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>state</OBJ>.<OO>m_next2</OO>)
                  {
                    <KEYWORD>if</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_nfa_set</OO>.<OO>contains</OO>(<OBJ>state</OBJ>.<OO>m_next2</OO>))
                      {
                        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
                          {
                            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_nfa_bit</OO>.<OO>get</OO>(<OBJ>state</OBJ>.<OO>m_next2</OO>.<OO>m_label</OO>));
                          }

                        <OBJ>bunch</OBJ>.<OO>m_nfa_bit</OO>.<OO>set</OO>(<OBJ>state</OBJ>.<OO>m_next2</OO>.<OO>m_label</OO>);
                        <OBJ>bunch</OBJ>.<OO>m_nfa_set</OO>.<OO>addElement</OO>(<OBJ>state</OBJ>.<OO>m_next2</OO>);
                        <OBJ>nfa_stack</OBJ>.<OO>push</OO>(<OBJ>state</OBJ>.<OO>m_next2</OO>);
                      }
                  }
              }
          }

        <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_nfa_set</OO>)
          {
            sortStates(<OBJ>bunch</OBJ>.<OO>m_nfa_set</OO>);
          }

        <KEYWORD>return</KEYWORD>;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: move</COMMENT>
<COMMENT>    Description: Returns null if resulting NFA set is empty.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <TYPE>void</TYPE> move
    (
     <TYPE>Vector</TYPE> nfa_set,
     SparseBitSet nfa_bit,
     <TYPE>int</TYPE> b,
     CBunch bunch
     )
      {
        <TYPE>int</TYPE> size;
        <TYPE>int</TYPE> index;
        CNfa state;

        <OBJ>bunch</OBJ>.<OO>m_nfa_set</OO> <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        <OBJ>bunch</OBJ>.<OO>m_nfa_bit</OO> <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;

        size <OPERATOR>=</OPERATOR> <OBJ>nfa_set</OBJ>.<OO>size</OO>();
        <KEYWORD>for</KEYWORD> (index <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; index <OPERATOR>&lt;</OPERATOR> size; <OPERATOR>++</OPERATOR>index)
          {
            state <OPERATOR>=</OPERATOR> (CNfa) <OBJ>nfa_set</OBJ>.<OO>elementAt</OO>(index);

            <KEYWORD>if</KEYWORD> (b <OPERATOR>==</OPERATOR> <OBJ>state</OBJ>.<OO>m_edge</OO>
                <OPERATOR>||</OPERATOR> (<OBJ>CNfa</OBJ>.<OO>CCL</OO> <OPERATOR>==</OPERATOR> <OBJ>state</OBJ>.<OO>m_edge</OO>
                    <OPERATOR>&amp;&amp;</OPERATOR> <KEYWORD>true</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>state</OBJ>.<OO>m_set</OO>.<OO>contains</OO>(b)))
              {
                <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_nfa_set</OO>)
                  {
                    <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
                      {
                        <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_nfa_bit</OO>);
                      }

                    <OBJ>bunch</OBJ>.<OO>m_nfa_set</OO> <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Vector</TYPE>();
                    <COMMENT>/*bunch.m_nfa_bit</COMMENT>
<COMMENT>                        = new SparseBitSet(m_spec.m_nfa_states.size());*/</COMMENT>
                    <OBJ>bunch</OBJ>.<OO>m_nfa_bit</OO> <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> SparseBitSet();
                  }

                <OBJ>bunch</OBJ>.<OO>m_nfa_set</OO>.<OO>addElement</OO>(<OBJ>state</OBJ>.<OO>m_next</OO>);
                <COMMENT>/*System.out.println("Size of bitset: " + bunch.m_nfa_bit.size());</COMMENT>
<COMMENT>                System.out.println("Reference index: " + state.m_next.m_label);</COMMENT>
<COMMENT>                System.out.flush();*/</COMMENT>
                <OBJ>bunch</OBJ>.<OO>m_nfa_bit</OO>.<OO>set</OO>(<OBJ>state</OBJ>.<OO>m_next</OO>.<OO>m_label</OO>);
              }
          }

        <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_nfa_set</OO>)
          {
            <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
              {
                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_nfa_bit</OO>);
              }

            sortStates(<OBJ>bunch</OBJ>.<OO>m_nfa_set</OO>);
          }

        <KEYWORD>return</KEYWORD>;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: sortStates</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> sortStates
    (
     <TYPE>Vector</TYPE> nfa_set
     )
      {
        CNfa elem;
        <TYPE>int</TYPE> begin;
        <TYPE>int</TYPE> size;
        <TYPE>int</TYPE> index;
        <TYPE>int</TYPE> value;
        <TYPE>int</TYPE> smallest_index;
        <TYPE>int</TYPE> smallest_value;
        CNfa begin_elem;

        size <OPERATOR>=</OPERATOR> <OBJ>nfa_set</OBJ>.<OO>size</OO>();
        <KEYWORD>for</KEYWORD> (begin <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; begin <OPERATOR>&lt;</OPERATOR> size; <OPERATOR>++</OPERATOR>begin)
          {
            elem <OPERATOR>=</OPERATOR> (CNfa) <OBJ>nfa_set</OBJ>.<OO>elementAt</OO>(begin);
            smallest_value <OPERATOR>=</OPERATOR> <OBJ>elem</OBJ>.<OO>m_label</OO>;
            smallest_index <OPERATOR>=</OPERATOR> begin;

            <KEYWORD>for</KEYWORD> (index <OPERATOR>=</OPERATOR> begin <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>; index <OPERATOR>&lt;</OPERATOR> size; <OPERATOR>++</OPERATOR>index)
              {
                elem <OPERATOR>=</OPERATOR> (CNfa) <OBJ>nfa_set</OBJ>.<OO>elementAt</OO>(index);
                value <OPERATOR>=</OPERATOR> <OBJ>elem</OBJ>.<OO>m_label</OO>;

                <KEYWORD>if</KEYWORD> (value <OPERATOR>&lt;</OPERATOR> smallest_value)
                  {
                    smallest_index <OPERATOR>=</OPERATOR> index;
                    smallest_value <OPERATOR>=</OPERATOR> value;
                  }
              }

            begin_elem <OPERATOR>=</OPERATOR> (CNfa) <OBJ>nfa_set</OBJ>.<OO>elementAt</OO>(begin);
            elem <OPERATOR>=</OPERATOR> (CNfa) <OBJ>nfa_set</OBJ>.<OO>elementAt</OO>(smallest_index);
            <OBJ>nfa_set</OBJ>.<OO>setElementAt</OO>(elem,begin);
            <OBJ>nfa_set</OBJ>.<OO>setElementAt</OO>(begin_elem,smallest_index);
          }

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>OLD_DEBUG</OO>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>"NFA vector indices: "</STRING>);

            <KEYWORD>for</KEYWORD> (index <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; index <OPERATOR>&lt;</OPERATOR> size; <OPERATOR>++</OPERATOR>index)
              {
                elem <OPERATOR>=</OPERATOR> (CNfa) <OBJ>nfa_set</OBJ>.<OO>elementAt</OO>(index);
                <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<OBJ>elem</OBJ>.<OO>m_label</OO> <OPERATOR>+</OPERATOR> <STRING>" "</STRING>);
              }
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>();
          }

        <KEYWORD>return</KEYWORD>;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: get_unmarked</COMMENT>
<COMMENT>    Description: Returns next unmarked DFA state.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> CDfa get_unmarked
    (
     )
      {
        <TYPE>int</TYPE> size;
        CDfa dfa;

        size <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dfa_states</OO>.<OO>size</OO>();
        <KEYWORD>while</KEYWORD> (m_unmarked_dfa <OPERATOR>&lt;</OPERATOR> size)
          {
            dfa <OPERATOR>=</OPERATOR> (CDfa) <OBJ>m_spec</OBJ>.<OO>m_dfa_states</OO>.<OO>elementAt</OO>(m_unmarked_dfa);

            <KEYWORD>if</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>dfa</OBJ>.<OO>m_mark</OO>)
              {
                <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>OLD_DUMP_DEBUG</OO>)
                  {
                    <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>"*"</STRING>);
                    <OBJ>System</OBJ>.<OO>out</OO>.<OO>flush</OO>();
                  }

                <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_verbose</OO> <OPERATOR>&amp;&amp;</OPERATOR> <KEYWORD>true</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>OLD_DUMP_DEBUG</OO>)
                  {
                    <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"---------------"</STRING>);
                    <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>"working on DFA state "</STRING>
                                     <OPERATOR>+</OPERATOR> m_unmarked_dfa
                                     <OPERATOR>+</OPERATOR> <STRING>" = NFA states: "</STRING>);
                    <OBJ>m_lexGen</OBJ>.<OO>print_set</OO>(<OBJ>dfa</OBJ>.<OO>m_nfa_set</OO>);
                    <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>();
                  }

                <KEYWORD>return</KEYWORD> dfa;
              }

            <OPERATOR>++</OPERATOR>m_unmarked_dfa;
          }

        <KEYWORD>return</KEYWORD> <KEYWORD>null</KEYWORD>;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    function: add_to_dstates</COMMENT>
<COMMENT>    Description: Takes as input a CBunch with details of</COMMENT>
<COMMENT>    a dfa state that needs to be created.</COMMENT>
<COMMENT>    1) Allocates a new dfa state and saves it in</COMMENT>
<COMMENT>    the appropriate CSpec vector.</COMMENT>
<COMMENT>    2) Initializes the fields of the dfa state</COMMENT>
<COMMENT>    with the information in the CBunch.</COMMENT>
<COMMENT>    3) Returns index of new dfa.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>int</TYPE> add_to_dstates
    (
     CBunch bunch
     )
      {
        CDfa dfa;

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_nfa_set</OO>);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_nfa_bit</OO>);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_accept</OO>
                            <OPERATOR>||</OPERATOR> <OBJ>CSpec</OBJ>.<OO>NONE</OO> <OPERATOR>==</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_anchor</OO>);
          }

        <COMMENT>/* Allocate, passing CSpec so dfa label can be set. */</COMMENT>
        dfa <OPERATOR>=</OPERATOR> <OBJ>CAlloc</OBJ>.<OO>newCDfa</OO>(m_spec);

        <COMMENT>/* Initialize fields, including the mark field. */</COMMENT>
        <OBJ>dfa</OBJ>.<OO>m_nfa_set</OO> <OPERATOR>=</OPERATOR> (<TYPE>Vector</TYPE>) <OBJ>bunch</OBJ>.<OO>m_nfa_set</OO>.<OO>clone</OO>();
        <OBJ>dfa</OBJ>.<OO>m_nfa_bit</OO> <OPERATOR>=</OPERATOR> (SparseBitSet) <OBJ>bunch</OBJ>.<OO>m_nfa_bit</OO>.<OO>clone</OO>();
        <OBJ>dfa</OBJ>.<OO>m_accept</OO> <OPERATOR>=</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_accept</OO>;
        <OBJ>dfa</OBJ>.<OO>m_anchor</OO> <OPERATOR>=</OPERATOR> <OBJ>bunch</OBJ>.<OO>m_anchor</OO>;
        <OBJ>dfa</OBJ>.<OO>m_mark</OO> <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;

        <COMMENT>/* Register dfa state using BitSet in CSpec Hashtable. */</COMMENT>
        <OBJ>m_spec</OBJ>.<OO>m_dfa_sets</OO>.<OO>put</OO>(<OBJ>dfa</OBJ>.<OO>m_nfa_bit</OO>,dfa);
        <COMMENT>/*registerCDfa(dfa);*/</COMMENT>

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>OLD_DUMP_DEBUG</OO>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>"Registering set : "</STRING>);
            <OBJ>m_lexGen</OBJ>.<OO>print_set</OO>(<OBJ>dfa</OBJ>.<OO>m_nfa_set</OO>);
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>();
          }

        <KEYWORD>return</KEYWORD> <OBJ>dfa</OBJ>.<OO>m_label</OO>;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: in_dstates</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>int</TYPE> in_dstates
    (
     CBunch bunch
     )
      {
        CDfa dfa;

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>OLD_DEBUG</OO>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>"Looking for set : "</STRING>);
            <OBJ>m_lexGen</OBJ>.<OO>print_set</OO>(<OBJ>bunch</OBJ>.<OO>m_nfa_set</OO>);
          }

        dfa <OPERATOR>=</OPERATOR> (CDfa) <OBJ>m_spec</OBJ>.<OO>m_dfa_sets</OO>.<OO>get</OO>(<OBJ>bunch</OBJ>.<OO>m_nfa_bit</OO>);

        <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> dfa)
          {
            <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>OLD_DUMP_DEBUG</OO>)
              {
                <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>" FOUND!"</STRING>);
              }

            <KEYWORD>return</KEYWORD> <OBJ>dfa</OBJ>.<OO>m_label</OO>;
          }

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>OLD_DUMP_DEBUG</OO>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>" NOT FOUND!"</STRING>);
          }
        <KEYWORD>return</KEYWORD> <CONSTANT>NOT_IN_DSTATES</CONSTANT>;
      }

}

<COMMENT>/***************************************************************</COMMENT>
<COMMENT>  Class: CAlloc</COMMENT>
<COMMENT>  **************************************************************/</COMMENT>
<KEYWORD>class</KEYWORD> CAlloc
{
  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: newCDfa</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> CDfa newCDfa
    (
     CSpec spec
     )
      {
        CDfa dfa;

        dfa <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> CDfa(<OBJ>spec</OBJ>.<OO>m_dfa_states</OO>.<OO>size</OO>());
        <OBJ>spec</OBJ>.<OO>m_dfa_states</OO>.<OO>addElement</OO>(dfa);

        <KEYWORD>return</KEYWORD> dfa;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: newCNfaPair</COMMENT>
<COMMENT>    Description:</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> CNfaPair newCNfaPair
    (
     )
      {
        CNfaPair pair <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> CNfaPair();

        <KEYWORD>return</KEYWORD> pair;
      }
  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: newNLPair</COMMENT>
<COMMENT>    Description: return a new CNfaPair that matches a new</COMMENT>
<COMMENT>                 line: (\r\n?|[\n\uu2028\uu2029])</COMMENT>
<COMMENT>                 Added by CSA 8-Aug-1999, updated 10-Aug-1999</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> CNfaPair newNLPair(CSpec spec) {
    CNfaPair pair <OPERATOR>=</OPERATOR> newCNfaPair();
    <OBJ>pair</OBJ>.<OO>m_end</OO><OPERATOR>=</OPERATOR>newCNfa(spec); <COMMENT>// newline accepting state</COMMENT>
    <OBJ>pair</OBJ>.<OO>m_start</OO><OPERATOR>=</OPERATOR>newCNfa(spec); <COMMENT>// new state with two epsilon edges</COMMENT>
    <OBJ>pair</OBJ>.<OO>m_start</OO>.<OO>m_next</OO> <OPERATOR>=</OPERATOR> newCNfa(spec);
    <OBJ>pair</OBJ>.<OO>m_start</OO>.<OO>m_next</OO>.<OO>m_edge</OO> <OPERATOR>=</OPERATOR> <OBJ>CNfa</OBJ>.<OO>CCL</OO>;
    <OBJ>pair</OBJ>.<OO>m_start</OO>.<OO>m_next</OO>.<OO>m_set</OO> <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> CSet();
    <OBJ>pair</OBJ>.<OO>m_start</OO>.<OO>m_next</OO>.<OO>m_set</OO>.<OO>add</OO>(<CHARACTER>'<ESC>\n</ESC>'</CHARACTER>);
    <KEYWORD>if</KEYWORD> (<OBJ>spec</OBJ>.<OO>m_dtrans_ncols</OO><OPERATOR>-</OPERATOR><OBJ>CSpec</OBJ>.<OO>NUM_PSEUDO</OO> <OPERATOR>&gt;</OPERATOR> <NUMERIC>2029</NUMERIC>) {
      <OBJ>pair</OBJ>.<OO>m_start</OO>.<OO>m_next</OO>.<OO>m_set</OO>.<OO>add</OO>(<NUMERIC>2028</NUMERIC>); <COMMENT>/*U+2028 is LS, the line separator*/</COMMENT>
      <OBJ>pair</OBJ>.<OO>m_start</OO>.<OO>m_next</OO>.<OO>m_set</OO>.<OO>add</OO>(<NUMERIC>2029</NUMERIC>); <COMMENT>/*U+2029 is PS, the paragraph sep.*/</COMMENT>
    }
    <OBJ>pair</OBJ>.<OO>m_start</OO>.<OO>m_next</OO>.<OO>m_next</OO> <OPERATOR>=</OPERATOR> <OBJ>pair</OBJ>.<OO>m_end</OO>; <COMMENT>// accept '\n', U+2028, or U+2029</COMMENT>
    <OBJ>pair</OBJ>.<OO>m_start</OO>.<OO>m_next2</OO> <OPERATOR>=</OPERATOR> newCNfa(spec);
    <OBJ>pair</OBJ>.<OO>m_start</OO>.<OO>m_next2</OO>.<OO>m_edge</OO> <OPERATOR>=</OPERATOR> <CHARACTER>'<ESC>\r</ESC>'</CHARACTER>;
    <OBJ>pair</OBJ>.<OO>m_start</OO>.<OO>m_next2</OO>.<OO>m_next</OO> <OPERATOR>=</OPERATOR> newCNfa(spec);
    <OBJ>pair</OBJ>.<OO>m_start</OO>.<OO>m_next2</OO>.<OO>m_next</OO>.<OO>m_next</OO> <OPERATOR>=</OPERATOR> <OBJ>pair</OBJ>.<OO>m_end</OO>; <COMMENT>// accept '\r';</COMMENT>
    <OBJ>pair</OBJ>.<OO>m_start</OO>.<OO>m_next2</OO>.<OO>m_next</OO>.<OO>m_next2</OO> <OPERATOR>=</OPERATOR> newCNfa(spec);
    <OBJ>pair</OBJ>.<OO>m_start</OO>.<OO>m_next2</OO>.<OO>m_next</OO>.<OO>m_next2</OO>.<OO>m_edge</OO> <OPERATOR>=</OPERATOR> <CHARACTER>'<ESC>\n</ESC>'</CHARACTER>;
    <OBJ>pair</OBJ>.<OO>m_start</OO>.<OO>m_next2</OO>.<OO>m_next</OO>.<OO>m_next2</OO>.<OO>m_next</OO> <OPERATOR>=</OPERATOR> <OBJ>pair</OBJ>.<OO>m_end</OO>; <COMMENT>// accept '\r\n';</COMMENT>
    <KEYWORD>return</KEYWORD> pair;
  }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: newCNfa</COMMENT>
<COMMENT>    Description:</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> CNfa newCNfa
    (
     CSpec spec
     )
      {
        CNfa p;

        <COMMENT>/* UNDONE: Buffer this? */</COMMENT>

        p <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> CNfa();

        <COMMENT>/*p.m_label = spec.m_nfa_states.size();*/</COMMENT>
        <OBJ>spec</OBJ>.<OO>m_nfa_states</OO>.<OO>addElement</OO>(p);
        <OBJ>p</OBJ>.<OO>m_edge</OO> <OPERATOR>=</OPERATOR> <OBJ>CNfa</OBJ>.<OO>EPSILON</OO>;

        <KEYWORD>return</KEYWORD> p;
      }
}

<COMMENT>/***************************************************************</COMMENT>
<COMMENT>  Class: Main</COMMENT>
<COMMENT>  Description: Top-level lexical analyzer generator function.</COMMENT>
<COMMENT> **************************************************************/</COMMENT>
<KEYWORD>public</KEYWORD> <KEYWORD>class</KEYWORD> Main
{
  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: main</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>void</TYPE> main
    (
     <TYPE>String</TYPE> arg[]
     )
    <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
      {
        CLexGen lg;

        <KEYWORD>if</KEYWORD> (<OBJ>arg</OBJ>.<OO>length</OO> <OPERATOR>&lt;</OPERATOR> <NUMERIC>1</NUMERIC>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Usage: JLex.Main &lt;filename&gt;"</STRING>);
            <KEYWORD>return</KEYWORD>;
          }

        <COMMENT>/* Note: For debuging, it may be helpful to remove the try/catch</COMMENT>
<COMMENT>           block and permit the Exception to propagate to the top level.</COMMENT>
<COMMENT>           This gives more information. */</COMMENT>
        <KEYWORD>try</KEYWORD>
          {
            lg <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> CLexGen(arg[<NUMERIC>0</NUMERIC>]);
            <OBJ>lg</OBJ>.<OO>generate</OO>();
          }
        <KEYWORD>catch</KEYWORD> (<TYPE>Error</TYPE> e)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<OBJ>e</OBJ>.<OO>getMessage</OO>());
          }
      }
}

<COMMENT>/***************************************************************</COMMENT>
<COMMENT>  Class: CDTrans</COMMENT>
<COMMENT>  **************************************************************/</COMMENT>
<KEYWORD>class</KEYWORD> CDTrans
{
  <COMMENT>/*************************************************************</COMMENT>
<COMMENT>    Member Variables</COMMENT>
<COMMENT>    ***********************************************************/</COMMENT>
  <TYPE>int</TYPE> m_dtrans[];
  CAccept m_accept;
  <TYPE>int</TYPE> m_anchor;
  <TYPE>int</TYPE> m_label;

  <COMMENT>/*************************************************************</COMMENT>
<COMMENT>    Constants</COMMENT>
<COMMENT>    ***********************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> F <OPERATOR>=</OPERATOR> <OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC>;

  <COMMENT>/*************************************************************</COMMENT>
<COMMENT>    Function: CTrans</COMMENT>
<COMMENT>    ***********************************************************/</COMMENT>
  CDTrans
    (
     <TYPE>int</TYPE> label,
     CSpec spec
     )
      {
        m_dtrans <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>int</TYPE>[<OBJ>spec</OBJ>.<OO>m_dtrans_ncols</OO>];
        m_accept <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_anchor <OPERATOR>=</OPERATOR> <OBJ>CSpec</OBJ>.<OO>NONE</OO>;
        m_label <OPERATOR>=</OPERATOR> label;
      }
}

<COMMENT>/***************************************************************</COMMENT>
<COMMENT>  Class: CDfa</COMMENT>
<COMMENT>  **************************************************************/</COMMENT>
<KEYWORD>class</KEYWORD> CDfa
{
  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Member Variables</COMMENT>
<COMMENT>    ***********************************************************/</COMMENT>
  <TYPE>int</TYPE> m_group;
  <TYPE>boolean</TYPE> m_mark;
  CAccept m_accept;
  <TYPE>int</TYPE> m_anchor;
  <TYPE>Vector</TYPE> m_nfa_set;
  SparseBitSet m_nfa_bit;
  <TYPE>int</TYPE> m_label;

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: CDfa</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  CDfa
    (
     <TYPE>int</TYPE> label
     )
      {
        m_group <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
        m_mark <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;

        m_accept <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_anchor <OPERATOR>=</OPERATOR> <OBJ>CSpec</OBJ>.<OO>NONE</OO>;

        m_nfa_set <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_nfa_bit <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;

        m_label <OPERATOR>=</OPERATOR> label;
      }
}

<COMMENT>/***************************************************************</COMMENT>
<COMMENT>  Class: CAccept</COMMENT>
<COMMENT> **************************************************************/</COMMENT>
<KEYWORD>class</KEYWORD> CAccept
{
  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Member Variables</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <TYPE>char</TYPE> m_action[];
  <TYPE>int</TYPE> m_action_read;
  <TYPE>int</TYPE> m_line_number;

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: CAccept</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  CAccept
    (
     <TYPE>char</TYPE> action[],
     <TYPE>int</TYPE> action_read,
     <TYPE>int</TYPE> line_number
     )
      {
        <TYPE>int</TYPE> elem;

        m_action_read <OPERATOR>=</OPERATOR> action_read;

        m_action <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>char</TYPE>[m_action_read];
        <KEYWORD>for</KEYWORD> (elem <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; elem <OPERATOR>&lt;</OPERATOR> m_action_read; <OPERATOR>++</OPERATOR>elem)
          {
            m_action[elem] <OPERATOR>=</OPERATOR> action[elem];
          }

        m_line_number <OPERATOR>=</OPERATOR> line_number;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: CAccept</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  CAccept
    (
     CAccept accept
     )
      {
        <TYPE>int</TYPE> elem;

        m_action_read <OPERATOR>=</OPERATOR> <OBJ>accept</OBJ>.<OO>m_action_read</OO>;

        m_action <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>char</TYPE>[m_action_read];
        <KEYWORD>for</KEYWORD> (elem <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; elem <OPERATOR>&lt;</OPERATOR> m_action_read; <OPERATOR>++</OPERATOR>elem)
          {
            m_action[elem] <OPERATOR>=</OPERATOR> <OBJ>accept</OBJ>.<OO>m_action</OO>[elem];
          }

        m_line_number <OPERATOR>=</OPERATOR> <OBJ>accept</OBJ>.<OO>m_line_number</OO>;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: mimic</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <TYPE>void</TYPE> mimic
    (
     CAccept accept
     )
      {
        <TYPE>int</TYPE> elem;

        m_action_read <OPERATOR>=</OPERATOR> <OBJ>accept</OBJ>.<OO>m_action_read</OO>;

        m_action <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>char</TYPE>[m_action_read];
        <KEYWORD>for</KEYWORD> (elem <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; elem <OPERATOR>&lt;</OPERATOR> m_action_read; <OPERATOR>++</OPERATOR>elem)
          {
            m_action[elem] <OPERATOR>=</OPERATOR> <OBJ>accept</OBJ>.<OO>m_action</OO>[elem];
          }
      }
}

<COMMENT>/***************************************************************</COMMENT>
<COMMENT>  Class: CAcceptAnchor</COMMENT>
<COMMENT>  **************************************************************/</COMMENT>
<KEYWORD>class</KEYWORD> CAcceptAnchor
{
  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Member Variables</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  CAccept m_accept;
  <TYPE>int</TYPE> m_anchor;

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: CAcceptAnchor</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  CAcceptAnchor
    (
     )
      {
        m_accept <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_anchor <OPERATOR>=</OPERATOR> <OBJ>CSpec</OBJ>.<OO>NONE</OO>;
      }
}

<COMMENT>/***************************************************************</COMMENT>
<COMMENT>  Class: CNfaPair</COMMENT>
<COMMENT>  **************************************************************/</COMMENT>
<KEYWORD>class</KEYWORD> CNfaPair
{
  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Member Variables</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  CNfa m_start;
  CNfa m_end;

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: CNfaPair</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  CNfaPair
    (
     )
      {
        m_start <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_end <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
      }
}

<COMMENT>/***************************************************************</COMMENT>
<COMMENT>  Class: CInput</COMMENT>
<COMMENT>  Description:</COMMENT>
<COMMENT> **************************************************************/</COMMENT>
<KEYWORD>class</KEYWORD> CInput
{
  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Member Variables</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>BufferedReader</OO> m_input; <COMMENT>/* JLex specification file. */</COMMENT>

  <TYPE>boolean</TYPE> m_eof_reached; <COMMENT>/* Whether EOF has been encountered. */</COMMENT>
  <TYPE>boolean</TYPE> m_pushback_line;

  <TYPE>char</TYPE> m_line[]; <COMMENT>/* Line buffer. */</COMMENT>
  <TYPE>int</TYPE> m_line_read; <COMMENT>/* Number of bytes read into line buffer. */</COMMENT>
  <TYPE>int</TYPE> m_line_index; <COMMENT>/* Current index into line buffer. */</COMMENT>

  <TYPE>int</TYPE> m_line_number; <COMMENT>/* Current line number. */</COMMENT>

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Constants</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>boolean</TYPE> EOF <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>boolean</TYPE> <CONSTANT>NOT_EOF</CONSTANT> <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: CInput</COMMENT>
<COMMENT>    Description:</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  CInput
    (
     <OBJ>java</OBJ>.<OO>io</OO>.<OO>Reader</OO> input
     )
      {
        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> input);
          }

        <COMMENT>/* Initialize input stream. */</COMMENT>
        m_input <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>BufferedReader</OO>(input);

        <COMMENT>/* Initialize buffers and index counters. */</COMMENT>
        m_line <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
        m_line_read <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
        m_line_index <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;

        <COMMENT>/* Initialize state variables. */</COMMENT>
        m_eof_reached <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
        m_line_number <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
        m_pushback_line <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: getLine</COMMENT>
<COMMENT>    Description: Returns true on EOF, false otherwise.</COMMENT>
<COMMENT>    Guarantees not to return a blank line, or a line</COMMENT>
<COMMENT>    of zero length.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <TYPE>boolean</TYPE> getLine
    (
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
      {
        <TYPE>String</TYPE> lineStr;
        <TYPE>int</TYPE> elem;

        <COMMENT>/* Has EOF already been reached? */</COMMENT>
        <KEYWORD>if</KEYWORD> (m_eof_reached)
          {
            <KEYWORD>return</KEYWORD> EOF;
          }

        <COMMENT>/* Pushback current line? */</COMMENT>
        <KEYWORD>if</KEYWORD> (m_pushback_line)
          {
            m_pushback_line <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;

            <COMMENT>/* Check for empty line. */</COMMENT>
            <KEYWORD>for</KEYWORD> (elem <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; elem <OPERATOR>&lt;</OPERATOR> m_line_read; <OPERATOR>++</OPERATOR>elem)
              {
                <KEYWORD>if</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>isspace</OO>(m_line[elem]))
                  {
                    <KEYWORD>break</KEYWORD>;
                  }
              }

            <COMMENT>/* Nonempty? */</COMMENT>
            <KEYWORD>if</KEYWORD> (elem <OPERATOR>&lt;</OPERATOR> m_line_read)
              {
                m_line_index <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
                <KEYWORD>return</KEYWORD> <CONSTANT>NOT_EOF</CONSTANT>;
              }
          }

        <KEYWORD>while</KEYWORD> (<KEYWORD>true</KEYWORD>)
          {
            <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>==</OPERATOR> (lineStr <OPERATOR>=</OPERATOR> <OBJ>m_input</OBJ>.<OO>readLine</OO>()))
              {
                m_eof_reached <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
                m_line_index <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
                <KEYWORD>return</KEYWORD> EOF;
              }
            m_line <OPERATOR>=</OPERATOR> (lineStr <OPERATOR>+</OPERATOR> <STRING>"<ESC>\n</ESC>"</STRING>).toCharArray();
            m_line_read<OPERATOR>=</OPERATOR><OBJ>m_line</OBJ>.<OO>length</OO>;
            <OPERATOR>++</OPERATOR>m_line_number;

            <COMMENT>/* Check for empty lines and discard them. */</COMMENT>
            elem <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
            <KEYWORD>while</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>isspace</OO>(m_line[elem]))
              {
                <OPERATOR>++</OPERATOR>elem;
                <KEYWORD>if</KEYWORD> (elem <OPERATOR>==</OPERATOR> m_line_read)
                  {
                    <KEYWORD>break</KEYWORD>;
                  }
              }

            <KEYWORD>if</KEYWORD> (elem <OPERATOR>&lt;</OPERATOR> m_line_read)
              {
                <KEYWORD>break</KEYWORD>;
              }
          }

        m_line_index <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
        <KEYWORD>return</KEYWORD> <CONSTANT>NOT_EOF</CONSTANT>;
      }
}

<COMMENT>/********************************************************</COMMENT>
<COMMENT>  Class: Utility</COMMENT>
<COMMENT>  *******************************************************/</COMMENT>
<KEYWORD>class</KEYWORD> CUtility
{
  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Constants</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>boolean</TYPE> <CONSTANT>DEBUG</CONSTANT> <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>boolean</TYPE> <CONSTANT>SLOW_DEBUG</CONSTANT> <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>boolean</TYPE> <CONSTANT>DUMP_DEBUG</CONSTANT> <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
  <COMMENT>/*static final boolean DEBUG = false;</COMMENT>
<COMMENT>  static final boolean SLOW_DEBUG = false;</COMMENT>
<COMMENT>  static final boolean DUMP_DEBUG = false;*/</COMMENT>
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>boolean</TYPE> <CONSTANT>DESCENT_DEBUG</CONSTANT> <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>boolean</TYPE> <CONSTANT>OLD_DEBUG</CONSTANT> <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>boolean</TYPE> <CONSTANT>OLD_DUMP_DEBUG</CONSTANT> <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>boolean</TYPE> <CONSTANT>FOODEBUG</CONSTANT> <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>boolean</TYPE> <CONSTANT>DO_DEBUG</CONSTANT> <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Constants: Integer Bounds</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>INT_MAX</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>2147483647</NUMERIC>;

  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>MAX_SEVEN_BIT</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>127</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>MAX_EIGHT_BIT</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>255</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>MAX_SIXTEEN_BIT</CONSTANT><OPERATOR>=</OPERATOR><NUMERIC>65535</NUMERIC>;

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: enter</COMMENT>
<COMMENT>    Description: Debugging routine.</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <TYPE>void</TYPE> enter
    (
     <TYPE>String</TYPE> descent,
     <TYPE>char</TYPE> lexeme,
     <TYPE>int</TYPE> token
     )
      {
        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Entering "</STRING> <OPERATOR>+</OPERATOR> descent
                           <OPERATOR>+</OPERATOR> <STRING>" [lexeme: "</STRING> <OPERATOR>+</OPERATOR> lexeme
                           <OPERATOR>+</OPERATOR> <STRING>"] [token: "</STRING> <OPERATOR>+</OPERATOR> token <OPERATOR>+</OPERATOR> <STRING>"]"</STRING>);
      }

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: leave</COMMENT>
<COMMENT>    Description: Debugging routine.</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <TYPE>void</TYPE> leave
    (
     <TYPE>String</TYPE> descent,
     <TYPE>char</TYPE> lexeme,
     <TYPE>int</TYPE> token
     )
      {
        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Leaving "</STRING> <OPERATOR>+</OPERATOR> descent
                           <OPERATOR>+</OPERATOR> <STRING>" [lexeme:"</STRING> <OPERATOR>+</OPERATOR> lexeme
                           <OPERATOR>+</OPERATOR> <STRING>"] [token:"</STRING> <OPERATOR>+</OPERATOR> token <OPERATOR>+</OPERATOR> <STRING>"]"</STRING>);
      }

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: ASSERT</COMMENT>
<COMMENT>    Description: Debugging routine.</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <TYPE>void</TYPE> <CONSTANT>ASSERT</CONSTANT>
    (
     <TYPE>boolean</TYPE> expr
     )
      {
        <KEYWORD>if</KEYWORD> (<CONSTANT>DEBUG</CONSTANT> <OPERATOR>&amp;&amp;</OPERATOR> <KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> expr)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Assertion Failed"</STRING>);
            <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> <TYPE>Error</TYPE>(<STRING>"Assertion Failed."</STRING>);
          }
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: doubleSize</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <TYPE>char</TYPE>[] doubleSize
    (
     <TYPE>char</TYPE> oldBuffer[]
     )
      {
        <TYPE>char</TYPE> newBuffer[] <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>char</TYPE>[<NUMERIC>2</NUMERIC> <OPERATOR>*</OPERATOR> <OBJ>oldBuffer</OBJ>.<OO>length</OO>];
        <TYPE>int</TYPE> elem;

        <KEYWORD>for</KEYWORD> (elem <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; elem <OPERATOR>&lt;</OPERATOR> <OBJ>oldBuffer</OBJ>.<OO>length</OO>; <OPERATOR>++</OPERATOR>elem)
          {
            newBuffer[elem] <OPERATOR>=</OPERATOR> oldBuffer[elem];
          }

        <KEYWORD>return</KEYWORD> newBuffer;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: doubleSize</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <TYPE>byte</TYPE>[] doubleSize
    (
     <TYPE>byte</TYPE> oldBuffer[]
     )
      {
        <TYPE>byte</TYPE> newBuffer[] <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>byte</TYPE>[<NUMERIC>2</NUMERIC> <OPERATOR>*</OPERATOR> <OBJ>oldBuffer</OBJ>.<OO>length</OO>];
        <TYPE>int</TYPE> elem;

        <KEYWORD>for</KEYWORD> (elem <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; elem <OPERATOR>&lt;</OPERATOR> <OBJ>oldBuffer</OBJ>.<OO>length</OO>; <OPERATOR>++</OPERATOR>elem)
          {
            newBuffer[elem] <OPERATOR>=</OPERATOR> oldBuffer[elem];
          }

        <KEYWORD>return</KEYWORD> newBuffer;
      }

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: hex2bin</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <TYPE>char</TYPE> hex2bin
    (
     <TYPE>char</TYPE> c
     )
      {
        <KEYWORD>if</KEYWORD> (<CHARACTER>'0'</CHARACTER> <OPERATOR>&lt;=</OPERATOR> c <OPERATOR>&amp;&amp;</OPERATOR> <CHARACTER>'9'</CHARACTER> <OPERATOR>&gt;=</OPERATOR> c)
          {
            <KEYWORD>return</KEYWORD> (<TYPE>char</TYPE>) (c <OPERATOR>-</OPERATOR> <CHARACTER>'0'</CHARACTER>);
          }
        <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (<CHARACTER>'a'</CHARACTER> <OPERATOR>&lt;=</OPERATOR> c <OPERATOR>&amp;&amp;</OPERATOR> <CHARACTER>'f'</CHARACTER> <OPERATOR>&gt;=</OPERATOR> c)
          {
            <KEYWORD>return</KEYWORD> (<TYPE>char</TYPE>) (c <OPERATOR>-</OPERATOR> <CHARACTER>'a'</CHARACTER> <OPERATOR>+</OPERATOR> <NUMERIC>10</NUMERIC>);
          }
        <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (<CHARACTER>'A'</CHARACTER> <OPERATOR>&lt;=</OPERATOR> c <OPERATOR>&amp;&amp;</OPERATOR> <CHARACTER>'F'</CHARACTER> <OPERATOR>&gt;=</OPERATOR> c)
          {
            <KEYWORD>return</KEYWORD> (<TYPE>char</TYPE>) (c <OPERATOR>-</OPERATOR> <CHARACTER>'A'</CHARACTER> <OPERATOR>+</OPERATOR> <NUMERIC>10</NUMERIC>);
          }

        <OBJ>CError</OBJ>.<OO>impos</OO>(<STRING>"Bad hexidecimal digit"</STRING> <OPERATOR>+</OPERATOR> c);
        <KEYWORD>return</KEYWORD> <NUMERIC>0</NUMERIC>;
      }

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: ishexdigit</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <TYPE>boolean</TYPE> ishexdigit
    (
     <TYPE>char</TYPE> c
     )
      {
        <KEYWORD>if</KEYWORD> ((<CHARACTER>'0'</CHARACTER> <OPERATOR>&lt;=</OPERATOR> c <OPERATOR>&amp;&amp;</OPERATOR> <CHARACTER>'9'</CHARACTER> <OPERATOR>&gt;=</OPERATOR> c)
            <OPERATOR>||</OPERATOR> (<CHARACTER>'a'</CHARACTER> <OPERATOR>&lt;=</OPERATOR> c <OPERATOR>&amp;&amp;</OPERATOR> <CHARACTER>'f'</CHARACTER> <OPERATOR>&gt;=</OPERATOR> c)
            <OPERATOR>||</OPERATOR> (<CHARACTER>'A'</CHARACTER> <OPERATOR>&lt;=</OPERATOR> c <OPERATOR>&amp;&amp;</OPERATOR> <CHARACTER>'F'</CHARACTER> <OPERATOR>&gt;=</OPERATOR> c))
          {
            <KEYWORD>return</KEYWORD> <KEYWORD>true</KEYWORD>;
          }

        <KEYWORD>return</KEYWORD> <KEYWORD>false</KEYWORD>;
      }

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: oct2bin</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <TYPE>char</TYPE> oct2bin
    (
     <TYPE>char</TYPE> c
     )
      {
        <KEYWORD>if</KEYWORD> (<CHARACTER>'0'</CHARACTER> <OPERATOR>&lt;=</OPERATOR> c <OPERATOR>&amp;&amp;</OPERATOR> <CHARACTER>'7'</CHARACTER> <OPERATOR>&gt;=</OPERATOR> c)
          {
            <KEYWORD>return</KEYWORD> (<TYPE>char</TYPE>) (c <OPERATOR>-</OPERATOR> <CHARACTER>'0'</CHARACTER>);
          }

        <OBJ>CError</OBJ>.<OO>impos</OO>(<STRING>"Bad octal digit "</STRING> <OPERATOR>+</OPERATOR> c);
        <KEYWORD>return</KEYWORD> <NUMERIC>0</NUMERIC>;
      }

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: isoctdigit</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <TYPE>boolean</TYPE> isoctdigit
    (
     <TYPE>char</TYPE> c
     )
      {
        <KEYWORD>if</KEYWORD> (<CHARACTER>'0'</CHARACTER> <OPERATOR>&lt;=</OPERATOR> c <OPERATOR>&amp;&amp;</OPERATOR> <CHARACTER>'7'</CHARACTER> <OPERATOR>&gt;=</OPERATOR> c)
          {
            <KEYWORD>return</KEYWORD> <KEYWORD>true</KEYWORD>;
          }

        <KEYWORD>return</KEYWORD> <KEYWORD>false</KEYWORD>;
      }

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: isspace</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <TYPE>boolean</TYPE> isspace
    (
     <TYPE>char</TYPE> c
     )
      {
        <KEYWORD>if</KEYWORD> (<CHARACTER>'<ESC>\b</ESC>'</CHARACTER> <OPERATOR>==</OPERATOR> c
            <OPERATOR>||</OPERATOR> <CHARACTER>'<ESC>\t</ESC>'</CHARACTER> <OPERATOR>==</OPERATOR> c
            <OPERATOR>||</OPERATOR> <CHARACTER>'<ESC>\n</ESC>'</CHARACTER> <OPERATOR>==</OPERATOR> c
            <OPERATOR>||</OPERATOR> <CHARACTER>'<ESC>\f</ESC>'</CHARACTER> <OPERATOR>==</OPERATOR> c
            <OPERATOR>||</OPERATOR> <CHARACTER>'<ESC>\r</ESC>'</CHARACTER> <OPERATOR>==</OPERATOR> c
            <OPERATOR>||</OPERATOR> <CHARACTER>' '</CHARACTER> <OPERATOR>==</OPERATOR> c)
          {
            <KEYWORD>return</KEYWORD> <KEYWORD>true</KEYWORD>;
          }

        <KEYWORD>return</KEYWORD> <KEYWORD>false</KEYWORD>;
      }

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: isnewline</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <TYPE>boolean</TYPE> isnewline
    (
     <TYPE>char</TYPE> c
     )
      {
        <KEYWORD>if</KEYWORD> (<CHARACTER>'<ESC>\n</ESC>'</CHARACTER> <OPERATOR>==</OPERATOR> c
            <OPERATOR>||</OPERATOR> <CHARACTER>'<ESC>\r</ESC>'</CHARACTER> <OPERATOR>==</OPERATOR> c)
            {
            <KEYWORD>return</KEYWORD> <KEYWORD>true</KEYWORD>;
          }

        <KEYWORD>return</KEYWORD> <KEYWORD>false</KEYWORD>;
      }

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: bytencmp</COMMENT>
<COMMENT>    Description: Compares up to n elements of</COMMENT>
<COMMENT>    byte array a[] against byte array b[].</COMMENT>
<COMMENT>    The first byte comparison is made between</COMMENT>
<COMMENT>    a[a_first] and b[b_first].  Comparisons continue</COMMENT>
<COMMENT>    until the null terminating byte '\0' is reached</COMMENT>
<COMMENT>    or until n bytes are compared.</COMMENT>
<COMMENT>    Return Value: Returns 0 if arrays are the</COMMENT>
<COMMENT>    same up to and including the null terminating byte</COMMENT>
<COMMENT>    or up to and including the first n bytes,</COMMENT>
<COMMENT>    whichever comes first.</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <TYPE>int</TYPE> bytencmp
    (
     <TYPE>byte</TYPE> a[],
     <TYPE>int</TYPE> a_first,
     <TYPE>byte</TYPE> b[],
     <TYPE>int</TYPE> b_first,
     <TYPE>int</TYPE> n
     )
      {
        <TYPE>int</TYPE> elem;

        <KEYWORD>for</KEYWORD> (elem <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; elem <OPERATOR>&lt;</OPERATOR> n; <OPERATOR>++</OPERATOR>elem)
          {
            <COMMENT>/*System.out.print((char) a[a_first + elem]);</COMMENT>
<COMMENT>            System.out.print((char) b[b_first + elem]);*/</COMMENT>

            <KEYWORD>if</KEYWORD> (<CHARACTER>'<ESC>\0</ESC>'</CHARACTER> <OPERATOR>==</OPERATOR> a[a_first <OPERATOR>+</OPERATOR> elem] <OPERATOR>&amp;&amp;</OPERATOR> <CHARACTER>'<ESC>\0</ESC>'</CHARACTER> <OPERATOR>==</OPERATOR> b[b_first <OPERATOR>+</OPERATOR> elem])
              {
                <COMMENT>/*System.out.println("return 0");*/</COMMENT>
                <KEYWORD>return</KEYWORD> <NUMERIC>0</NUMERIC>;
              }
            <KEYWORD>if</KEYWORD> (a[a_first <OPERATOR>+</OPERATOR> elem] <OPERATOR>&lt;</OPERATOR> b[b_first <OPERATOR>+</OPERATOR> elem])
              {
                <COMMENT>/*System.out.println("return 1");*/</COMMENT>
                <KEYWORD>return</KEYWORD> <NUMERIC>1</NUMERIC>;
              }
            <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (a[a_first <OPERATOR>+</OPERATOR> elem] <OPERATOR>&gt;</OPERATOR> b[b_first <OPERATOR>+</OPERATOR> elem])
              {
                <COMMENT>/*System.out.println("return -1");*/</COMMENT>
                <KEYWORD>return</KEYWORD> <OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC>;
              }
          }

        <COMMENT>/*System.out.println("return 0");*/</COMMENT>
        <KEYWORD>return</KEYWORD> <NUMERIC>0</NUMERIC>;
      }

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: charncmp</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <TYPE>int</TYPE> charncmp
    (
     <TYPE>char</TYPE> a[],
     <TYPE>int</TYPE> a_first,
     <TYPE>char</TYPE> b[],
     <TYPE>int</TYPE> b_first,
     <TYPE>int</TYPE> n
     )
      {
        <TYPE>int</TYPE> elem;

        <KEYWORD>for</KEYWORD> (elem <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; elem <OPERATOR>&lt;</OPERATOR> n; <OPERATOR>++</OPERATOR>elem)
          {
            <KEYWORD>if</KEYWORD> (<CHARACTER>'<ESC>\0</ESC>'</CHARACTER> <OPERATOR>==</OPERATOR> a[a_first <OPERATOR>+</OPERATOR> elem] <OPERATOR>&amp;&amp;</OPERATOR> <CHARACTER>'<ESC>\0</ESC>'</CHARACTER> <OPERATOR>==</OPERATOR> b[b_first <OPERATOR>+</OPERATOR> elem])
              {
                <KEYWORD>return</KEYWORD> <NUMERIC>0</NUMERIC>;
              }
            <KEYWORD>if</KEYWORD> (a[a_first <OPERATOR>+</OPERATOR> elem] <OPERATOR>&lt;</OPERATOR> b[b_first <OPERATOR>+</OPERATOR> elem])
              {
                <KEYWORD>return</KEYWORD> <NUMERIC>1</NUMERIC>;
              }
            <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (a[a_first <OPERATOR>+</OPERATOR> elem] <OPERATOR>&gt;</OPERATOR> b[b_first <OPERATOR>+</OPERATOR> elem])
              {
                <KEYWORD>return</KEYWORD> <OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC>;
              }
          }

        <KEYWORD>return</KEYWORD> <NUMERIC>0</NUMERIC>;
      }
}

<COMMENT>/********************************************************</COMMENT>
<COMMENT>  Class: CError</COMMENT>
<COMMENT>  *******************************************************/</COMMENT>
<KEYWORD>class</KEYWORD> CError
{
  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: impos</COMMENT>
<COMMENT>    Description:</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <TYPE>void</TYPE> impos
    (
     <TYPE>String</TYPE> message
     )
      {
        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"JLex Error: "</STRING> <OPERATOR>+</OPERATOR> message);
      }

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Constants</COMMENT>
<COMMENT>    Description: Error codes for parse_error().</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>E_BADEXPR</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>E_PAREN</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>E_LENGTH</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>2</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>E_BRACKET</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>3</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>E_BOL</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>4</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>E_CLOSE</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>5</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>E_NEWLINE</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>6</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>E_BADMAC</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>7</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>E_NOMAC</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>8</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>E_MACDEPTH</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>9</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>E_INIT</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>10</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>E_EOF</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>11</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>E_DIRECT</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>12</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>E_INTERNAL</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>13</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>E_STATE</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>14</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>E_MACDEF</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>15</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>E_SYNTAX</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>16</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>E_BRACE</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>17</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>E_DASH</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>18</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>E_ZERO</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>19</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>E_BADCTRL</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>20</NUMERIC>;

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Constants</COMMENT>
<COMMENT>    Description: String messages for parse_error();</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>String</TYPE> errmsg[] <OPERATOR>=</OPERATOR>
    {
      <STRING>"Malformed regular expression."</STRING>,
      <STRING>"Missing close parenthesis."</STRING>,
      <STRING>"Too many regular expressions or expression too long."</STRING>,
      <STRING>"Missing [ in character class."</STRING>,
      <STRING>"^ must be at start of expression or after [."</STRING>,
      <STRING>"+ ? or * must follow an expression or subexpression."</STRING>,
      <STRING>"Newline in quoted string."</STRING>,
      <STRING>"Missing } in macro expansion."</STRING>,
      <STRING>"Macro does not exist."</STRING>,
      <STRING>"Macro expansions nested too deeply."</STRING>,
      <STRING>"JLex has not been successfully initialized."</STRING>,
      <STRING>"Unexpected end-of-file found."</STRING>,
      <STRING>"Undefined or badly-formed JLex directive."</STRING>,
      <STRING>"Internal JLex error."</STRING>,
      <STRING>"Unitialized state name."</STRING>,
      <STRING>"Badly formed macro definition."</STRING>,
      <STRING>"Syntax error."</STRING>,
      <STRING>"Missing brace at start of lexical action."</STRING>,
      <STRING>"Special character dash - in character class [...] must<ESC>\n</ESC>"</STRING>
        <OPERATOR>+</OPERATOR> <STRING>"<ESC>\t</ESC>be preceded by start-of-range character."</STRING>,
      <STRING>"Zero-length regular expression."</STRING>,
      <STRING>"Illegal <ESC>\\</ESC>^C-style escape sequence (character following caret must<ESC>\n</ESC>"</STRING>
        <OPERATOR>+</OPERATOR> <STRING>"<ESC>\t</ESC>be alphabetic)."</STRING>,
    };

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: parse_error</COMMENT>
<COMMENT>    Description:</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <TYPE>void</TYPE> parse_error
    (
     <TYPE>int</TYPE> error_code,
     <TYPE>int</TYPE> line_number
     )
      {
        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Error: Parse error at line "</STRING>
                           <OPERATOR>+</OPERATOR> line_number <OPERATOR>+</OPERATOR> <STRING>"."</STRING>);
        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Description: "</STRING> <OPERATOR>+</OPERATOR> errmsg[error_code]);
        <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> <TYPE>Error</TYPE>(<STRING>"Parse error."</STRING>);
      }
}

<COMMENT>/********************************************************</COMMENT>
<COMMENT>  Class: CSet</COMMENT>
<COMMENT>  *******************************************************/</COMMENT>
<KEYWORD>class</KEYWORD> CSet
{
  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Member Variables</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> SparseBitSet m_set;
  <KEYWORD>private</KEYWORD> <TYPE>boolean</TYPE> m_complement;

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: CSet</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  CSet
    (
     )
    {
      m_set <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> SparseBitSet();
      m_complement <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
    }

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: complement</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <TYPE>void</TYPE> complement
    (
     )
      {
        m_complement <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
      }

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: add</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <TYPE>void</TYPE> add
    (
     <TYPE>int</TYPE> i
     )
      {
        <OBJ>m_set</OBJ>.<OO>set</OO>(i);
      }

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: addncase</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <TYPE>void</TYPE> addncase <COMMENT>// add, ignoring case.</COMMENT>
    (
     <TYPE>char</TYPE> c
     )
      {
        <COMMENT>/* Do this in a Unicode-friendly way. */</COMMENT>
        <COMMENT>/* (note that duplicate adds have no effect) */</COMMENT>
        add(c);
        add(<OBJ>Character</OBJ>.<OO>toLowerCase</OO>(c));
        add(<OBJ>Character</OBJ>.<OO>toTitleCase</OO>(c));
        add(<OBJ>Character</OBJ>.<OO>toUpperCase</OO>(c));
      }

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: contains</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <TYPE>boolean</TYPE> contains
    (
     <TYPE>int</TYPE> i
     )
      {
        <TYPE>boolean</TYPE> result;

        result <OPERATOR>=</OPERATOR> <OBJ>m_set</OBJ>.<OO>get</OO>(i);

        <KEYWORD>if</KEYWORD> (m_complement)
          {
            <KEYWORD>return</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> result);
          }

        <KEYWORD>return</KEYWORD> result;
      }

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: mimic</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <TYPE>void</TYPE> mimic
    (
     CSet set
     )
      {
        m_complement <OPERATOR>=</OPERATOR> <OBJ>set</OBJ>.<OO>m_complement</OO>;
        m_set <OPERATOR>=</OPERATOR> (SparseBitSet) <OBJ>set</OBJ>.<OO>m_set</OO>.<OO>clone</OO>();
      }

  <DOCCOMMENT>/** Map set using character classes [CSA] */</DOCCOMMENT>
  <TYPE>void</TYPE> map(CSet set, <TYPE>int</TYPE>[] mapping) {
    m_complement <OPERATOR>=</OPERATOR> <OBJ>set</OBJ>.<OO>m_complement</OO>;
    <OBJ>m_set</OBJ>.<OO>clearAll</OO>();
    <KEYWORD>for</KEYWORD> (<TYPE>Enumeration</TYPE> e<OPERATOR>=</OPERATOR><OBJ>set</OBJ>.<OO>m_set</OO>.<OO>elements</OO>(); <OBJ>e</OBJ>.<OO>hasMoreElements</OO>(); ) {
      <TYPE>int</TYPE> old_value <OPERATOR>=</OPERATOR>((<TYPE>Integer</TYPE>)<OBJ>e</OBJ>.<OO>nextElement</OO>()).intValue();
      <KEYWORD>if</KEYWORD> (old_value<OPERATOR>&lt;</OPERATOR><OBJ>mapping</OBJ>.<OO>length</OO>) <COMMENT>// skip unmapped characters</COMMENT>
        <OBJ>m_set</OBJ>.<OO>set</OO>(mapping[old_value]);
    }
  }
}

<COMMENT>/********************************************************</COMMENT>
<COMMENT>  Class: CNfa</COMMENT>
<COMMENT>  *******************************************************/</COMMENT>
<KEYWORD>class</KEYWORD> CNfa
{
  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Member Variables</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <TYPE>int</TYPE> m_edge;  <COMMENT>/* Label for edge type:</COMMENT>
<COMMENT>                         character code,</COMMENT>
<COMMENT>                         CCL (character class),</COMMENT>
<COMMENT>                         [STATE,</COMMENT>
<COMMENT>                         SCL (state class),]</COMMENT>
<COMMENT>                         EMPTY,</COMMENT>
<COMMENT>                         EPSILON. */</COMMENT>

  CSet m_set;  <COMMENT>/* Set to store character classes. */</COMMENT>
  CNfa m_next;  <COMMENT>/* Next state (or null if none). */</COMMENT>

  CNfa m_next2;  <COMMENT>/* Another state with type == EPSILON</COMMENT>
<COMMENT>                           and null if not used.</COMMENT>
<COMMENT>                           The NFA construction should result in two</COMMENT>
<COMMENT>                           outgoing edges only if both are EPSILON edges. */</COMMENT>

  CAccept m_accept;  <COMMENT>/* Set to null if nonaccepting state. */</COMMENT>
  <TYPE>int</TYPE> m_anchor;  <COMMENT>/* Says if and where pattern is anchored. */</COMMENT>

  <TYPE>int</TYPE> m_label;

  SparseBitSet m_states;

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Constants</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>NO_LABEL</CONSTANT> <OPERATOR>=</OPERATOR> <OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC>;

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Constants: Edge Types</COMMENT>
<COMMENT>    Note: Edge transitions on one specific character</COMMENT>
<COMMENT>    are labelled with the character Ascii (Unicode)</COMMENT>
<COMMENT>    codes.  So none of the constants below should</COMMENT>
<COMMENT>    overlap with the natural character codes.</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> CCL <OPERATOR>=</OPERATOR> <OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>EMPTY</CONSTANT> <OPERATOR>=</OPERATOR> <OPERATOR>-</OPERATOR><NUMERIC>2</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>EPSILON</CONSTANT> <OPERATOR>=</OPERATOR> <OPERATOR>-</OPERATOR><NUMERIC>3</NUMERIC>;

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: CNfa</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
 CNfa
    (
     )
    {
      m_edge <OPERATOR>=</OPERATOR> <CONSTANT>EMPTY</CONSTANT>;
      m_set <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
      m_next <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
      m_next2 <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
      m_accept <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
      m_anchor <OPERATOR>=</OPERATOR> <OBJ>CSpec</OBJ>.<OO>NONE</OO>;
      m_label <OPERATOR>=</OPERATOR> <CONSTANT>NO_LABEL</CONSTANT>;
      m_states <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
    }

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: mimic</COMMENT>
<COMMENT>    Description: Converts this NFA state into a copy of</COMMENT>
<COMMENT>    the input one.</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <TYPE>void</TYPE> mimic
    (
     CNfa nfa
     )
      {
        m_edge <OPERATOR>=</OPERATOR> <OBJ>nfa</OBJ>.<OO>m_edge</OO>;

        <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>nfa</OBJ>.<OO>m_set</OO>)
          {
            <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>==</OPERATOR> m_set)
              {
                m_set <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> CSet();
              }
            <OBJ>m_set</OBJ>.<OO>mimic</OO>(<OBJ>nfa</OBJ>.<OO>m_set</OO>);
          }
        <KEYWORD>else</KEYWORD>
          {
            m_set <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
          }

        m_next <OPERATOR>=</OPERATOR> <OBJ>nfa</OBJ>.<OO>m_next</OO>;
        m_next2 <OPERATOR>=</OPERATOR> <OBJ>nfa</OBJ>.<OO>m_next2</OO>;
        m_accept <OPERATOR>=</OPERATOR> <OBJ>nfa</OBJ>.<OO>m_accept</OO>;
        m_anchor <OPERATOR>=</OPERATOR> <OBJ>nfa</OBJ>.<OO>m_anchor</OO>;

        <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>nfa</OBJ>.<OO>m_states</OO>)
          {
            m_states <OPERATOR>=</OPERATOR> (SparseBitSet) <OBJ>nfa</OBJ>.<OO>m_states</OO>.<OO>clone</OO>();
          }
        <KEYWORD>else</KEYWORD>
          {
            m_states <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
          }
      }
}

<COMMENT>/***************************************************************</COMMENT>
<COMMENT>  Class: CLexGen</COMMENT>
<COMMENT>  **************************************************************/</COMMENT>
<KEYWORD>class</KEYWORD> CLexGen
{
  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Member Variables</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>Reader</OO> m_instream; <COMMENT>/* JLex specification file. */</COMMENT>
  <KEYWORD>private</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>PrintWriter</OO> m_outstream; <COMMENT>/* Lexical analyzer source file. */</COMMENT>

  <KEYWORD>private</KEYWORD> CInput m_input; <COMMENT>/* Input buffer class. */</COMMENT>

  <KEYWORD>private</KEYWORD> <TYPE>Hashtable</TYPE> m_tokens; <COMMENT>/* Hashtable that maps characters to their</COMMENT>
<COMMENT>                                 corresponding lexical code for</COMMENT>
<COMMENT>                                 the internal lexical analyzer. */</COMMENT>
  <KEYWORD>private</KEYWORD> CSpec m_spec; <COMMENT>/* Spec class holds information</COMMENT>
<COMMENT>                           about the generated lexer. */</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>boolean</TYPE> m_init_flag; <COMMENT>/* Flag set to true only upon</COMMENT>
<COMMENT>                                  successful initialization. */</COMMENT>

  <KEYWORD>private</KEYWORD> CMakeNfa m_makeNfa; <COMMENT>/* NFA machine generator module. */</COMMENT>
  <KEYWORD>private</KEYWORD> CNfa2Dfa m_nfa2dfa; <COMMENT>/* NFA to DFA machine (transition table)</COMMENT>
<COMMENT>                                 conversion module. */</COMMENT>
  <KEYWORD>private</KEYWORD> CMinimize m_minimize; <COMMENT>/* Transition table compressor. */</COMMENT>
  <KEYWORD>private</KEYWORD> CSimplifyNfa m_simplifyNfa; <COMMENT>/* NFA simplifier using char classes */</COMMENT>
  <KEYWORD>private</KEYWORD> CEmit m_emit; <COMMENT>/* Output module that emits source code</COMMENT>
<COMMENT>                           into the generated lexer file. */</COMMENT>


  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Constants</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>boolean</TYPE> <CONSTANT>ERROR</CONSTANT> <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
  <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>boolean</TYPE> <CONSTANT>NOT_ERROR</CONSTANT> <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
  <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>BUFFER_SIZE</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>1024</NUMERIC>;

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Constants: Token Types</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> EOS <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> ANY <OPERATOR>=</OPERATOR> <NUMERIC>2</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>AT_BOL</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>3</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>AT_EOL</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>4</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>CCL_END</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>5</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>CCL_START</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>6</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>CLOSE_CURLY</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>7</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>CLOSE_PAREN</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>8</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>CLOSURE</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>9</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>DASH</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>10</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>END_OF_INPUT</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>11</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> L <OPERATOR>=</OPERATOR> <NUMERIC>12</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>OPEN_CURLY</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>13</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>OPEN_PAREN</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>14</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>OPTIONAL</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>15</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> OR <OPERATOR>=</OPERATOR> <NUMERIC>16</NUMERIC>;
  <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>PLUS_CLOSE</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>17</NUMERIC>;

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: CLexGen</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  CLexGen
    (
     <TYPE>String</TYPE> filename
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>FileNotFoundException</OO>, <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
      {
        <COMMENT>/* Successful initialization flag. */</COMMENT>
        m_init_flag <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;

        <COMMENT>/* Open input stream. */</COMMENT>
        m_instream <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>FileReader</OO>(filename);
        <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>==</OPERATOR> m_instream)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Error: Unable to open input file "</STRING>
                               <OPERATOR>+</OPERATOR> filename <OPERATOR>+</OPERATOR> <STRING>"."</STRING>);
            <KEYWORD>return</KEYWORD>;
          }

        <COMMENT>/* Open output stream. */</COMMENT>
        m_outstream
          <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>PrintWriter</OO>(<KEYWORD>new</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>BufferedWriter</OO>(
                <KEYWORD>new</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>FileWriter</OO>(filename <OPERATOR>+</OPERATOR> <STRING>".java"</STRING>)));
        <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>==</OPERATOR> m_outstream)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Error: Unable to open output file "</STRING>
                               <OPERATOR>+</OPERATOR> filename <OPERATOR>+</OPERATOR> <STRING>".java."</STRING>);
            <KEYWORD>return</KEYWORD>;
          }

        <COMMENT>/* Create input buffer class. */</COMMENT>
        m_input <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> CInput(m_instream);

        <COMMENT>/* Initialize character hash table. */</COMMENT>
        m_tokens <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Hashtable</TYPE>();
        <OBJ>m_tokens</OBJ>.<OO>put</OO>(<KEYWORD>new</KEYWORD> <TYPE>Character</TYPE>(<CHARACTER>'$'</CHARACTER>),<KEYWORD>new</KEYWORD> <TYPE>Integer</TYPE>(<CONSTANT>AT_EOL</CONSTANT>));
        <OBJ>m_tokens</OBJ>.<OO>put</OO>(<KEYWORD>new</KEYWORD> <TYPE>Character</TYPE>(<CHARACTER>'('</CHARACTER>),<KEYWORD>new</KEYWORD> <TYPE>Integer</TYPE>(<CONSTANT>OPEN_PAREN</CONSTANT>));
        <OBJ>m_tokens</OBJ>.<OO>put</OO>(<KEYWORD>new</KEYWORD> <TYPE>Character</TYPE>(<CHARACTER>')'</CHARACTER>),<KEYWORD>new</KEYWORD> <TYPE>Integer</TYPE>(<CONSTANT>CLOSE_PAREN</CONSTANT>));
        <OBJ>m_tokens</OBJ>.<OO>put</OO>(<KEYWORD>new</KEYWORD> <TYPE>Character</TYPE>(<CHARACTER>'*'</CHARACTER>),<KEYWORD>new</KEYWORD> <TYPE>Integer</TYPE>(<CONSTANT>CLOSURE</CONSTANT>));
        <OBJ>m_tokens</OBJ>.<OO>put</OO>(<KEYWORD>new</KEYWORD> <TYPE>Character</TYPE>(<CHARACTER>'+'</CHARACTER>),<KEYWORD>new</KEYWORD> <TYPE>Integer</TYPE>(<CONSTANT>PLUS_CLOSE</CONSTANT>));
        <OBJ>m_tokens</OBJ>.<OO>put</OO>(<KEYWORD>new</KEYWORD> <TYPE>Character</TYPE>(<CHARACTER>'-'</CHARACTER>),<KEYWORD>new</KEYWORD> <TYPE>Integer</TYPE>(<CONSTANT>DASH</CONSTANT>));
        <OBJ>m_tokens</OBJ>.<OO>put</OO>(<KEYWORD>new</KEYWORD> <TYPE>Character</TYPE>(<CHARACTER>'.'</CHARACTER>),<KEYWORD>new</KEYWORD> <TYPE>Integer</TYPE>(ANY));
        <OBJ>m_tokens</OBJ>.<OO>put</OO>(<KEYWORD>new</KEYWORD> <TYPE>Character</TYPE>(<CHARACTER>'?'</CHARACTER>),<KEYWORD>new</KEYWORD> <TYPE>Integer</TYPE>(<CONSTANT>OPTIONAL</CONSTANT>));
        <OBJ>m_tokens</OBJ>.<OO>put</OO>(<KEYWORD>new</KEYWORD> <TYPE>Character</TYPE>(<CHARACTER>'['</CHARACTER>),<KEYWORD>new</KEYWORD> <TYPE>Integer</TYPE>(<CONSTANT>CCL_START</CONSTANT>));
        <OBJ>m_tokens</OBJ>.<OO>put</OO>(<KEYWORD>new</KEYWORD> <TYPE>Character</TYPE>(<CHARACTER>']'</CHARACTER>),<KEYWORD>new</KEYWORD> <TYPE>Integer</TYPE>(<CONSTANT>CCL_END</CONSTANT>));
        <OBJ>m_tokens</OBJ>.<OO>put</OO>(<KEYWORD>new</KEYWORD> <TYPE>Character</TYPE>(<CHARACTER>'^'</CHARACTER>),<KEYWORD>new</KEYWORD> <TYPE>Integer</TYPE>(<CONSTANT>AT_BOL</CONSTANT>));
        <OBJ>m_tokens</OBJ>.<OO>put</OO>(<KEYWORD>new</KEYWORD> <TYPE>Character</TYPE>(<CHARACTER>'{'</CHARACTER>),<KEYWORD>new</KEYWORD> <TYPE>Integer</TYPE>(<CONSTANT>OPEN_CURLY</CONSTANT>));
        <OBJ>m_tokens</OBJ>.<OO>put</OO>(<KEYWORD>new</KEYWORD> <TYPE>Character</TYPE>(<CHARACTER>'|'</CHARACTER>),<KEYWORD>new</KEYWORD> <TYPE>Integer</TYPE>(OR));
        <OBJ>m_tokens</OBJ>.<OO>put</OO>(<KEYWORD>new</KEYWORD> <TYPE>Character</TYPE>(<CHARACTER>'}'</CHARACTER>),<KEYWORD>new</KEYWORD> <TYPE>Integer</TYPE>(<CONSTANT>CLOSE_CURLY</CONSTANT>));

        <COMMENT>/* Initialize spec structure. */</COMMENT>
        m_spec <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> CSpec(<KEYWORD>this</KEYWORD>);

        <COMMENT>/* Nfa to dfa converter. */</COMMENT>
        m_nfa2dfa <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> CNfa2Dfa();
        m_minimize <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> CMinimize();
        m_makeNfa <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> CMakeNfa();
        m_simplifyNfa <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> CSimplifyNfa();

        m_emit <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> CEmit();

        <COMMENT>/* Successful initialization flag. */</COMMENT>
        m_init_flag <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: generate</COMMENT>
<COMMENT>    Description:</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <TYPE>void</TYPE> generate
    (
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>, <OBJ>java</OBJ>.<OO>io</OO>.<OO>FileNotFoundException</OO>
      {
        <KEYWORD>if</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> m_init_flag)
          {
            <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_INIT</OO>,<NUMERIC>0</NUMERIC>);
          }

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <KEYWORD>this</KEYWORD>);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_outstream);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_input);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_tokens);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_spec);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(m_init_flag);
          }

        <COMMENT>/*m_emit.emit_imports(m_spec,m_outstream);*/</COMMENT>

        <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_verbose</OO>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Processing first section -- user code."</STRING>);
          }
        userCode();
        <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_eof_reached</OO>)
          {
            <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_EOF</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
          }

        <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_verbose</OO>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Processing second section -- "</STRING>
                               <OPERATOR>+</OPERATOR> <STRING>"JLex declarations."</STRING>);
          }
        userDeclare();
        <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_eof_reached</OO>)
          {
            <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_EOF</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
          }

        <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_verbose</OO>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Processing third section -- lexical rules."</STRING>);
          }
        userRules();
        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DO_DEBUG</OO>)
          {
            print_header();
          }

        <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_verbose</OO>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Outputting lexical analyzer code."</STRING>);
          }
        <OBJ>m_emit</OBJ>.<OO>emit</OO>(m_spec,m_outstream);

        <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_verbose</OO> <OPERATOR>&amp;&amp;</OPERATOR> <KEYWORD>true</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>OLD_DUMP_DEBUG</OO>)
          {
            details();
          }

        <OBJ>m_outstream</OBJ>.<OO>close</OO>();
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: userCode</COMMENT>
<COMMENT>    Description: Process first section of specification,</COMMENT>
<COMMENT>    echoing it into output file.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> userCode
    (
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
      {
        <TYPE>int</TYPE> count <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;

        <KEYWORD>if</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> m_init_flag)
          {
            <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_INIT</OO>,<NUMERIC>0</NUMERIC>);
          }

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <KEYWORD>this</KEYWORD>);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_outstream);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_input);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_tokens);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_spec);
          }

        <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_eof_reached</OO>)
          {
            <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_EOF</OO>,<NUMERIC>0</NUMERIC>);
          }

        <KEYWORD>while</KEYWORD> (<KEYWORD>true</KEYWORD>)
          {
            <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>getLine</OO>())
              {
                <COMMENT>/* Eof reached. */</COMMENT>
                <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_EOF</OO>,<NUMERIC>0</NUMERIC>);
              }

            <KEYWORD>if</KEYWORD> (<NUMERIC>2</NUMERIC> <OPERATOR>&lt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>
                <OPERATOR>&amp;&amp;</OPERATOR> <CHARACTER>'%'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<NUMERIC>0</NUMERIC>]
                <OPERATOR>&amp;&amp;</OPERATOR> <CHARACTER>'%'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<NUMERIC>1</NUMERIC>])
              {
                <COMMENT>/* Discard remainder of line. */</COMMENT>
                <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>;
                <KEYWORD>return</KEYWORD>;
              }

            <OBJ>m_outstream</OBJ>.<OO>print</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,<NUMERIC>0</NUMERIC>,
                                              <OBJ>m_input</OBJ>.<OO>m_line_read</OO>));
          }
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: getName</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE>[] getName
    (
     )
      {
        <TYPE>char</TYPE> buffer[];
        <TYPE>int</TYPE> elem;

        <COMMENT>/* Skip white space. */</COMMENT>
        <KEYWORD>while</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&lt;</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>
               <OPERATOR>&amp;&amp;</OPERATOR> <KEYWORD>true</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>isspace</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>]))
          {
            <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
          }

        <COMMENT>/* No name? */</COMMENT>
        <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
          {
            <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_DIRECT</OO>,<NUMERIC>0</NUMERIC>);
          }

        <COMMENT>/* Determine length. */</COMMENT>
        elem <OPERATOR>=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
        <KEYWORD>while</KEYWORD> (elem <OPERATOR>&lt;</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>
               <OPERATOR>&amp;&amp;</OPERATOR> <KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>isnewline</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>[elem]))
          {
            <OPERATOR>++</OPERATOR>elem;
          }

        <COMMENT>/* Allocate non-terminated buffer of exact length. */</COMMENT>
        buffer <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>char</TYPE>[elem <OPERATOR>-</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_index</OO>];

        <COMMENT>/* Copy. */</COMMENT>
        elem <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
        <KEYWORD>while</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&lt;</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>
               <OPERATOR>&amp;&amp;</OPERATOR> <KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>isnewline</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>]))
          {
            buffer[elem] <OPERATOR>=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>];
            <OPERATOR>++</OPERATOR>elem;
            <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
          }

        <KEYWORD>return</KEYWORD> buffer;
      }

  <KEYWORD>private</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>CLASS_CODE</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
  <KEYWORD>private</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>INIT_CODE</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC>;
  <KEYWORD>private</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>EOF_CODE</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>2</NUMERIC>;
  <KEYWORD>private</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>INIT_THROW_CODE</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>3</NUMERIC>;
  <KEYWORD>private</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>YYLEX_THROW_CODE</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>4</NUMERIC>;
  <KEYWORD>private</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>EOF_THROW_CODE</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>5</NUMERIC>;
  <KEYWORD>private</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>EOF_VALUE_CODE</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>6</NUMERIC>;

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: packCode</COMMENT>
<COMMENT>    Description:</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE>[] packCode
    (
     <TYPE>char</TYPE> start_dir[],
     <TYPE>char</TYPE> end_dir[],
     <TYPE>char</TYPE> prev_code[],
     <TYPE>int</TYPE> prev_read,
     <TYPE>int</TYPE> specified
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
      {
        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<CONSTANT>INIT_CODE</CONSTANT> <OPERATOR>==</OPERATOR> specified
                            <OPERATOR>||</OPERATOR> <CONSTANT>CLASS_CODE</CONSTANT> <OPERATOR>==</OPERATOR> specified
                            <OPERATOR>||</OPERATOR> <CONSTANT>EOF_CODE</CONSTANT> <OPERATOR>==</OPERATOR> specified
                            <OPERATOR>||</OPERATOR> <CONSTANT>EOF_VALUE_CODE</CONSTANT> <OPERATOR>==</OPERATOR> specified
                            <OPERATOR>||</OPERATOR> <CONSTANT>INIT_THROW_CODE</CONSTANT> <OPERATOR>==</OPERATOR> specified
                            <OPERATOR>||</OPERATOR> <CONSTANT>YYLEX_THROW_CODE</CONSTANT> <OPERATOR>==</OPERATOR> specified
                            <OPERATOR>||</OPERATOR> <CONSTANT>EOF_THROW_CODE</CONSTANT> <OPERATOR>==</OPERATOR> specified);
          }

        <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>!=</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                   <NUMERIC>0</NUMERIC>,
                                   start_dir,
                                   <NUMERIC>0</NUMERIC>,
                                   <OBJ>start_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))
          {
            <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_INTERNAL</OO>,<NUMERIC>0</NUMERIC>);
          }

        <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>==</OPERATOR> prev_code)
          {
            prev_code <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>char</TYPE>[<CONSTANT>BUFFER_SIZE</CONSTANT>];
            prev_read <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
          }

        <KEYWORD>if</KEYWORD> (prev_read <OPERATOR>&gt;=</OPERATOR> <OBJ>prev_code</OBJ>.<OO>length</OO>)
          {
            prev_code <OPERATOR>=</OPERATOR> <OBJ>CUtility</OBJ>.<OO>doubleSize</OO>(prev_code);
          }

        <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>=</OPERATOR> <OBJ>start_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>;
        <KEYWORD>while</KEYWORD> (<KEYWORD>true</KEYWORD>)
          {
            <KEYWORD>while</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
              {
                <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>getLine</OO>())
                  {
                    <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_EOF</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                  }

                <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                           <NUMERIC>0</NUMERIC>,
                                           end_dir,
                                           <NUMERIC>0</NUMERIC>,
                                           <OBJ>end_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))
                  {
                    <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>=</OPERATOR> <OBJ>end_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>;

                    <KEYWORD>switch</KEYWORD> (specified)
                      {
                      <KEYWORD>case</KEYWORD> <CONSTANT>CLASS_CODE</CONSTANT><OPERATOR>:</OPERATOR>
                        <OBJ>m_spec</OBJ>.<OO>m_class_read</OO> <OPERATOR>=</OPERATOR> prev_read;
                        <KEYWORD>break</KEYWORD>;

                      <KEYWORD>case</KEYWORD> <CONSTANT>INIT_CODE</CONSTANT><OPERATOR>:</OPERATOR>
                        <OBJ>m_spec</OBJ>.<OO>m_init_read</OO> <OPERATOR>=</OPERATOR> prev_read;
                        <KEYWORD>break</KEYWORD>;

                      <KEYWORD>case</KEYWORD> <CONSTANT>EOF_CODE</CONSTANT><OPERATOR>:</OPERATOR>
                        <OBJ>m_spec</OBJ>.<OO>m_eof_read</OO> <OPERATOR>=</OPERATOR> prev_read;
                        <KEYWORD>break</KEYWORD>;

                      <KEYWORD>case</KEYWORD> <CONSTANT>EOF_VALUE_CODE</CONSTANT><OPERATOR>:</OPERATOR>
                        <OBJ>m_spec</OBJ>.<OO>m_eof_value_read</OO> <OPERATOR>=</OPERATOR> prev_read;
                        <KEYWORD>break</KEYWORD>;

                      <KEYWORD>case</KEYWORD> <CONSTANT>INIT_THROW_CODE</CONSTANT><OPERATOR>:</OPERATOR>
                        <OBJ>m_spec</OBJ>.<OO>m_init_throw_read</OO> <OPERATOR>=</OPERATOR> prev_read;
                        <KEYWORD>break</KEYWORD>;

                      <KEYWORD>case</KEYWORD> <CONSTANT>YYLEX_THROW_CODE</CONSTANT><OPERATOR>:</OPERATOR>
                        <OBJ>m_spec</OBJ>.<OO>m_yylex_throw_read</OO> <OPERATOR>=</OPERATOR> prev_read;
                        <KEYWORD>break</KEYWORD>;

                      <KEYWORD>case</KEYWORD> <CONSTANT>EOF_THROW_CODE</CONSTANT><OPERATOR>:</OPERATOR>
                        <OBJ>m_spec</OBJ>.<OO>m_eof_throw_read</OO> <OPERATOR>=</OPERATOR> prev_read;
                        <KEYWORD>break</KEYWORD>;

                      <KEYWORD>default</KEYWORD><OPERATOR>:</OPERATOR>
                        <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_INTERNAL</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                        <KEYWORD>break</KEYWORD>;
                      }

                    <KEYWORD>return</KEYWORD> prev_code;
                  }
              }

            <KEYWORD>while</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&lt;</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
              {
                prev_code[prev_read] <OPERATOR>=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>];
                <OPERATOR>++</OPERATOR>prev_read;
                <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;

                <KEYWORD>if</KEYWORD> (prev_read <OPERATOR>&gt;=</OPERATOR> <OBJ>prev_code</OBJ>.<OO>length</OO>)
                  {
                    prev_code <OPERATOR>=</OPERATOR> <OBJ>CUtility</OBJ>.<OO>doubleSize</OO>(prev_code);
                  }
              }
          }
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Member Variables: JLex directives.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_state_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'s'</CHARACTER>, <CHARACTER>'t'</CHARACTER>,
    <CHARACTER>'a'</CHARACTER>, <CHARACTER>'t'</CHARACTER>, <CHARACTER>'e'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_char_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'c'</CHARACTER>, <CHARACTER>'h'</CHARACTER>,
    <CHARACTER>'a'</CHARACTER>, <CHARACTER>'r'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_line_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'l'</CHARACTER>, <CHARACTER>'i'</CHARACTER>,
    <CHARACTER>'n'</CHARACTER>, <CHARACTER>'e'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_cup_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'c'</CHARACTER>, <CHARACTER>'u'</CHARACTER>,
    <CHARACTER>'p'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_class_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'c'</CHARACTER>, <CHARACTER>'l'</CHARACTER>,
    <CHARACTER>'a'</CHARACTER>, <CHARACTER>'s'</CHARACTER>, <CHARACTER>'s'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_implements_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'i'</CHARACTER>, <CHARACTER>'m'</CHARACTER>, <CHARACTER>'p'</CHARACTER>, <CHARACTER>'l'</CHARACTER>, <CHARACTER>'e'</CHARACTER>, <CHARACTER>'m'</CHARACTER>, <CHARACTER>'e'</CHARACTER>, <CHARACTER>'n'</CHARACTER>, <CHARACTER>'t'</CHARACTER>, <CHARACTER>'s'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_function_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'f'</CHARACTER>, <CHARACTER>'u'</CHARACTER>,
    <CHARACTER>'n'</CHARACTER>, <CHARACTER>'c'</CHARACTER>, <CHARACTER>'t'</CHARACTER>,
    <CHARACTER>'i'</CHARACTER>, <CHARACTER>'o'</CHARACTER>, <CHARACTER>'n'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_type_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'t'</CHARACTER>, <CHARACTER>'y'</CHARACTER>,
    <CHARACTER>'p'</CHARACTER>, <CHARACTER>'e'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_integer_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'i'</CHARACTER>, <CHARACTER>'n'</CHARACTER>,
    <CHARACTER>'t'</CHARACTER>, <CHARACTER>'e'</CHARACTER>, <CHARACTER>'g'</CHARACTER>,
    <CHARACTER>'e'</CHARACTER>, <CHARACTER>'r'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_intwrap_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'i'</CHARACTER>, <CHARACTER>'n'</CHARACTER>,
    <CHARACTER>'t'</CHARACTER>, <CHARACTER>'w'</CHARACTER>, <CHARACTER>'r'</CHARACTER>,
    <CHARACTER>'a'</CHARACTER>, <CHARACTER>'p'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_full_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'f'</CHARACTER>, <CHARACTER>'u'</CHARACTER>,
    <CHARACTER>'l'</CHARACTER>, <CHARACTER>'l'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_unicode_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'u'</CHARACTER>, <CHARACTER>'n'</CHARACTER>,
    <CHARACTER>'i'</CHARACTER>, <CHARACTER>'c'</CHARACTER>, <CHARACTER>'o'</CHARACTER>,
    <CHARACTER>'d'</CHARACTER>, <CHARACTER>'e'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_ignorecase_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'i'</CHARACTER>, <CHARACTER>'g'</CHARACTER>,
    <CHARACTER>'n'</CHARACTER>, <CHARACTER>'o'</CHARACTER>, <CHARACTER>'r'</CHARACTER>,
    <CHARACTER>'e'</CHARACTER>, <CHARACTER>'c'</CHARACTER>, <CHARACTER>'a'</CHARACTER>,
    <CHARACTER>'s'</CHARACTER>, <CHARACTER>'e'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_notunix_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'n'</CHARACTER>, <CHARACTER>'o'</CHARACTER>,
    <CHARACTER>'t'</CHARACTER>, <CHARACTER>'u'</CHARACTER>, <CHARACTER>'n'</CHARACTER>,
    <CHARACTER>'i'</CHARACTER>, <CHARACTER>'x'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_init_code_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'i'</CHARACTER>, <CHARACTER>'n'</CHARACTER>,
    <CHARACTER>'i'</CHARACTER>, <CHARACTER>'t'</CHARACTER>, <CHARACTER>'{'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_init_code_end_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'i'</CHARACTER>, <CHARACTER>'n'</CHARACTER>,
    <CHARACTER>'i'</CHARACTER>, <CHARACTER>'t'</CHARACTER>, <CHARACTER>'}'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_init_throw_code_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'i'</CHARACTER>, <CHARACTER>'n'</CHARACTER>,
    <CHARACTER>'i'</CHARACTER>, <CHARACTER>'t'</CHARACTER>, <CHARACTER>'t'</CHARACTER>,
    <CHARACTER>'h'</CHARACTER>, <CHARACTER>'r'</CHARACTER>, <CHARACTER>'o'</CHARACTER>,
    <CHARACTER>'w'</CHARACTER>, <CHARACTER>'{'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_init_throw_code_end_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'i'</CHARACTER>, <CHARACTER>'n'</CHARACTER>,
    <CHARACTER>'i'</CHARACTER>, <CHARACTER>'t'</CHARACTER>, <CHARACTER>'t'</CHARACTER>,
    <CHARACTER>'h'</CHARACTER>, <CHARACTER>'r'</CHARACTER>, <CHARACTER>'o'</CHARACTER>,
    <CHARACTER>'w'</CHARACTER>, <CHARACTER>'}'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_yylex_throw_code_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'y'</CHARACTER>, <CHARACTER>'y'</CHARACTER>, <CHARACTER>'l'</CHARACTER>,
    <CHARACTER>'e'</CHARACTER>, <CHARACTER>'x'</CHARACTER>, <CHARACTER>'t'</CHARACTER>,
    <CHARACTER>'h'</CHARACTER>, <CHARACTER>'r'</CHARACTER>, <CHARACTER>'o'</CHARACTER>,
    <CHARACTER>'w'</CHARACTER>, <CHARACTER>'{'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_yylex_throw_code_end_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'y'</CHARACTER>, <CHARACTER>'y'</CHARACTER>, <CHARACTER>'l'</CHARACTER>,
    <CHARACTER>'e'</CHARACTER>, <CHARACTER>'x'</CHARACTER>, <CHARACTER>'t'</CHARACTER>,
    <CHARACTER>'h'</CHARACTER>, <CHARACTER>'r'</CHARACTER>, <CHARACTER>'o'</CHARACTER>,
    <CHARACTER>'w'</CHARACTER>, <CHARACTER>'}'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_eof_code_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'e'</CHARACTER>, <CHARACTER>'o'</CHARACTER>,
    <CHARACTER>'f'</CHARACTER>, <CHARACTER>'{'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_eof_code_end_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'e'</CHARACTER>, <CHARACTER>'o'</CHARACTER>,
    <CHARACTER>'f'</CHARACTER>, <CHARACTER>'}'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_eof_value_code_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'e'</CHARACTER>, <CHARACTER>'o'</CHARACTER>,
    <CHARACTER>'f'</CHARACTER>, <CHARACTER>'v'</CHARACTER>, <CHARACTER>'a'</CHARACTER>,
    <CHARACTER>'l'</CHARACTER>, <CHARACTER>'{'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_eof_value_code_end_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'e'</CHARACTER>, <CHARACTER>'o'</CHARACTER>,
    <CHARACTER>'f'</CHARACTER>, <CHARACTER>'v'</CHARACTER>, <CHARACTER>'a'</CHARACTER>,
    <CHARACTER>'l'</CHARACTER>, <CHARACTER>'}'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_eof_throw_code_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'e'</CHARACTER>, <CHARACTER>'o'</CHARACTER>,
    <CHARACTER>'f'</CHARACTER>, <CHARACTER>'t'</CHARACTER>, <CHARACTER>'h'</CHARACTER>,
    <CHARACTER>'r'</CHARACTER>, <CHARACTER>'o'</CHARACTER>, <CHARACTER>'w'</CHARACTER>,
    <CHARACTER>'{'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_eof_throw_code_end_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'e'</CHARACTER>, <CHARACTER>'o'</CHARACTER>,
    <CHARACTER>'f'</CHARACTER>, <CHARACTER>'t'</CHARACTER>, <CHARACTER>'h'</CHARACTER>,
    <CHARACTER>'r'</CHARACTER>, <CHARACTER>'o'</CHARACTER>, <CHARACTER>'w'</CHARACTER>,
    <CHARACTER>'}'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_class_code_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'{'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_class_code_end_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'}'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_yyeof_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'y'</CHARACTER>, <CHARACTER>'y'</CHARACTER>,
    <CHARACTER>'e'</CHARACTER>, <CHARACTER>'o'</CHARACTER>, <CHARACTER>'f'</CHARACTER>,
    <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> m_public_dir[] <OPERATOR>=</OPERATOR> {
    <CHARACTER>'%'</CHARACTER>, <CHARACTER>'p'</CHARACTER>, <CHARACTER>'u'</CHARACTER>,
    <CHARACTER>'b'</CHARACTER>, <CHARACTER>'l'</CHARACTER>, <CHARACTER>'i'</CHARACTER>,
    <CHARACTER>'c'</CHARACTER>, <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>
    };

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: userDeclare</COMMENT>
<COMMENT>    Description:</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> userDeclare
    (
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
        {
          <TYPE>int</TYPE> elem;

          <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
            {
              <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <KEYWORD>this</KEYWORD>);
              <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_outstream);
              <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_input);
              <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_tokens);
              <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_spec);
            }

          <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_eof_reached</OO>)
            {
              <COMMENT>/* End-of-file. */</COMMENT>
              <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_EOF</OO>,
                                 <OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
            }

          <KEYWORD>while</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>getLine</OO>())
            {
              <COMMENT>/* Look for double percent. */</COMMENT>
              <KEYWORD>if</KEYWORD> (<NUMERIC>2</NUMERIC> <OPERATOR>&lt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>
                  <OPERATOR>&amp;&amp;</OPERATOR> <CHARACTER>'%'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<NUMERIC>0</NUMERIC>]
                  <OPERATOR>&amp;&amp;</OPERATOR> <CHARACTER>'%'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<NUMERIC>1</NUMERIC>])
                {
                  <COMMENT>/* Mess around with line. */</COMMENT>
                  <OBJ>m_input</OBJ>.<OO>m_line_read</OO> <OPERATOR>-=</OPERATOR> <NUMERIC>2</NUMERIC>;
                  <OBJ>System</OBJ>.<OO>arraycopy</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>, <NUMERIC>2</NUMERIC>,
                                   <OBJ>m_input</OBJ>.<OO>m_line</OO>, <NUMERIC>0</NUMERIC>, <OBJ>m_input</OBJ>.<OO>m_line_read</OO>);

                  <OBJ>m_input</OBJ>.<OO>m_pushback_line</OO> <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
                  <COMMENT>/* Check for and discard empty line. */</COMMENT>
                  <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>
                      <OPERATOR>||</OPERATOR> <CHARACTER>'<ESC>\n</ESC>'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<NUMERIC>0</NUMERIC>])
                    {
                      <OBJ>m_input</OBJ>.<OO>m_pushback_line</OO> <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
                    }

                  <KEYWORD>return</KEYWORD>;
                }

              <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
                {
                  <KEYWORD>continue</KEYWORD>;
                }

              <KEYWORD>if</KEYWORD> (<CHARACTER>'%'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<NUMERIC>0</NUMERIC>])
                {
                  <COMMENT>/* Special lex declarations. */</COMMENT>
                  <KEYWORD>if</KEYWORD> (<NUMERIC>1</NUMERIC> <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
                    {
                      <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_DIRECT</OO>,
                                         <OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                      <KEYWORD>continue</KEYWORD>;
                    }

                  <KEYWORD>switch</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line</OO>[<NUMERIC>1</NUMERIC>])
                    {
                    <KEYWORD>case</KEYWORD> <CHARACTER>'{'</CHARACTER><OPERATOR>:</OPERATOR>
                      <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                                 <NUMERIC>0</NUMERIC>,
                                                 m_class_code_dir,
                                                 <NUMERIC>0</NUMERIC>,
                                                 <OBJ>m_class_code_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))
                        {
                          <OBJ>m_spec</OBJ>.<OO>m_class_code</OO> <OPERATOR>=</OPERATOR> packCode(m_class_code_dir,
                                                         m_class_code_end_dir,
                                                         <OBJ>m_spec</OBJ>.<OO>m_class_code</OO>,
                                                         <OBJ>m_spec</OBJ>.<OO>m_class_read</OO>,
                                                         <CONSTANT>CLASS_CODE</CONSTANT>);
                          <KEYWORD>break</KEYWORD>;
                        }

                      <COMMENT>/* Bad directive. */</COMMENT>
                      <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_DIRECT</OO>,
                                         <OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                      <KEYWORD>break</KEYWORD>;

                    <KEYWORD>case</KEYWORD> <CHARACTER>'c'</CHARACTER><OPERATOR>:</OPERATOR>
                      <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                                 <NUMERIC>0</NUMERIC>,
                                                 m_char_dir,
                                                 <NUMERIC>0</NUMERIC>,
                                                 <OBJ>m_char_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))
                        {
                          <COMMENT>/* Set line counting to ON. */</COMMENT>
                          <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>=</OPERATOR> <OBJ>m_char_dir</OBJ>.<OO>length</OO>;
                          <OBJ>m_spec</OBJ>.<OO>m_count_chars</OO> <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
                          <KEYWORD>break</KEYWORD>;
                        }
                      <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                                      <NUMERIC>0</NUMERIC>,
                                                      m_class_dir,
                                                      <NUMERIC>0</NUMERIC>,
                                                      <OBJ>m_class_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))
                        {
                          <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>=</OPERATOR> <OBJ>m_class_dir</OBJ>.<OO>length</OO>;
                          <OBJ>m_spec</OBJ>.<OO>m_class_name</OO> <OPERATOR>=</OPERATOR> getName();
                          <KEYWORD>break</KEYWORD>;
                        }
                      <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                                      <NUMERIC>0</NUMERIC>,
                                                      m_cup_dir,
                                                      <NUMERIC>0</NUMERIC>,
                                                      <OBJ>m_cup_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))
                        {
                          <COMMENT>/* Set Java CUP compatibility to ON. */</COMMENT>
                          <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>=</OPERATOR> <OBJ>m_cup_dir</OBJ>.<OO>length</OO>;
                          <OBJ>m_spec</OBJ>.<OO>m_cup_compatible</OO> <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
                          <COMMENT>// this is what %cup does: [CSA, 27-Jul-1999]</COMMENT>
                          <OBJ>m_spec</OBJ>.<OO>m_implements_name</OO> <OPERATOR>=</OPERATOR>
                              <STRING>"java_cup.runtime.Scanner"</STRING>.<OO>toCharArray</OO>();
                          <OBJ>m_spec</OBJ>.<OO>m_function_name</OO> <OPERATOR>=</OPERATOR>
                              <STRING>"next_token"</STRING>.<OO>toCharArray</OO>();
                          <OBJ>m_spec</OBJ>.<OO>m_type_name</OO> <OPERATOR>=</OPERATOR>
                              <STRING>"java_cup.runtime.Symbol"</STRING>.<OO>toCharArray</OO>();
                          <KEYWORD>break</KEYWORD>;
                        }

                      <COMMENT>/* Bad directive. */</COMMENT>
                      <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_DIRECT</OO>,
                                         <OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                      <KEYWORD>break</KEYWORD>;

                    <KEYWORD>case</KEYWORD> <CHARACTER>'e'</CHARACTER><OPERATOR>:</OPERATOR>
                      <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                                 <NUMERIC>0</NUMERIC>,
                                                 m_eof_code_dir,
                                                 <NUMERIC>0</NUMERIC>,
                                                 <OBJ>m_eof_code_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))
                        {
                          <OBJ>m_spec</OBJ>.<OO>m_eof_code</OO> <OPERATOR>=</OPERATOR> packCode(m_eof_code_dir,
                                                       m_eof_code_end_dir,
                                                       <OBJ>m_spec</OBJ>.<OO>m_eof_code</OO>,
                                                       <OBJ>m_spec</OBJ>.<OO>m_eof_read</OO>,
                                                       <CONSTANT>EOF_CODE</CONSTANT>);
                          <KEYWORD>break</KEYWORD>;
                        }
                      <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                                      <NUMERIC>0</NUMERIC>,
                                                      m_eof_value_code_dir,
                                                      <NUMERIC>0</NUMERIC>,
                                                      <OBJ>m_eof_value_code_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))
                        {
                          <OBJ>m_spec</OBJ>.<OO>m_eof_value_code</OO> <OPERATOR>=</OPERATOR> packCode(m_eof_value_code_dir,
                                                             m_eof_value_code_end_dir,
                                                             <OBJ>m_spec</OBJ>.<OO>m_eof_value_code</OO>,
                                                             <OBJ>m_spec</OBJ>.<OO>m_eof_value_read</OO>,
                                                             <CONSTANT>EOF_VALUE_CODE</CONSTANT>);
                          <KEYWORD>break</KEYWORD>;
                        }
                      <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                                      <NUMERIC>0</NUMERIC>,
                                                      m_eof_throw_code_dir,
                                                      <NUMERIC>0</NUMERIC>,
                                                      <OBJ>m_eof_throw_code_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))
                        {
                          <OBJ>m_spec</OBJ>.<OO>m_eof_throw_code</OO> <OPERATOR>=</OPERATOR> packCode(m_eof_throw_code_dir,
                                                       m_eof_throw_code_end_dir,
                                                       <OBJ>m_spec</OBJ>.<OO>m_eof_throw_code</OO>,
                                                       <OBJ>m_spec</OBJ>.<OO>m_eof_throw_read</OO>,
                                                       <CONSTANT>EOF_THROW_CODE</CONSTANT>);
                          <KEYWORD>break</KEYWORD>;
                        }

                      <COMMENT>/* Bad directive. */</COMMENT>
                      <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_DIRECT</OO>,
                                         <OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                      <KEYWORD>break</KEYWORD>;

                    <KEYWORD>case</KEYWORD> <CHARACTER>'f'</CHARACTER><OPERATOR>:</OPERATOR>
                      <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                                 <NUMERIC>0</NUMERIC>,
                                                 m_function_dir,
                                                 <NUMERIC>0</NUMERIC>,
                                                 <OBJ>m_function_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))
                        {
                          <COMMENT>/* Set line counting to ON. */</COMMENT>
                          <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>=</OPERATOR> <OBJ>m_function_dir</OBJ>.<OO>length</OO>;
                          <OBJ>m_spec</OBJ>.<OO>m_function_name</OO> <OPERATOR>=</OPERATOR> getName();
                          <KEYWORD>break</KEYWORD>;
                        }
                      <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                                      <NUMERIC>0</NUMERIC>,
                                                      m_full_dir,
                                                      <NUMERIC>0</NUMERIC>,
                                                      <OBJ>m_full_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))
                        {
                          <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>=</OPERATOR> <OBJ>m_full_dir</OBJ>.<OO>length</OO>;
                          <OBJ>m_spec</OBJ>.<OO>m_dtrans_ncols</OO> <OPERATOR>=</OPERATOR> <OBJ>CUtility</OBJ>.<OO>MAX_EIGHT_BIT</OO> <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>;
                          <KEYWORD>break</KEYWORD>;
                        }

                      <COMMENT>/* Bad directive. */</COMMENT>
                      <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_DIRECT</OO>,
                                         <OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                      <KEYWORD>break</KEYWORD>;

                    <KEYWORD>case</KEYWORD> <CHARACTER>'i'</CHARACTER><OPERATOR>:</OPERATOR>
                      <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                                 <NUMERIC>0</NUMERIC>,
                                                 m_integer_dir,
                                                 <NUMERIC>0</NUMERIC>,
                                                 <OBJ>m_integer_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))
                        {
                          <COMMENT>/* Set line counting to ON. */</COMMENT>
                          <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>=</OPERATOR> <OBJ>m_integer_dir</OBJ>.<OO>length</OO>;
                          <OBJ>m_spec</OBJ>.<OO>m_integer_type</OO> <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
                          <KEYWORD>break</KEYWORD>;
                        }
                      <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                                      <NUMERIC>0</NUMERIC>,
                                                      m_intwrap_dir,
                                                      <NUMERIC>0</NUMERIC>,
                                                      <OBJ>m_intwrap_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))
                        {
                          <COMMENT>/* Set line counting to ON. */</COMMENT>
                          <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>=</OPERATOR> <OBJ>m_integer_dir</OBJ>.<OO>length</OO>;
                          <OBJ>m_spec</OBJ>.<OO>m_intwrap_type</OO> <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
                          <KEYWORD>break</KEYWORD>;
                        }
                      <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                                      <NUMERIC>0</NUMERIC>,
                                                      m_init_code_dir,
                                                      <NUMERIC>0</NUMERIC>,
                                                      <OBJ>m_init_code_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))
                        {
                          <OBJ>m_spec</OBJ>.<OO>m_init_code</OO> <OPERATOR>=</OPERATOR> packCode(m_init_code_dir,
                                                        m_init_code_end_dir,
                                                        <OBJ>m_spec</OBJ>.<OO>m_init_code</OO>,
                                                        <OBJ>m_spec</OBJ>.<OO>m_init_read</OO>,
                                                        <CONSTANT>INIT_CODE</CONSTANT>);
                          <KEYWORD>break</KEYWORD>;
                        }
                      <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                                      <NUMERIC>0</NUMERIC>,
                                                      m_init_throw_code_dir,
                                                      <NUMERIC>0</NUMERIC>,
                                                      <OBJ>m_init_throw_code_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))
                        {
                          <OBJ>m_spec</OBJ>.<OO>m_init_throw_code</OO> <OPERATOR>=</OPERATOR> packCode(m_init_throw_code_dir,
                                                       m_init_throw_code_end_dir,
                                                       <OBJ>m_spec</OBJ>.<OO>m_init_throw_code</OO>,
                                                       <OBJ>m_spec</OBJ>.<OO>m_init_throw_read</OO>,
                                                       <CONSTANT>INIT_THROW_CODE</CONSTANT>);
                          <KEYWORD>break</KEYWORD>;
                        }
                      <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                                      <NUMERIC>0</NUMERIC>,
                                                      m_implements_dir,
                                                      <NUMERIC>0</NUMERIC>,
                                                      <OBJ>m_implements_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))
                        {
                          <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>=</OPERATOR> <OBJ>m_implements_dir</OBJ>.<OO>length</OO>;
                          <OBJ>m_spec</OBJ>.<OO>m_implements_name</OO> <OPERATOR>=</OPERATOR> getName();
                          <KEYWORD>break</KEYWORD>;
                        }
                      <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                                      <NUMERIC>0</NUMERIC>,
                                                      m_ignorecase_dir,
                                                      <NUMERIC>0</NUMERIC>,
                                                      <OBJ>m_ignorecase_dir</OBJ>.<OO>length</OO><OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC>))
                        {
                          <COMMENT>/* Set m_ignorecase to ON. */</COMMENT>
                          <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>=</OPERATOR> <OBJ>m_ignorecase_dir</OBJ>.<OO>length</OO>;
                          <OBJ>m_spec</OBJ>.<OO>m_ignorecase</OO> <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
                          <KEYWORD>break</KEYWORD>;
                        }

                      <COMMENT>/* Bad directive. */</COMMENT>
                      <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_DIRECT</OO>,
                                         <OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                      <KEYWORD>break</KEYWORD>;

                    <KEYWORD>case</KEYWORD> <CHARACTER>'l'</CHARACTER><OPERATOR>:</OPERATOR>
                      <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                                 <NUMERIC>0</NUMERIC>,
                                                 m_line_dir,
                                                 <NUMERIC>0</NUMERIC>,
                                                 <OBJ>m_line_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))
                        {
                          <COMMENT>/* Set line counting to ON. */</COMMENT>
                          <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>=</OPERATOR> <OBJ>m_line_dir</OBJ>.<OO>length</OO>;
                          <OBJ>m_spec</OBJ>.<OO>m_count_lines</OO> <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
                          <KEYWORD>break</KEYWORD>;
                        }

                      <COMMENT>/* Bad directive. */</COMMENT>
                      <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_DIRECT</OO>,
                                         <OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                      <KEYWORD>break</KEYWORD>;

                    <KEYWORD>case</KEYWORD> <CHARACTER>'n'</CHARACTER><OPERATOR>:</OPERATOR>
                      <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                                 <NUMERIC>0</NUMERIC>,
                                                 m_notunix_dir,
                                                 <NUMERIC>0</NUMERIC>,
                                                 <OBJ>m_notunix_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))
                        {
                          <COMMENT>/* Set line counting to ON. */</COMMENT>
                          <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>=</OPERATOR> <OBJ>m_notunix_dir</OBJ>.<OO>length</OO>;
                          <OBJ>m_spec</OBJ>.<OO>m_unix</OO> <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
                          <KEYWORD>break</KEYWORD>;
                        }

                      <COMMENT>/* Bad directive. */</COMMENT>
                      <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_DIRECT</OO>,
                                         <OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                      <KEYWORD>break</KEYWORD>;

                    <KEYWORD>case</KEYWORD> <CHARACTER>'p'</CHARACTER><OPERATOR>:</OPERATOR>
                      <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                                 <NUMERIC>0</NUMERIC>,
                                                 m_public_dir,
                                                 <NUMERIC>0</NUMERIC>,
                                                 <OBJ>m_public_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))
                        {
                          <COMMENT>/* Set public flag. */</COMMENT>
                          <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>=</OPERATOR> <OBJ>m_public_dir</OBJ>.<OO>length</OO>;
                          <OBJ>m_spec</OBJ>.<OO>m_public</OO> <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
                          <KEYWORD>break</KEYWORD>;
                        }

                      <COMMENT>/* Bad directive. */</COMMENT>
                      <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_DIRECT</OO>,
                                         <OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                      <KEYWORD>break</KEYWORD>;

                    <KEYWORD>case</KEYWORD> <CHARACTER>'s'</CHARACTER><OPERATOR>:</OPERATOR>
                      <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                                 <NUMERIC>0</NUMERIC>,
                                                 m_state_dir,
                                                 <NUMERIC>0</NUMERIC>,
                                                 <OBJ>m_state_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))
                        {
                          <COMMENT>/* Recognize state list. */</COMMENT>
                          <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>=</OPERATOR> <OBJ>m_state_dir</OBJ>.<OO>length</OO>;
                          saveStates();
                          <KEYWORD>break</KEYWORD>;
                        }

                      <COMMENT>/* Undefined directive. */</COMMENT>
                      <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_DIRECT</OO>,
                                         <OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                      <KEYWORD>break</KEYWORD>;

                    <KEYWORD>case</KEYWORD> <CHARACTER>'t'</CHARACTER><OPERATOR>:</OPERATOR>
                      <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                                 <NUMERIC>0</NUMERIC>,
                                                 m_type_dir,
                                                 <NUMERIC>0</NUMERIC>,
                                                 <OBJ>m_type_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))
                        {
                          <COMMENT>/* Set Java CUP compatibility to ON. */</COMMENT>
                          <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>=</OPERATOR> <OBJ>m_type_dir</OBJ>.<OO>length</OO>;
                          <OBJ>m_spec</OBJ>.<OO>m_type_name</OO> <OPERATOR>=</OPERATOR> getName();
                          <KEYWORD>break</KEYWORD>;
                        }

                      <COMMENT>/* Undefined directive. */</COMMENT>
                      <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_DIRECT</OO>,
                                         <OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                      <KEYWORD>break</KEYWORD>;

                    <KEYWORD>case</KEYWORD> <CHARACTER>'u'</CHARACTER><OPERATOR>:</OPERATOR>
                      <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                                 <NUMERIC>0</NUMERIC>,
                                                 m_unicode_dir,
                                                 <NUMERIC>0</NUMERIC>,
                                                 <OBJ>m_unicode_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))
                        {
                          <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>=</OPERATOR> <OBJ>m_unicode_dir</OBJ>.<OO>length</OO>;
                          <OBJ>m_spec</OBJ>.<OO>m_dtrans_ncols</OO><OPERATOR>=</OPERATOR> <OBJ>CUtility</OBJ>.<OO>MAX_SIXTEEN_BIT</OO> <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>;
                          <KEYWORD>break</KEYWORD>;
                        }

                      <COMMENT>/* Bad directive. */</COMMENT>
                      <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_DIRECT</OO>,
                                         <OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                      <KEYWORD>break</KEYWORD>;

                    <KEYWORD>case</KEYWORD> <CHARACTER>'y'</CHARACTER><OPERATOR>:</OPERATOR>
                      <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                                 <NUMERIC>0</NUMERIC>,
                                                 m_yyeof_dir,
                                                 <NUMERIC>0</NUMERIC>,
                                                 <OBJ>m_yyeof_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))
                        {
                          <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>=</OPERATOR> <OBJ>m_yyeof_dir</OBJ>.<OO>length</OO>;
                          <OBJ>m_spec</OBJ>.<OO>m_yyeof</OO> <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
                          <KEYWORD>break</KEYWORD>;
                        } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>charncmp</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                                          <NUMERIC>0</NUMERIC>,
                                                          m_yylex_throw_code_dir,
                                                          <NUMERIC>0</NUMERIC>,
                                                          <OBJ>m_yylex_throw_code_dir</OBJ>.<OO>length</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))
                        {
                          <OBJ>m_spec</OBJ>.<OO>m_yylex_throw_code</OO> <OPERATOR>=</OPERATOR> packCode(m_yylex_throw_code_dir,
                                                               m_yylex_throw_code_end_dir,
                                                       <OBJ>m_spec</OBJ>.<OO>m_yylex_throw_code</OO>,
                                                       <OBJ>m_spec</OBJ>.<OO>m_yylex_throw_read</OO>,
                                                       <CONSTANT>YYLEX_THROW_CODE</CONSTANT>);
                          <KEYWORD>break</KEYWORD>;
                        }


                      <COMMENT>/* Bad directive. */</COMMENT>
                      <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_DIRECT</OO>,
                                         <OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                      <KEYWORD>break</KEYWORD>;

                    <KEYWORD>default</KEYWORD><OPERATOR>:</OPERATOR>
                      <COMMENT>/* Undefined directive. */</COMMENT>
                      <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_DIRECT</OO>,
                                         <OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                      <KEYWORD>break</KEYWORD>;
                    }
                }
              <KEYWORD>else</KEYWORD>
                {
                  <COMMENT>/* Regular expression macro. */</COMMENT>
                  <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
                  saveMacro();
                }

              <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>OLD_DEBUG</OO>)
                {
                  <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Line number "</STRING>
                                     <OPERATOR>+</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_number</OO> <OPERATOR>+</OPERATOR> <STRING>":"</STRING>);
                  <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                              <NUMERIC>0</NUMERIC>,<OBJ>m_input</OBJ>.<OO>m_line_read</OO>));
                }
            }
        }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: userRules</COMMENT>
<COMMENT>    Description: Processes third section of JLex</COMMENT>
<COMMENT>    specification and creates minimized transition table.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> userRules
    (
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
      {
        <TYPE>int</TYPE> code;

        <KEYWORD>if</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> m_init_flag)
          {
            <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_INIT</OO>,<NUMERIC>0</NUMERIC>);
          }

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <KEYWORD>this</KEYWORD>);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_outstream);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_input);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_tokens);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_spec);
          }

        <COMMENT>/* UNDONE: Need to handle states preceding rules. */</COMMENT>

        <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_verbose</OO>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Creating NFA machine representation."</STRING>);
          }
        <OBJ>m_makeNfa</OBJ>.<OO>allocate_BOL_EOF</OO>(m_spec);
        <OBJ>m_makeNfa</OBJ>.<OO>thompson</OO>(<KEYWORD>this</KEYWORD>,m_spec,m_input);

        <OBJ>m_simplifyNfa</OBJ>.<OO>simplify</OO>(m_spec);

        <COMMENT>/*print_nfa();*/</COMMENT>

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<CONSTANT>END_OF_INPUT</CONSTANT> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>);
          }

        <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_verbose</OO>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Creating DFA transition table."</STRING>);
          }
        <OBJ>m_nfa2dfa</OBJ>.<OO>make_dfa</OO>(<KEYWORD>this</KEYWORD>,m_spec);

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>FOODEBUG</OO>) {
          print_header();
        }

        <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_verbose</OO>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Minimizing DFA transition table."</STRING>);
          }
        <OBJ>m_minimize</OBJ>.<OO>min_dfa</OO>(m_spec);
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: printccl</COMMENT>
<COMMENT>    Description: Debugging routine that outputs readable form</COMMENT>
<COMMENT>    of character class.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> printccl
    (
     CSet set
     )
      {
        <TYPE>int</TYPE> i;

        <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>" ["</STRING>);
        <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dtrans_ncols</OO>; <OPERATOR>++</OPERATOR>i)
          {
            <KEYWORD>if</KEYWORD> (<OBJ>set</OBJ>.<OO>contains</OO>(i))
              {
                <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(interp_int(i));
              }
          }
        <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<CHARACTER>']'</CHARACTER>);
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: plab</COMMENT>
<COMMENT>    Description:</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>String</TYPE> plab
    (
     CNfa state
     )
      {
        <TYPE>int</TYPE> index;

        <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>==</OPERATOR> state)
          {
            <KEYWORD>return</KEYWORD> (<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<STRING>"--"</STRING>));
          }

        index <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_nfa_states</OO>.<OO>indexOf</OO>(state);

        <KEYWORD>return</KEYWORD> ((<KEYWORD>new</KEYWORD> <TYPE>Integer</TYPE>(index)).toString());
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: interp_int</COMMENT>
<COMMENT>    Description:</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>String</TYPE> interp_int
    (
     <TYPE>int</TYPE> i
     )
      {
        <KEYWORD>switch</KEYWORD> (i)
          {
          <KEYWORD>case</KEYWORD> (<TYPE>int</TYPE>) <CHARACTER>'<ESC>\b</ESC>'</CHARACTER><OPERATOR>:</OPERATOR>
            <KEYWORD>return</KEYWORD> (<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<STRING>"<ESC>\\</ESC>b"</STRING>));

          <KEYWORD>case</KEYWORD> (<TYPE>int</TYPE>) <CHARACTER>'<ESC>\t</ESC>'</CHARACTER><OPERATOR>:</OPERATOR>
            <KEYWORD>return</KEYWORD> (<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<STRING>"<ESC>\\</ESC>t"</STRING>));

          <KEYWORD>case</KEYWORD> (<TYPE>int</TYPE>) <CHARACTER>'<ESC>\n</ESC>'</CHARACTER><OPERATOR>:</OPERATOR>
            <KEYWORD>return</KEYWORD> (<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<STRING>"<ESC>\\</ESC>n"</STRING>));

          <KEYWORD>case</KEYWORD> (<TYPE>int</TYPE>) <CHARACTER>'<ESC>\f</ESC>'</CHARACTER><OPERATOR>:</OPERATOR>
            <KEYWORD>return</KEYWORD> (<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<STRING>"<ESC>\\</ESC>f"</STRING>));

          <KEYWORD>case</KEYWORD> (<TYPE>int</TYPE>) <CHARACTER>'<ESC>\r</ESC>'</CHARACTER><OPERATOR>:</OPERATOR>
            <KEYWORD>return</KEYWORD> (<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<STRING>"<ESC>\\</ESC>r"</STRING>));

          <KEYWORD>case</KEYWORD> (<TYPE>int</TYPE>) <CHARACTER>' '</CHARACTER><OPERATOR>:</OPERATOR>
            <KEYWORD>return</KEYWORD> (<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<STRING>"<ESC>\\</ESC> "</STRING>));

          <KEYWORD>default</KEYWORD><OPERATOR>:</OPERATOR>
            <KEYWORD>return</KEYWORD> ((<KEYWORD>new</KEYWORD> <TYPE>Character</TYPE>((<TYPE>char</TYPE>) i)).toString());
          }
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: print_nfa</COMMENT>
<COMMENT>    Description:</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <TYPE>void</TYPE> print_nfa
    (
     )
      {
        <TYPE>int</TYPE> elem;
        CNfa nfa;
        <TYPE>int</TYPE> size;
        <TYPE>Enumeration</TYPE> states;
        <TYPE>Integer</TYPE> index;
        <TYPE>int</TYPE> i;
        <TYPE>int</TYPE> j;
        <TYPE>int</TYPE> vsize;
        <TYPE>String</TYPE> state;

        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"--------------------- NFA -----------------------"</STRING>);

        size <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_nfa_states</OO>.<OO>size</OO>();
        <KEYWORD>for</KEYWORD> (elem <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; elem <OPERATOR>&lt;</OPERATOR> size; <OPERATOR>++</OPERATOR>elem)
          {
            nfa <OPERATOR>=</OPERATOR> (CNfa) <OBJ>m_spec</OBJ>.<OO>m_nfa_states</OO>.<OO>elementAt</OO>(elem);

            <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>"Nfa state "</STRING> <OPERATOR>+</OPERATOR> plab(nfa) <OPERATOR>+</OPERATOR> <STRING>": "</STRING>);

            <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>nfa</OBJ>.<OO>m_next</OO>)
              {
                <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>"(TERMINAL)"</STRING>);
              }
            <KEYWORD>else</KEYWORD>
              {
                <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>"--&gt; "</STRING> <OPERATOR>+</OPERATOR> plab(<OBJ>nfa</OBJ>.<OO>m_next</OO>));
                <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>"--&gt; "</STRING> <OPERATOR>+</OPERATOR> plab(<OBJ>nfa</OBJ>.<OO>m_next2</OO>));

                <KEYWORD>switch</KEYWORD> (<OBJ>nfa</OBJ>.<OO>m_edge</OO>)
                  {
                  <KEYWORD>case</KEYWORD> <OBJ>CNfa</OBJ>.<OO>CCL</OO><OPERATOR>:</OPERATOR>
                    printccl(<OBJ>nfa</OBJ>.<OO>m_set</OO>);
                    <KEYWORD>break</KEYWORD>;

                  <KEYWORD>case</KEYWORD> <OBJ>CNfa</OBJ>.<OO>EPSILON</OO><OPERATOR>:</OPERATOR>
                    <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>" EPSILON "</STRING>);
                    <KEYWORD>break</KEYWORD>;

                  <KEYWORD>default</KEYWORD><OPERATOR>:</OPERATOR>
                    <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>" "</STRING> <OPERATOR>+</OPERATOR> interp_int(<OBJ>nfa</OBJ>.<OO>m_edge</OO>));
                    <KEYWORD>break</KEYWORD>;
                  }
              }

            <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> elem)
              {
                <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>" (START STATE)"</STRING>);
              }

            <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>nfa</OBJ>.<OO>m_accept</OO>)
              {
                <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>" accepting "</STRING>
                                 <OPERATOR>+</OPERATOR> ((<NUMERIC>0</NUMERIC> <OPERATOR>!=</OPERATOR> (<OBJ>nfa</OBJ>.<OO>m_anchor</OO> <OPERATOR>&amp;</OPERATOR> <OBJ>CSpec</OBJ>.<OO>START</OO>)) <OPERATOR>?</OPERATOR> <STRING>"^"</STRING> <OPERATOR>:</OPERATOR> <STRING>""</STRING>)
                                 <OPERATOR>+</OPERATOR> <STRING>"&lt;"</STRING>
                                 <OPERATOR>+</OPERATOR> (<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>nfa</OBJ>.<OO>m_accept</OO>.<OO>m_action</OO>,<NUMERIC>0</NUMERIC>,
                                               <OBJ>nfa</OBJ>.<OO>m_accept</OO>.<OO>m_action_read</OO>))
                                 <OPERATOR>+</OPERATOR> <STRING>"&gt;"</STRING>
                                 <OPERATOR>+</OPERATOR> ((<NUMERIC>0</NUMERIC> <OPERATOR>!=</OPERATOR> (<OBJ>nfa</OBJ>.<OO>m_anchor</OO> <OPERATOR>&amp;</OPERATOR> <OBJ>CSpec</OBJ>.<OO>END</OO>)) <OPERATOR>?</OPERATOR> <STRING>"$"</STRING> <OPERATOR>:</OPERATOR> <STRING>""</STRING>));
              }

            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>();
          }

        states <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_states</OO>.<OO>keys</OO>();
        <KEYWORD>while</KEYWORD> (<OBJ>states</OBJ>.<OO>hasMoreElements</OO>())
          {
            state <OPERATOR>=</OPERATOR> (<TYPE>String</TYPE>) <OBJ>states</OBJ>.<OO>nextElement</OO>();
            index <OPERATOR>=</OPERATOR> (<TYPE>Integer</TYPE>) <OBJ>m_spec</OBJ>.<OO>m_states</OO>.<OO>get</OO>(state);

            <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
              {
                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> state);
                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> index);
              }

            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"State <ESC>\"</ESC>"</STRING> <OPERATOR>+</OPERATOR> state
                               <OPERATOR>+</OPERATOR> <STRING>"<ESC>\"</ESC> has identifying index "</STRING>
                               <OPERATOR>+</OPERATOR> <OBJ>index</OBJ>.<OO>toString</OO>() <OPERATOR>+</OPERATOR> <STRING>"."</STRING>);
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>"<ESC>\t</ESC>Start states of matching rules: "</STRING>);

            i <OPERATOR>=</OPERATOR> <OBJ>index</OBJ>.<OO>intValue</OO>();
            vsize <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_state_rules</OO>[i].size();

            <KEYWORD>for</KEYWORD> (j <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; j <OPERATOR>&lt;</OPERATOR> vsize; <OPERATOR>++</OPERATOR>j)
              {
                nfa <OPERATOR>=</OPERATOR> (CNfa) <OBJ>m_spec</OBJ>.<OO>m_state_rules</OO>[i].elementAt(j);

                <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<OBJ>m_spec</OBJ>.<OO>m_nfa_states</OO>.<OO>indexOf</OO>(nfa) <OPERATOR>+</OPERATOR> <STRING>" "</STRING>);
              }

            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>();
          }

        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"-------------------- NFA ----------------------"</STRING>);
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: getStates</COMMENT>
<COMMENT>    Description: Parses the state area of a rule,</COMMENT>
<COMMENT>    from the beginning of a line.</COMMENT>
<COMMENT>    &lt; state1, state2 ... &gt; regular_expression { action }</COMMENT>
<COMMENT>    Returns null on only EOF.  Returns all_states,</COMMENT>
<COMMENT>    initialied properly to correspond to all states,</COMMENT>
<COMMENT>    if no states are found.</COMMENT>
<COMMENT>    Special Notes: This function treats commas as optional</COMMENT>
<COMMENT>    and permits states to be spread over multiple lines.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> SparseBitSet all_states <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;
  SparseBitSet getStates
    (
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
      {
        <TYPE>int</TYPE> start_state;
        <TYPE>int</TYPE> count_state;
        SparseBitSet states;
        <TYPE>String</TYPE> name;
        <TYPE>Integer</TYPE> index;
        <TYPE>int</TYPE> i;
        <TYPE>int</TYPE> size;

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <KEYWORD>this</KEYWORD>);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_outstream);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_input);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_tokens);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_spec);
          }

        states <OPERATOR>=</OPERATOR> <KEYWORD>null</KEYWORD>;

        <COMMENT>/* Skip white space. */</COMMENT>
        <KEYWORD>while</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>isspace</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>]))
          {
            <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;

            <KEYWORD>while</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
              {
                <COMMENT>/* Must just be an empty line. */</COMMENT>
                <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>getLine</OO>())
                  {
                    <COMMENT>/* EOF found. */</COMMENT>
                    <KEYWORD>return</KEYWORD> <KEYWORD>null</KEYWORD>;
                  }
              }
          }

        <COMMENT>/* Look for states. */</COMMENT>
        <KEYWORD>if</KEYWORD> (<CHARACTER>'&lt;'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>])
          {
            <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;

            states <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> SparseBitSet();

            <COMMENT>/* Parse states. */</COMMENT>
            <KEYWORD>while</KEYWORD> (<KEYWORD>true</KEYWORD>)
              {
                <COMMENT>/* We may have reached the end of the line. */</COMMENT>
                <KEYWORD>while</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
                  {
                    <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>getLine</OO>())
                      {
                        <COMMENT>/* EOF found. */</COMMENT>
                        <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_EOF</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                        <KEYWORD>return</KEYWORD> states;
                      }
                  }

                <KEYWORD>while</KEYWORD> (<KEYWORD>true</KEYWORD>)
                  {
                    <COMMENT>/* Skip white space. */</COMMENT>
                    <KEYWORD>while</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>isspace</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>]))
                      {
                        <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;

                        <KEYWORD>while</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
                          {
                            <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>getLine</OO>())
                              {
                                <COMMENT>/* EOF found. */</COMMENT>
                                <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_EOF</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                                <KEYWORD>return</KEYWORD> states;
                              }
                          }
                      }

                    <KEYWORD>if</KEYWORD> (<CHARACTER>','</CHARACTER> <OPERATOR>!=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>])
                      {
                        <KEYWORD>break</KEYWORD>;
                      }

                    <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
                  }

                <KEYWORD>if</KEYWORD> (<CHARACTER>'&gt;'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>])
                  {
                    <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
                    <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&lt;</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
                      {
                        m_advance_stop <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
                      }
                    <KEYWORD>return</KEYWORD> states;
                  }

                <COMMENT>/* Read in state name. */</COMMENT>
                start_state <OPERATOR>=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
                <KEYWORD>while</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>isspace</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>])
                       <OPERATOR>&amp;&amp;</OPERATOR> <CHARACTER>','</CHARACTER> <OPERATOR>!=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>]
                       <OPERATOR>&amp;&amp;</OPERATOR> <CHARACTER>'&gt;'</CHARACTER> <OPERATOR>!=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>])
                  {
                    <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;

                    <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
                      {
                        <COMMENT>/* End of line means end of state name. */</COMMENT>
                        <KEYWORD>break</KEYWORD>;
                      }
                  }
                count_state <OPERATOR>=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>-</OPERATOR> start_state;

                <COMMENT>/* Save name after checking definition. */</COMMENT>
                name <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,
                                  start_state,
                                  count_state);
                index <OPERATOR>=</OPERATOR> (<TYPE>Integer</TYPE>) <OBJ>m_spec</OBJ>.<OO>m_states</OO>.<OO>get</OO>(name);
                <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>==</OPERATOR> index)
                  {
                    <COMMENT>/* Uninitialized state. */</COMMENT>
                    <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Uninitialized State Name: "</STRING> <OPERATOR>+</OPERATOR> name);
                    <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_STATE</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                  }
                <OBJ>states</OBJ>.<OO>set</OO>(<OBJ>index</OBJ>.<OO>intValue</OO>());
              }
          }

        <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>==</OPERATOR> all_states)
          {
            all_states <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> SparseBitSet();

            size <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_states</OO>.<OO>size</OO>();
            <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> size; <OPERATOR>++</OPERATOR>i)
              {
                <OBJ>all_states</OBJ>.<OO>set</OO>(i);
              }
          }

        <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&lt;</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
          {
            m_advance_stop <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
          }
        <KEYWORD>return</KEYWORD> all_states;
      }

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: expandMacro</COMMENT>
<COMMENT>    Description: Returns false on error, true otherwise.</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>boolean</TYPE> expandMacro
    (
     )
      {
        <TYPE>int</TYPE> elem;
        <TYPE>int</TYPE> start_macro;
        <TYPE>int</TYPE> end_macro;
        <TYPE>int</TYPE> start_name;
        <TYPE>int</TYPE> count_name;
        <TYPE>String</TYPE> def;
        <TYPE>int</TYPE> def_elem;
        <TYPE>String</TYPE> name;
        <TYPE>char</TYPE> replace[];
        <TYPE>int</TYPE> rep_elem;

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <KEYWORD>this</KEYWORD>);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_outstream);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_input);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_tokens);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_spec);
          }

        <COMMENT>/* Check for macro. */</COMMENT>
        <KEYWORD>if</KEYWORD> (<CHARACTER>'{'</CHARACTER> <OPERATOR>!=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>])
          {
            <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_INTERNAL</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
            <KEYWORD>return</KEYWORD> <CONSTANT>ERROR</CONSTANT>;
          }

        start_macro <OPERATOR>=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
        elem <OPERATOR>=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>;
        <KEYWORD>if</KEYWORD> (elem <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
          {
            <OBJ>CError</OBJ>.<OO>impos</OO>(<STRING>"Unfinished macro name"</STRING>);
            <KEYWORD>return</KEYWORD> <CONSTANT>ERROR</CONSTANT>;
          }

        <COMMENT>/* Get macro name. */</COMMENT>
        start_name <OPERATOR>=</OPERATOR> elem;
        <KEYWORD>while</KEYWORD> (<CHARACTER>'}'</CHARACTER> <OPERATOR>!=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[elem])
          {
            <OPERATOR>++</OPERATOR>elem;
            <KEYWORD>if</KEYWORD> (elem <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
              {
                <OBJ>CError</OBJ>.<OO>impos</OO>(<STRING>"Unfinished macro name at line "</STRING>
                             <OPERATOR>+</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                <KEYWORD>return</KEYWORD> <CONSTANT>ERROR</CONSTANT>;
              }
          }
        count_name <OPERATOR>=</OPERATOR> elem <OPERATOR>-</OPERATOR> start_name;
        end_macro <OPERATOR>=</OPERATOR> elem;

        <COMMENT>/* Check macro name. */</COMMENT>
        <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> count_name)
          {
            <OBJ>CError</OBJ>.<OO>impos</OO>(<STRING>"Nonexistent macro name"</STRING>);
            <KEYWORD>return</KEYWORD> <CONSTANT>ERROR</CONSTANT>;
          }

        <COMMENT>/* Debug checks. */</COMMENT>
        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<NUMERIC>0</NUMERIC> <OPERATOR>&lt;</OPERATOR> count_name);
          }

        <COMMENT>/* Retrieve macro definition. */</COMMENT>
        name <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,start_name,count_name);
        def <OPERATOR>=</OPERATOR> (<TYPE>String</TYPE>) <OBJ>m_spec</OBJ>.<OO>m_macros</OO>.<OO>get</OO>(name);
        <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>==</OPERATOR> def)
          {
            <COMMENT>/*CError.impos("Undefined macro \"" + name + "\".");*/</COMMENT>
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Error: Undefined macro <ESC>\"</ESC>"</STRING> <OPERATOR>+</OPERATOR> name <OPERATOR>+</OPERATOR> <STRING>"<ESC>\"</ESC>."</STRING>);
            <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_NOMAC</OO>, <OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
            <KEYWORD>return</KEYWORD> <CONSTANT>ERROR</CONSTANT>;
          }
        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>OLD_DUMP_DEBUG</OO>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"expanded escape: "</STRING> <OPERATOR>+</OPERATOR> def);
          }

        <COMMENT>/* Replace macro in new buffer,</COMMENT>
<COMMENT>           beginning by copying first part of line buffer. */</COMMENT>
        replace <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>char</TYPE>[<OBJ>m_input</OBJ>.<OO>m_line</OO>.<OO>length</OO>];
        <KEYWORD>for</KEYWORD> (rep_elem <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; rep_elem <OPERATOR>&lt;</OPERATOR> start_macro; <OPERATOR>++</OPERATOR>rep_elem)
          {
            replace[rep_elem] <OPERATOR>=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[rep_elem];

            <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
              {
                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(rep_elem <OPERATOR>&lt;</OPERATOR> <OBJ>replace</OBJ>.<OO>length</OO>);
              }
          }

        <COMMENT>/* Copy macro definition. */</COMMENT>
        <KEYWORD>if</KEYWORD> (rep_elem <OPERATOR>&gt;=</OPERATOR> <OBJ>replace</OBJ>.<OO>length</OO>)
          {
            replace <OPERATOR>=</OPERATOR> <OBJ>CUtility</OBJ>.<OO>doubleSize</OO>(replace);
          }
        <KEYWORD>for</KEYWORD> (def_elem <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; def_elem <OPERATOR>&lt;</OPERATOR> <OBJ>def</OBJ>.<OO>length</OO>(); <OPERATOR>++</OPERATOR>def_elem)
          {
            replace[rep_elem] <OPERATOR>=</OPERATOR> <OBJ>def</OBJ>.<OO>charAt</OO>(def_elem);

            <OPERATOR>++</OPERATOR>rep_elem;
            <KEYWORD>if</KEYWORD> (rep_elem <OPERATOR>&gt;=</OPERATOR> <OBJ>replace</OBJ>.<OO>length</OO>)
              {
                replace <OPERATOR>=</OPERATOR> <OBJ>CUtility</OBJ>.<OO>doubleSize</OO>(replace);
              }
          }

        <COMMENT>/* Copy last part of line. */</COMMENT>
        <KEYWORD>if</KEYWORD> (rep_elem <OPERATOR>&gt;=</OPERATOR> <OBJ>replace</OBJ>.<OO>length</OO>)
          {
            replace <OPERATOR>=</OPERATOR> <OBJ>CUtility</OBJ>.<OO>doubleSize</OO>(replace);
          }
        <KEYWORD>for</KEYWORD> (elem <OPERATOR>=</OPERATOR> end_macro <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>; elem <OPERATOR>&lt;</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>; <OPERATOR>++</OPERATOR>elem)
          {
            replace[rep_elem] <OPERATOR>=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[elem];

            <OPERATOR>++</OPERATOR>rep_elem;
            <KEYWORD>if</KEYWORD> (rep_elem <OPERATOR>&gt;=</OPERATOR> <OBJ>replace</OBJ>.<OO>length</OO>)
              {
                replace <OPERATOR>=</OPERATOR> <OBJ>CUtility</OBJ>.<OO>doubleSize</OO>(replace);
              }
          }

        <COMMENT>/* Replace buffer. */</COMMENT>
        <OBJ>m_input</OBJ>.<OO>m_line</OO> <OPERATOR>=</OPERATOR> replace;
        <OBJ>m_input</OBJ>.<OO>m_line_read</OO> <OPERATOR>=</OPERATOR> rep_elem;

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>OLD_DEBUG</OO>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,<NUMERIC>0</NUMERIC>,<OBJ>m_input</OBJ>.<OO>m_line_read</OO>));
          }
        <KEYWORD>return</KEYWORD> <CONSTANT>NOT_ERROR</CONSTANT>;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: saveMacro</COMMENT>
<COMMENT>    Description: Saves macro definition of form:</COMMENT>
<COMMENT>    macro_name = macro_definition</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> saveMacro
    (
     )
      {
        <TYPE>int</TYPE> elem;
        <TYPE>int</TYPE> start_name;
        <TYPE>int</TYPE> count_name;
        <TYPE>int</TYPE> start_def;
        <TYPE>int</TYPE> count_def;
        <TYPE>boolean</TYPE> saw_escape;
        <TYPE>boolean</TYPE> in_quote;
        <TYPE>boolean</TYPE> in_ccl;

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <KEYWORD>this</KEYWORD>);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_outstream);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_input);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_tokens);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_spec);
          }

        <COMMENT>/* Macro declarations are of the following form:</COMMENT>
<COMMENT>           macro_name macro_definition */</COMMENT>

        elem <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;

        <COMMENT>/* Skip white space preceding macro name. */</COMMENT>
        <KEYWORD>while</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>isspace</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>[elem]))
          {
            <OPERATOR>++</OPERATOR>elem;
            <KEYWORD>if</KEYWORD> (elem <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
              {
                <COMMENT>/* End of line has been reached,</COMMENT>
<COMMENT>                   and line was found to be empty. */</COMMENT>
                <KEYWORD>return</KEYWORD>;
              }
          }

        <COMMENT>/* Read macro name. */</COMMENT>
        start_name <OPERATOR>=</OPERATOR> elem;
        <KEYWORD>while</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>isspace</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>[elem])
               <OPERATOR>&amp;&amp;</OPERATOR> <CHARACTER>'='</CHARACTER> <OPERATOR>!=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[elem])
          {
            <OPERATOR>++</OPERATOR>elem;
            <KEYWORD>if</KEYWORD> (elem <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
              {
                <COMMENT>/* Macro name but no associated definition. */</COMMENT>
                <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_MACDEF</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
              }
          }
        count_name <OPERATOR>=</OPERATOR> elem <OPERATOR>-</OPERATOR> start_name;

        <COMMENT>/* Check macro name. */</COMMENT>
        <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> count_name)
          {
            <COMMENT>/* Nonexistent macro name. */</COMMENT>
            <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_MACDEF</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
          }

        <COMMENT>/* Skip white space between name and definition. */</COMMENT>
        <KEYWORD>while</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>isspace</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>[elem]))
          {
            <OPERATOR>++</OPERATOR>elem;
            <KEYWORD>if</KEYWORD> (elem <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
              {
                <COMMENT>/* Macro name but no associated definition. */</COMMENT>
                <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_MACDEF</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
              }
          }

        <KEYWORD>if</KEYWORD> (<CHARACTER>'='</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[elem])
          {
            <OPERATOR>++</OPERATOR>elem;
            <KEYWORD>if</KEYWORD> (elem <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
              {
                <COMMENT>/* Macro name but no associated definition. */</COMMENT>
                <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_MACDEF</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
              }
          }
        <KEYWORD>else</KEYWORD> <COMMENT>/* macro definition without = */</COMMENT>
                <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_MACDEF</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);

        <COMMENT>/* Skip white space between name and definition. */</COMMENT>
        <KEYWORD>while</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>isspace</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>[elem]))
          {
            <OPERATOR>++</OPERATOR>elem;
            <KEYWORD>if</KEYWORD> (elem <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
              {
                <COMMENT>/* Macro name but no associated definition. */</COMMENT>
                <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_MACDEF</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
              }
          }

        <COMMENT>/* Read macro definition. */</COMMENT>
        start_def <OPERATOR>=</OPERATOR> elem;
        in_quote <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
        in_ccl <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
        saw_escape <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
        <KEYWORD>while</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>isspace</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>[elem])
               <OPERATOR>||</OPERATOR> <KEYWORD>true</KEYWORD> <OPERATOR>==</OPERATOR> in_quote
               <OPERATOR>||</OPERATOR> <KEYWORD>true</KEYWORD> <OPERATOR>==</OPERATOR> in_ccl
               <OPERATOR>||</OPERATOR> <KEYWORD>true</KEYWORD> <OPERATOR>==</OPERATOR> saw_escape)
          {
            <KEYWORD>if</KEYWORD> (<CHARACTER>'<ESC>\"</ESC>'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[elem] <OPERATOR>&amp;&amp;</OPERATOR> <KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> saw_escape)
              {
                in_quote <OPERATOR>=</OPERATOR> <OPERATOR>!</OPERATOR>in_quote;
              }

            <KEYWORD>if</KEYWORD> (<CHARACTER>'<ESC>\\</ESC>'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[elem] <OPERATOR>&amp;&amp;</OPERATOR> <KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> saw_escape)
              {
                saw_escape <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
              }
            <KEYWORD>else</KEYWORD>
              {
                saw_escape <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
              }
            <KEYWORD>if</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> saw_escape <OPERATOR>&amp;&amp;</OPERATOR> <KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> in_quote) { <COMMENT>// CSA, 24-jul-99</COMMENT>
              <KEYWORD>if</KEYWORD> (<CHARACTER>'['</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[elem] <OPERATOR>&amp;&amp;</OPERATOR> <KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> in_ccl)
                in_ccl <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
              <KEYWORD>if</KEYWORD> (<CHARACTER>']'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[elem] <OPERATOR>&amp;&amp;</OPERATOR> <KEYWORD>true</KEYWORD> <OPERATOR>==</OPERATOR> in_ccl)
                in_ccl <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
            }

            <OPERATOR>++</OPERATOR>elem;
            <KEYWORD>if</KEYWORD> (elem <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
              {
                <COMMENT>/* End of line. */</COMMENT>
                <KEYWORD>break</KEYWORD>;
              }
          }
        count_def <OPERATOR>=</OPERATOR> elem <OPERATOR>-</OPERATOR> start_def;

        <COMMENT>/* Check macro definition. */</COMMENT>
        <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> count_def)
          {
            <COMMENT>/* Nonexistent macro name. */</COMMENT>
            <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_MACDEF</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
          }

        <COMMENT>/* Debug checks. */</COMMENT>
        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<NUMERIC>0</NUMERIC> <OPERATOR>&lt;</OPERATOR> count_def);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<NUMERIC>0</NUMERIC> <OPERATOR>&lt;</OPERATOR> count_name);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_macros</OO>);
          }

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>OLD_DEBUG</OO>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"macro name <ESC>\"</ESC>"</STRING>
                               <OPERATOR>+</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,start_name,count_name)
                               <OPERATOR>+</OPERATOR> <STRING>"<ESC>\"</ESC>."</STRING>);
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"macro definition <ESC>\"</ESC>"</STRING>
                               <OPERATOR>+</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,start_def,count_def)
                               <OPERATOR>+</OPERATOR> <STRING>"<ESC>\"</ESC>."</STRING>);
          }

        <COMMENT>/* Add macro name and definition to table. */</COMMENT>
        <OBJ>m_spec</OBJ>.<OO>m_macros</OO>.<OO>put</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,start_name,count_name),
                            <KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,start_def,count_def));
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: saveStates</COMMENT>
<COMMENT>    Description: Takes state declaration and makes entries</COMMENT>
<COMMENT>    for them in state hashtable in CSpec structure.</COMMENT>
<COMMENT>    State declaration should be of the form:</COMMENT>
<COMMENT>    %state name0[, name1, name2 ...]</COMMENT>
<COMMENT>    (But commas are actually optional as long as there is</COMMENT>
<COMMENT>    white space in between them.)</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> saveStates
    (
     )
      {
        <TYPE>int</TYPE> start_state;
        <TYPE>int</TYPE> count_state;

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <KEYWORD>this</KEYWORD>);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_outstream);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_input);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_tokens);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_spec);
          }

        <COMMENT>/* EOF found? */</COMMENT>
        <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_eof_reached</OO>)
          {
            <KEYWORD>return</KEYWORD>;
          }

        <COMMENT>/* Debug checks. */</COMMENT>
        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<CHARACTER>'%'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<NUMERIC>0</NUMERIC>]);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<CHARACTER>'s'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<NUMERIC>1</NUMERIC>]);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&lt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<NUMERIC>0</NUMERIC> <OPERATOR>&lt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_index</OO>);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<NUMERIC>0</NUMERIC> <OPERATOR>&lt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>);
          }

        <COMMENT>/* Blank line?  No states? */</COMMENT>
        <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
          {
            <KEYWORD>return</KEYWORD>;
          }

        <KEYWORD>while</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&lt;</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
          {
            <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>OLD_DEBUG</OO>)
              {
                <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"line read "</STRING> <OPERATOR>+</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>
                                   <OPERATOR>+</OPERATOR> <STRING>"<ESC>\t</ESC>line index = "</STRING> <OPERATOR>+</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_index</OO>);
              }

            <COMMENT>/* Skip white space. */</COMMENT>
            <KEYWORD>while</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>isspace</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>]))
              {
                <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
                <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
                  {
                    <COMMENT>/* No more states to be found. */</COMMENT>
                    <KEYWORD>return</KEYWORD>;
                  }
              }

            <COMMENT>/* Look for state name. */</COMMENT>
            start_state <OPERATOR>=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
            <KEYWORD>while</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>isspace</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>])
                   <OPERATOR>&amp;&amp;</OPERATOR> <CHARACTER>','</CHARACTER> <OPERATOR>!=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>])
              {
                <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
                <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
                  {
                    <COMMENT>/* End of line and end of state name. */</COMMENT>
                    <KEYWORD>break</KEYWORD>;
                  }
              }
            count_state <OPERATOR>=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>-</OPERATOR> start_state;

            <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>OLD_DEBUG</OO>)
              {
                <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"State name <ESC>\"</ESC>"</STRING>
                                   <OPERATOR>+</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,start_state,count_state)
                                   <OPERATOR>+</OPERATOR> <STRING>"<ESC>\"</ESC>."</STRING>);
                <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Integer index <ESC>\"</ESC>"</STRING>
                                   <OPERATOR>+</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_states</OO>.<OO>size</OO>()
                                   <OPERATOR>+</OPERATOR> <STRING>"<ESC>\"</ESC>."</STRING>);
              }

            <COMMENT>/* Enter new state name, along with unique index. */</COMMENT>
            <OBJ>m_spec</OBJ>.<OO>m_states</OO>.<OO>put</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>m_input</OBJ>.<OO>m_line</OO>,start_state,count_state),
                                <KEYWORD>new</KEYWORD> <TYPE>Integer</TYPE>(<OBJ>m_spec</OBJ>.<OO>m_states</OO>.<OO>size</OO>()));

            <COMMENT>/* Skip comma. */</COMMENT>
            <KEYWORD>if</KEYWORD> (<CHARACTER>','</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>])
              {
                <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
                <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
                  {
                    <COMMENT>/* End of line. */</COMMENT>
                    <KEYWORD>return</KEYWORD>;
                  }
              }
          }
      }

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: expandEscape</COMMENT>
<COMMENT>    Description: Takes escape sequence and returns</COMMENT>
<COMMENT>    corresponding character code.</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>char</TYPE> expandEscape
    (
     )
      {
        <TYPE>char</TYPE> r;

        <COMMENT>/* Debug checks. */</COMMENT>
        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&lt;</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<NUMERIC>0</NUMERIC> <OPERATOR>&lt;</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<NUMERIC>0</NUMERIC> <OPERATOR>&lt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_index</OO>);
          }

        <KEYWORD>if</KEYWORD> (<CHARACTER>'<ESC>\\</ESC>'</CHARACTER> <OPERATOR>!=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>])
          {
            <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
            <KEYWORD>return</KEYWORD> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>];
          }
        <KEYWORD>else</KEYWORD>
          {
            <TYPE>boolean</TYPE> unicode_escape <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
            <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
            <KEYWORD>switch</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>])
              {
              <KEYWORD>case</KEYWORD> <CHARACTER>'b'</CHARACTER><OPERATOR>:</OPERATOR>
                <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
                <KEYWORD>return</KEYWORD> <CHARACTER>'<ESC>\b</ESC>'</CHARACTER>;

              <KEYWORD>case</KEYWORD> <CHARACTER>'t'</CHARACTER><OPERATOR>:</OPERATOR>
                <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
                <KEYWORD>return</KEYWORD> <CHARACTER>'<ESC>\t</ESC>'</CHARACTER>;

              <KEYWORD>case</KEYWORD> <CHARACTER>'n'</CHARACTER><OPERATOR>:</OPERATOR>
                <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
                <KEYWORD>return</KEYWORD> <CHARACTER>'<ESC>\n</ESC>'</CHARACTER>;

              <KEYWORD>case</KEYWORD> <CHARACTER>'f'</CHARACTER><OPERATOR>:</OPERATOR>
                <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
                <KEYWORD>return</KEYWORD> <CHARACTER>'<ESC>\f</ESC>'</CHARACTER>;

              <KEYWORD>case</KEYWORD> <CHARACTER>'r'</CHARACTER><OPERATOR>:</OPERATOR>
                <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
                <KEYWORD>return</KEYWORD> <CHARACTER>'<ESC>\r</ESC>'</CHARACTER>;

              <KEYWORD>case</KEYWORD> <CHARACTER>'^'</CHARACTER><OPERATOR>:</OPERATOR>
                <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
                r<OPERATOR>=</OPERATOR><OBJ>Character</OBJ>.<OO>toUpperCase</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>]);
                <KEYWORD>if</KEYWORD> (r<OPERATOR>&lt;</OPERATOR><CHARACTER>'@'</CHARACTER> <OPERATOR>||</OPERATOR> r<OPERATOR>&gt;</OPERATOR><CHARACTER>'Z'</CHARACTER>) <COMMENT>// non-fatal</COMMENT>
                    <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_BADCTRL</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                r <OPERATOR>=</OPERATOR> (<TYPE>char</TYPE>) (r <OPERATOR>-</OPERATOR> <CHARACTER>'@'</CHARACTER>);
                <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
                <KEYWORD>return</KEYWORD> r;

              <KEYWORD>case</KEYWORD> <CHARACTER>'u'</CHARACTER><OPERATOR>:</OPERATOR>
                unicode_escape <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
              <KEYWORD>case</KEYWORD> <CHARACTER>'x'</CHARACTER><OPERATOR>:</OPERATOR>
                <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
                r <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
                <KEYWORD>for</KEYWORD> (<TYPE>int</TYPE> i<OPERATOR>=</OPERATOR><NUMERIC>0</NUMERIC>; i<OPERATOR>&lt;</OPERATOR>(unicode_escape<OPERATOR>?</OPERATOR><NUMERIC>4</NUMERIC><OPERATOR>:</OPERATOR><NUMERIC>2</NUMERIC>); i<OPERATOR>++</OPERATOR>)
                  <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>ishexdigit</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>]))
                    {
                      r <OPERATOR>=</OPERATOR> (<TYPE>char</TYPE>) (r <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>4</NUMERIC>);
                      r <OPERATOR>=</OPERATOR> (<TYPE>char</TYPE>) (r <OPERATOR>|</OPERATOR> <OBJ>CUtility</OBJ>.<OO>hex2bin</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>]));
                      <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
                    }
                  <KEYWORD>else</KEYWORD> <KEYWORD>break</KEYWORD>;

                <KEYWORD>return</KEYWORD> r;

              <KEYWORD>default</KEYWORD><OPERATOR>:</OPERATOR>
                <KEYWORD>if</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>isoctdigit</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>]))
                  {
                    r <OPERATOR>=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>];
                    <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
                  }
                <KEYWORD>else</KEYWORD>
                  {
                    r <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
                    <KEYWORD>for</KEYWORD> (<TYPE>int</TYPE> i<OPERATOR>=</OPERATOR><NUMERIC>0</NUMERIC>; i<OPERATOR>&lt;</OPERATOR><NUMERIC>3</NUMERIC>; i<OPERATOR>++</OPERATOR>)
                      <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>isoctdigit</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>]))
                        {
                          r <OPERATOR>=</OPERATOR> (<TYPE>char</TYPE>) (r <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>3</NUMERIC>);
                          r <OPERATOR>=</OPERATOR> (<TYPE>char</TYPE>) (r <OPERATOR>|</OPERATOR> <OBJ>CUtility</OBJ>.<OO>oct2bin</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>]));
                          <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
                        }
                      <KEYWORD>else</KEYWORD> <KEYWORD>break</KEYWORD>;
                  }
                <KEYWORD>return</KEYWORD> r;
              }
          }
      }

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: packAccept</COMMENT>
<COMMENT>    Description: Packages and returns CAccept</COMMENT>
<COMMENT>    for action next in input stream.</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  CAccept packAccept
    (
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
      {
        CAccept accept;
        <TYPE>char</TYPE> action[];
        <TYPE>int</TYPE> action_index;
        <TYPE>int</TYPE> brackets;
        <TYPE>boolean</TYPE> insinglequotes;
        <TYPE>boolean</TYPE> indoublequotes;
        <TYPE>boolean</TYPE> instarcomment;
        <TYPE>boolean</TYPE> inslashcomment;
        <TYPE>boolean</TYPE> escaped;
        <TYPE>boolean</TYPE> slashed;

        action <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>char</TYPE>[<CONSTANT>BUFFER_SIZE</CONSTANT>];
        action_index <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <KEYWORD>this</KEYWORD>);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_outstream);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_input);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_tokens);
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> m_spec);
          }

        <COMMENT>/* Get a new line, if needed. */</COMMENT>
        <KEYWORD>while</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
          {
            <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>getLine</OO>())
              {
                <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_EOF</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                <KEYWORD>return</KEYWORD> <KEYWORD>null</KEYWORD>;
              }
          }

        <COMMENT>/* Look for beginning of action. */</COMMENT>
        <KEYWORD>while</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>isspace</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>]))
          {
            <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;

            <COMMENT>/* Get a new line, if needed. */</COMMENT>
            <KEYWORD>while</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
              {
                <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>getLine</OO>())
                  {
                    <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_EOF</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                    <KEYWORD>return</KEYWORD> <KEYWORD>null</KEYWORD>;
                  }
              }
          }

        <COMMENT>/* Look for brackets. */</COMMENT>
        <KEYWORD>if</KEYWORD> (<CHARACTER>'{'</CHARACTER> <OPERATOR>!=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>])
          {
            <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_BRACE</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
          }

        <COMMENT>/* Copy new line into action buffer. */</COMMENT>
        brackets <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
        insinglequotes <OPERATOR>=</OPERATOR> indoublequotes <OPERATOR>=</OPERATOR> inslashcomment <OPERATOR>=</OPERATOR> instarcomment <OPERATOR>=</OPERATOR>
        escaped  <OPERATOR>=</OPERATOR> slashed <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
        <KEYWORD>while</KEYWORD> (<KEYWORD>true</KEYWORD>)
          {
            action[action_index] <OPERATOR>=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>];

            <COMMENT>/* Look for quotes. */</COMMENT>
            <KEYWORD>if</KEYWORD> ((insinglequotes <OPERATOR>||</OPERATOR> indoublequotes) <OPERATOR>&amp;&amp;</OPERATOR> escaped)
                escaped<OPERATOR>=</OPERATOR><KEYWORD>false</KEYWORD>; <COMMENT>// only protects one char, but this is enough.</COMMENT>
            <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> ((insinglequotes <OPERATOR>||</OPERATOR> indoublequotes) <OPERATOR>&amp;&amp;</OPERATOR>
                     <CHARACTER>'<ESC>\\</ESC>'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>])
                escaped<OPERATOR>=</OPERATOR><KEYWORD>true</KEYWORD>;
            <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (<OPERATOR>!</OPERATOR>(insinglequotes <OPERATOR>||</OPERATOR> inslashcomment <OPERATOR>||</OPERATOR> instarcomment) <OPERATOR>&amp;&amp;</OPERATOR>
                     <CHARACTER>'<ESC>\"</ESC>'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>])
                indoublequotes<OPERATOR>=!</OPERATOR>indoublequotes; <COMMENT>// unescaped double quote.</COMMENT>
            <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (<OPERATOR>!</OPERATOR>(indoublequotes <OPERATOR>||</OPERATOR> inslashcomment <OPERATOR>||</OPERATOR> instarcomment) <OPERATOR>&amp;&amp;</OPERATOR>
                     <CHARACTER>'<ESC>\'</ESC>'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>])
                insinglequotes<OPERATOR>=!</OPERATOR>insinglequotes; <COMMENT>// unescaped single quote.</COMMENT>
            <COMMENT>/* Look for comments. */</COMMENT>
            <KEYWORD>if</KEYWORD> (instarcomment) { <COMMENT>// inside "/*" comment; look for "*/"</COMMENT>
                <KEYWORD>if</KEYWORD> (slashed <OPERATOR>&amp;&amp;</OPERATOR> <CHARACTER>'/'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>])
                    instarcomment <OPERATOR>=</OPERATOR> slashed <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
                <KEYWORD>else</KEYWORD> <COMMENT>// note that inside a star comment, slashed means starred</COMMENT>
                    slashed <OPERATOR>=</OPERATOR> (<CHARACTER>'*'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>]);
            } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (<OPERATOR>!</OPERATOR>inslashcomment <OPERATOR>&amp;&amp;</OPERATOR> <OPERATOR>!</OPERATOR>insinglequotes <OPERATOR>&amp;&amp;</OPERATOR> <OPERATOR>!</OPERATOR>indoublequotes) {
                <COMMENT>// not in comment, look for /* or //</COMMENT>
                inslashcomment <OPERATOR>=</OPERATOR>
                    (slashed <OPERATOR>&amp;&amp;</OPERATOR> <CHARACTER>'/'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>]);
                instarcomment <OPERATOR>=</OPERATOR>
                    (slashed <OPERATOR>&amp;&amp;</OPERATOR> <CHARACTER>'*'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>]);
                slashed <OPERATOR>=</OPERATOR> (<CHARACTER>'/'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>]);
            }

            <COMMENT>/* Look for brackets. */</COMMENT>
            <KEYWORD>if</KEYWORD> (<OPERATOR>!</OPERATOR>insinglequotes <OPERATOR>&amp;&amp;</OPERATOR> <OPERATOR>!</OPERATOR>indoublequotes <OPERATOR>&amp;&amp;</OPERATOR>
                <OPERATOR>!</OPERATOR>instarcomment <OPERATOR>&amp;&amp;</OPERATOR> <OPERATOR>!</OPERATOR>inslashcomment) {
              <KEYWORD>if</KEYWORD> (<CHARACTER>'{'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>])
                {
                  <OPERATOR>++</OPERATOR>brackets;
                }
              <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (<CHARACTER>'}'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>])
                {
                  <OPERATOR>--</OPERATOR>brackets;

                  <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> brackets)
                    {
                      <OPERATOR>++</OPERATOR>action_index;
                      <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;

                      <KEYWORD>break</KEYWORD>;
                    }
                }
            }

            <OPERATOR>++</OPERATOR>action_index;
            <COMMENT>/* Double the buffer size, if needed. */</COMMENT>
            <KEYWORD>if</KEYWORD> (action_index <OPERATOR>&gt;=</OPERATOR> <OBJ>action</OBJ>.<OO>length</OO>)
              {
                action <OPERATOR>=</OPERATOR> <OBJ>CUtility</OBJ>.<OO>doubleSize</OO>(action);
              }

            <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
            <COMMENT>/* Get a new line, if needed. */</COMMENT>
            <KEYWORD>while</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
              {
                inslashcomment <OPERATOR>=</OPERATOR> slashed <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
                <KEYWORD>if</KEYWORD> (insinglequotes <OPERATOR>||</OPERATOR> indoublequotes) { <COMMENT>// non-fatal</COMMENT>
                    <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_NEWLINE</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                    insinglequotes <OPERATOR>=</OPERATOR> indoublequotes <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
                }
                <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>getLine</OO>())
                  {
                    <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_SYNTAX</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
                    <KEYWORD>return</KEYWORD> <KEYWORD>null</KEYWORD>;
                  }
              }
          }

        accept <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> CAccept(action,action_index,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
          {
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> accept);
          }

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DESCENT_DEBUG</OO>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>"Accepting action:"</STRING>);
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>accept</OBJ>.<OO>m_action</OO>,<NUMERIC>0</NUMERIC>,<OBJ>accept</OBJ>.<OO>m_action_read</OO>));
          }

        <KEYWORD>return</KEYWORD> accept;
      }

  <COMMENT>/********************************************************</COMMENT>
<COMMENT>    Function: advance</COMMENT>
<COMMENT>    Description: Returns code for next token.</COMMENT>
<COMMENT>    *******************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>boolean</TYPE> m_advance_stop <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
  <TYPE>int</TYPE> advance
    (
     )
      <KEYWORD>throws</KEYWORD> <OBJ>java</OBJ>.<OO>io</OO>.<OO>IOException</OO>
      {
        <TYPE>boolean</TYPE> saw_escape <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
        <TYPE>Integer</TYPE> code;

        <COMMENT>/*if (m_input.m_line_index &gt; m_input.m_line_read) {</COMMENT>
<COMMENT>          System.out.println("m_input.m_line_index = " + m_input.m_line_index);</COMMENT>
<COMMENT>          System.out.println("m_input.m_line_read = " + m_input.m_line_read);</COMMENT>
<COMMENT>          CUtility.ASSERT(m_input.m_line_index &lt;= m_input.m_line_read);</COMMENT>
<COMMENT>        }*/</COMMENT>

        <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_eof_reached</OO>)
          {
            <COMMENT>/* EOF has already been reached,</COMMENT>
<COMMENT>               so return appropriate code. */</COMMENT>

            <OBJ>m_spec</OBJ>.<OO>m_current_token</OO> <OPERATOR>=</OPERATOR> <CONSTANT>END_OF_INPUT</CONSTANT>;
            <OBJ>m_spec</OBJ>.<OO>m_lexeme</OO> <OPERATOR>=</OPERATOR> <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>;
            <KEYWORD>return</KEYWORD> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>;
          }

        <COMMENT>/* End of previous regular expression?</COMMENT>
<COMMENT>           Refill line buffer? */</COMMENT>
        <KEYWORD>if</KEYWORD> (EOS <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>
            <COMMENT>/* ADDED */</COMMENT>
            <OPERATOR>||</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
            <COMMENT>/* ADDED */</COMMENT>
          {
            <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_in_quote</OO>)
              {
                <OBJ>CError</OBJ>.<OO>parse_error</OO>(<OBJ>CError</OBJ>.<OO>E_SYNTAX</OO>,<OBJ>m_input</OBJ>.<OO>m_line_number</OO>);
              }

            <KEYWORD>while</KEYWORD> (<KEYWORD>true</KEYWORD>)
              {
                <KEYWORD>if</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> m_advance_stop
                    <OPERATOR>||</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
                  {
                    <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>getLine</OO>())
                      {
                        <COMMENT>/* EOF has already been reached,</COMMENT>
<COMMENT>                           so return appropriate code. */</COMMENT>

                        <OBJ>m_spec</OBJ>.<OO>m_current_token</OO> <OPERATOR>=</OPERATOR> <CONSTANT>END_OF_INPUT</CONSTANT>;
                        <OBJ>m_spec</OBJ>.<OO>m_lexeme</OO> <OPERATOR>=</OPERATOR> <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>;
                        <KEYWORD>return</KEYWORD> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>;
                      }
                    <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
                  }
                <KEYWORD>else</KEYWORD>
                  {
                    m_advance_stop <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
                  }

                <KEYWORD>while</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&lt;</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>
                       <OPERATOR>&amp;&amp;</OPERATOR> <KEYWORD>true</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>CUtility</OBJ>.<OO>isspace</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>]))
                  {
                    <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
                  }

                <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&lt;</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
                  {
                    <KEYWORD>break</KEYWORD>;
                  }
              }
          }

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>) {
          <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&lt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>);
        }

        <KEYWORD>while</KEYWORD> (<KEYWORD>true</KEYWORD>)
          {
            <KEYWORD>if</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_in_quote</OO>
                <OPERATOR>&amp;&amp;</OPERATOR> <CHARACTER>'{'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>])
              {
                <KEYWORD>if</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> expandMacro())
                  {
                    <KEYWORD>break</KEYWORD>;
                  }

                <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
                  {
                    <OBJ>m_spec</OBJ>.<OO>m_current_token</OO> <OPERATOR>=</OPERATOR> EOS;
                    <OBJ>m_spec</OBJ>.<OO>m_lexeme</OO> <OPERATOR>=</OPERATOR> <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>;
                    <KEYWORD>return</KEYWORD> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>;
                  }
              }
            <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (<CHARACTER>'<ESC>\"</ESC>'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>])
              {
                <OBJ>m_spec</OBJ>.<OO>m_in_quote</OO> <OPERATOR>=</OPERATOR> <OPERATOR>!</OPERATOR><OBJ>m_spec</OBJ>.<OO>m_in_quote</OO>;
                <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;

                <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&gt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>)
                  {
                    <OBJ>m_spec</OBJ>.<OO>m_current_token</OO> <OPERATOR>=</OPERATOR> EOS;
                    <OBJ>m_spec</OBJ>.<OO>m_lexeme</OO> <OPERATOR>=</OPERATOR> <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>;
                    <KEYWORD>return</KEYWORD> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>;
                  }
              }
            <KEYWORD>else</KEYWORD>
              {
                <KEYWORD>break</KEYWORD>;
              }
          }

        <KEYWORD>if</KEYWORD> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&gt;</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>) {
          <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"m_input.m_line_index = "</STRING> <OPERATOR>+</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_index</OO>);
          <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"m_input.m_line_read = "</STRING> <OPERATOR>+</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>);
          <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>&lt;=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>);
        }

        <COMMENT>/* Look for backslash, and corresponding</COMMENT>
<COMMENT>           escape sequence. */</COMMENT>
        <KEYWORD>if</KEYWORD> (<CHARACTER>'<ESC>\\</ESC>'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>])
          {
            saw_escape <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
          }
        <KEYWORD>else</KEYWORD>
          {
            saw_escape <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;
          }

        <KEYWORD>if</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_in_quote</OO>)
          {
            <KEYWORD>if</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_in_ccl</OO> <OPERATOR>&amp;&amp;</OPERATOR>
                <OBJ>CUtility</OBJ>.<OO>isspace</OO>(<OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>]))
              {
                <COMMENT>/* White space means the end of</COMMENT>
<COMMENT>                   the current regular expression. */</COMMENT>

                <OBJ>m_spec</OBJ>.<OO>m_current_token</OO> <OPERATOR>=</OPERATOR> EOS;
                <OBJ>m_spec</OBJ>.<OO>m_lexeme</OO> <OPERATOR>=</OPERATOR> <CHARACTER>'<ESC>\0</ESC>'</CHARACTER>;
                <KEYWORD>return</KEYWORD> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>;
              }

            <COMMENT>/* Process escape sequence, if needed. */</COMMENT>
            <KEYWORD>if</KEYWORD> (saw_escape)
              {
                <OBJ>m_spec</OBJ>.<OO>m_lexeme</OO> <OPERATOR>=</OPERATOR> expandEscape();
              }
            <KEYWORD>else</KEYWORD>
              {
                <OBJ>m_spec</OBJ>.<OO>m_lexeme</OO> <OPERATOR>=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>];
                <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
              }
          }
        <KEYWORD>else</KEYWORD>
          {
            <KEYWORD>if</KEYWORD> (saw_escape
                <OPERATOR>&amp;&amp;</OPERATOR> (<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>) <OPERATOR>&lt;</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_read</OO>
                <OPERATOR>&amp;&amp;</OPERATOR> <CHARACTER>'<ESC>\"</ESC>'</CHARACTER> <OPERATOR>==</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>])
              {
                <OBJ>m_spec</OBJ>.<OO>m_lexeme</OO> <OPERATOR>=</OPERATOR> <CHARACTER>'<ESC>\"</ESC>'</CHARACTER>;
                <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_index</OO> <OPERATOR>+</OPERATOR> <NUMERIC>2</NUMERIC>;
              }
            <KEYWORD>else</KEYWORD>
              {
                <OBJ>m_spec</OBJ>.<OO>m_lexeme</OO> <OPERATOR>=</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line</OO>[<OBJ>m_input</OBJ>.<OO>m_line_index</OO>];
                <OPERATOR>++</OPERATOR><OBJ>m_input</OBJ>.<OO>m_line_index</OO>;
              }
          }

        code <OPERATOR>=</OPERATOR> (<TYPE>Integer</TYPE>) <OBJ>m_tokens</OBJ>.<OO>get</OO>(<KEYWORD>new</KEYWORD> <TYPE>Character</TYPE>(<OBJ>m_spec</OBJ>.<OO>m_lexeme</OO>));
        <KEYWORD>if</KEYWORD> (<OBJ>m_spec</OBJ>.<OO>m_in_quote</OO> <OPERATOR>||</OPERATOR> <KEYWORD>true</KEYWORD> <OPERATOR>==</OPERATOR> saw_escape)
          {
            <OBJ>m_spec</OBJ>.<OO>m_current_token</OO> <OPERATOR>=</OPERATOR> L;
          }
        <KEYWORD>else</KEYWORD>
          {
            <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>==</OPERATOR> code)
              {
                <OBJ>m_spec</OBJ>.<OO>m_current_token</OO> <OPERATOR>=</OPERATOR> L;
              }
            <KEYWORD>else</KEYWORD>
              {
                <OBJ>m_spec</OBJ>.<OO>m_current_token</OO> <OPERATOR>=</OPERATOR> <OBJ>code</OBJ>.<OO>intValue</OO>();
              }
          }

        <KEYWORD>if</KEYWORD> (<CONSTANT>CCL_START</CONSTANT> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>) <OBJ>m_spec</OBJ>.<OO>m_in_ccl</OO> <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD>;
        <KEYWORD>if</KEYWORD> (<CONSTANT>CCL_END</CONSTANT>   <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>) <OBJ>m_spec</OBJ>.<OO>m_in_ccl</OO> <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD>;

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>FOODEBUG</OO>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Lexeme: "</STRING> <OPERATOR>+</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_lexeme</OO>
                               <OPERATOR>+</OPERATOR> <STRING>"<ESC>\t</ESC>Token: "</STRING> <OPERATOR>+</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>
                               <OPERATOR>+</OPERATOR> <STRING>"<ESC>\t</ESC>Index: "</STRING> <OPERATOR>+</OPERATOR> <OBJ>m_input</OBJ>.<OO>m_line_index</OO>);
          }

        <KEYWORD>return</KEYWORD> <OBJ>m_spec</OBJ>.<OO>m_current_token</OO>;
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    Function: details</COMMENT>
<COMMENT>    Description: High level debugging routine.</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> details
    (
     )
      {
        <TYPE>Enumeration</TYPE> names;
        <TYPE>String</TYPE> name;
        <TYPE>String</TYPE> def;
        <TYPE>Enumeration</TYPE> states;
        <TYPE>String</TYPE> state;
        <TYPE>Integer</TYPE> index;
        <TYPE>int</TYPE> elem;
        <TYPE>int</TYPE> size;

        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>();
        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>** Macros **"</STRING>);
        names <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_macros</OO>.<OO>keys</OO>();
        <KEYWORD>while</KEYWORD> (<OBJ>names</OBJ>.<OO>hasMoreElements</OO>())
          {
            name <OPERATOR>=</OPERATOR> (<TYPE>String</TYPE>) <OBJ>names</OBJ>.<OO>nextElement</OO>();
            def <OPERATOR>=</OPERATOR> (<TYPE>String</TYPE>) <OBJ>m_spec</OBJ>.<OO>m_macros</OO>.<OO>get</OO>(name);

            <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
              {
                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> name);
                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> def);
              }

            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Macro name <ESC>\"</ESC>"</STRING> <OPERATOR>+</OPERATOR> name
                               <OPERATOR>+</OPERATOR> <STRING>"<ESC>\"</ESC> has definition <ESC>\"</ESC>"</STRING>
                               <OPERATOR>+</OPERATOR> def <OPERATOR>+</OPERATOR> <STRING>"<ESC>\"</ESC>."</STRING>);
          }

        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>();
        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>** States **"</STRING>);
        states <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_states</OO>.<OO>keys</OO>();
        <KEYWORD>while</KEYWORD> (<OBJ>states</OBJ>.<OO>hasMoreElements</OO>())
          {
            state <OPERATOR>=</OPERATOR> (<TYPE>String</TYPE>) <OBJ>states</OBJ>.<OO>nextElement</OO>();
            index <OPERATOR>=</OPERATOR> (<TYPE>Integer</TYPE>) <OBJ>m_spec</OBJ>.<OO>m_states</OO>.<OO>get</OO>(state);

            <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
              {
                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> state);
                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> index);
              }

            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"State <ESC>\"</ESC>"</STRING> <OPERATOR>+</OPERATOR> state
                               <OPERATOR>+</OPERATOR> <STRING>"<ESC>\"</ESC> has identifying index "</STRING>
                               <OPERATOR>+</OPERATOR> <OBJ>index</OBJ>.<OO>toString</OO>() <OPERATOR>+</OPERATOR> <STRING>"."</STRING>);
          }

        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>();
        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>** Character Counting **"</STRING>);
        <KEYWORD>if</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_count_chars</OO>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Character counting is off."</STRING>);
          }
        <KEYWORD>else</KEYWORD>
          {
            <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
              {
                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>m_spec</OBJ>.<OO>m_count_lines</OO>);
              }

            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Character counting is on."</STRING>);
          }

        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>();
        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>** Line Counting **"</STRING>);
        <KEYWORD>if</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_count_lines</OO>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Line counting is off."</STRING>);
          }
        <KEYWORD>else</KEYWORD>
          {
            <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
              {
                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>m_spec</OBJ>.<OO>m_count_lines</OO>);
              }

            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Line counting is on."</STRING>);
          }

        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>();
        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>** Operating System Specificity **"</STRING>);
        <KEYWORD>if</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_unix</OO>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Not generating UNIX-specific code."</STRING>);
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"(This means that <ESC>\"</ESC><ESC>\\</ESC>r<ESC>\\</ESC>n<ESC>\"</ESC> is a "</STRING>
                               <OPERATOR>+</OPERATOR> <STRING>"newline, rather than <ESC>\"</ESC><ESC>\\</ESC>n<ESC>\"</ESC>.)"</STRING>);
          }
        <KEYWORD>else</KEYWORD>
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Generating UNIX-specific code."</STRING>);
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"(This means that <ESC>\"</ESC><ESC>\\</ESC>n<ESC>\"</ESC> is a "</STRING>
                               <OPERATOR>+</OPERATOR> <STRING>"newline, rather than <ESC>\"</ESC><ESC>\\</ESC>r<ESC>\\</ESC>n<ESC>\"</ESC>.)"</STRING>);
          }

        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>();
        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>** Java CUP Compatibility **"</STRING>);
        <KEYWORD>if</KEYWORD> (<KEYWORD>false</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_cup_compatible</OO>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Generating CUP compatible code."</STRING>);
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"(Scanner implements "</STRING>
                               <OPERATOR>+</OPERATOR> <STRING>"java_cup.runtime.Scanner.)"</STRING>);
          }
        <KEYWORD>else</KEYWORD>
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Not generating CUP compatible code."</STRING>);
          }

        <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>FOODEBUG</OO>) {
          <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_nfa_states</OO> <OPERATOR>&amp;&amp;</OPERATOR> <KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_nfa_start</OO>)
            {
              <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>();
              <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>** NFA machine **"</STRING>);
              print_nfa();
          }
        }

        <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>();
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>** DFA transition table **"</STRING>);
            <COMMENT>/*print_header();*/</COMMENT>
          }

        <COMMENT>/*if (null != m_spec.m_accept_vector &amp;&amp; null != m_spec.m_anchor_array)</COMMENT>
<COMMENT>          {</COMMENT>
<COMMENT>            System.out.println();</COMMENT>
<COMMENT>            System.out.println("\t** Accept States and Anchor Vector **");</COMMENT>
<COMMENT>            print_accept();</COMMENT>
<COMMENT>          }*/</COMMENT>
      }

  <COMMENT>/***************************************************************</COMMENT>
<COMMENT>    function: print_set</COMMENT>
<COMMENT>    **************************************************************/</COMMENT>
  <TYPE>void</TYPE> print_set
    (
     <TYPE>Vector</TYPE> nfa_set
     )
      {
        <TYPE>int</TYPE> size;
        <TYPE>int</TYPE> elem;
        CNfa nfa;

        size <OPERATOR>=</OPERATOR> <OBJ>nfa_set</OBJ>.<OO>size</OO>();

        <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC> <OPERATOR>==</OPERATOR> size)
          {
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>"empty "</STRING>);
          }

        <KEYWORD>for</KEYWORD> (elem <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; elem <OPERATOR>&lt;</OPERATOR> size; <OPERATOR>++</OPERATOR>elem)
          {
            nfa <OPERATOR>=</OPERATOR> (CNfa) <OBJ>nfa_set</OBJ>.<OO>elementAt</OO>(elem);
            <COMMENT>/*System.out.print(m_spec.m_nfa_states.indexOf(nfa) + " ");*/</COMMENT>
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<OBJ>nfa</OBJ>.<OO>m_label</OO> <OPERATOR>+</OPERATOR> <STRING>" "</STRING>);
          }
      }

   <COMMENT>/***************************************************************</COMMENT>
<COMMENT>     Function: print_header</COMMENT>
<COMMENT>     **************************************************************/</COMMENT>
  <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> print_header
    (
     )
      {
        <TYPE>Enumeration</TYPE> states;
        <TYPE>int</TYPE> i;
        <TYPE>int</TYPE> j;
        <TYPE>int</TYPE> chars_printed<OPERATOR>=</OPERATOR><NUMERIC>0</NUMERIC>;
        CDTrans dtrans;
        <TYPE>int</TYPE> last_transition;
        <TYPE>String</TYPE> str;
        CAccept accept;
        <TYPE>String</TYPE> state;
        <TYPE>Integer</TYPE> index;

        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"/*---------------------- DFA -----------------------"</STRING>);

        states <OPERATOR>=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_states</OO>.<OO>keys</OO>();
        <KEYWORD>while</KEYWORD> (<OBJ>states</OBJ>.<OO>hasMoreElements</OO>())
          {
            state <OPERATOR>=</OPERATOR> (<TYPE>String</TYPE>) <OBJ>states</OBJ>.<OO>nextElement</OO>();
            index <OPERATOR>=</OPERATOR> (<TYPE>Integer</TYPE>) <OBJ>m_spec</OBJ>.<OO>m_states</OO>.<OO>get</OO>(state);

            <KEYWORD>if</KEYWORD> (<OBJ>CUtility</OBJ>.<OO>DEBUG</OO>)
              {
                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> state);
                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<KEYWORD>null</KEYWORD> <OPERATOR>!=</OPERATOR> index);
              }

            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"State <ESC>\"</ESC>"</STRING> <OPERATOR>+</OPERATOR> state
                               <OPERATOR>+</OPERATOR> <STRING>"<ESC>\"</ESC> has identifying index "</STRING>
                               <OPERATOR>+</OPERATOR> <OBJ>index</OBJ>.<OO>toString</OO>() <OPERATOR>+</OPERATOR> <STRING>"."</STRING>);

            i <OPERATOR>=</OPERATOR> <OBJ>index</OBJ>.<OO>intValue</OO>();
            <KEYWORD>if</KEYWORD> (<OBJ>CDTrans</OBJ>.<OO>F</OO> <OPERATOR>!=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_state_dtrans</OO>[i])
              {
                <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>Start index in transition table: "</STRING>
                                   <OPERATOR>+</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_state_dtrans</OO>[i]);
              }
            <KEYWORD>else</KEYWORD>
              {
                <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"<ESC>\t</ESC>No associated transition states."</STRING>);
              }
          }

        <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>size</OO>(); <OPERATOR>++</OPERATOR>i)
          {
            dtrans <OPERATOR>=</OPERATOR> (CDTrans) <OBJ>m_spec</OBJ>.<OO>m_dtrans_vector</OO>.<OO>elementAt</OO>(i);

            <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_accept_vector</OO> <OPERATOR>&amp;&amp;</OPERATOR> <KEYWORD>null</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_anchor_array</OO>)
              {
                <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>==</OPERATOR> <OBJ>dtrans</OBJ>.<OO>m_accept</OO>)
                  {
                    <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>" * State "</STRING> <OPERATOR>+</OPERATOR> i <OPERATOR>+</OPERATOR> <STRING>" [nonaccepting]"</STRING>);
                  }
                <KEYWORD>else</KEYWORD>
                  {
                    <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>" * State "</STRING> <OPERATOR>+</OPERATOR> i
                                     <OPERATOR>+</OPERATOR> <STRING>" [accepting, line "</STRING>
                                     <OPERATOR>+</OPERATOR> <OBJ>dtrans</OBJ>.<OO>m_accept</OO>.<OO>m_line_number</OO>
                                     <OPERATOR>+</OPERATOR> <STRING>" &lt;"</STRING>
                                     <OPERATOR>+</OPERATOR> (<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>dtrans</OBJ>.<OO>m_accept</OO>.<OO>m_action</OO>,<NUMERIC>0</NUMERIC>,
                                                   <OBJ>dtrans</OBJ>.<OO>m_accept</OO>.<OO>m_action_read</OO>))
                                     <OPERATOR>+</OPERATOR> <STRING>"&gt;]"</STRING>);
                    <KEYWORD>if</KEYWORD> (<OBJ>CSpec</OBJ>.<OO>NONE</OO> <OPERATOR>!=</OPERATOR> <OBJ>dtrans</OBJ>.<OO>m_anchor</OO>)
                      {
                        <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>" Anchor: "</STRING>
                                         <OPERATOR>+</OPERATOR> ((<NUMERIC>0</NUMERIC> <OPERATOR>!=</OPERATOR> (<OBJ>dtrans</OBJ>.<OO>m_anchor</OO> <OPERATOR>&amp;</OPERATOR> <OBJ>CSpec</OBJ>.<OO>START</OO>))
                                            <OPERATOR>?</OPERATOR> <STRING>"start "</STRING> <OPERATOR>:</OPERATOR> <STRING>""</STRING>)
                                         <OPERATOR>+</OPERATOR> ((<NUMERIC>0</NUMERIC> <OPERATOR>!=</OPERATOR> (<OBJ>dtrans</OBJ>.<OO>m_anchor</OO> <OPERATOR>&amp;</OPERATOR> <OBJ>CSpec</OBJ>.<OO>END</OO>))
                                            <OPERATOR>?</OPERATOR> <STRING>"end "</STRING> <OPERATOR>:</OPERATOR> <STRING>""</STRING>));
                      }
                  }
              }
            <KEYWORD>else</KEYWORD>
              {
                accept <OPERATOR>=</OPERATOR> (CAccept) <OBJ>m_spec</OBJ>.<OO>m_accept_vector</OO>.<OO>elementAt</OO>(i);

                <KEYWORD>if</KEYWORD> (<KEYWORD>null</KEYWORD> <OPERATOR>==</OPERATOR> accept)
                  {
                    <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>" * State "</STRING> <OPERATOR>+</OPERATOR> i <OPERATOR>+</OPERATOR> <STRING>" [nonaccepting]"</STRING>);
                  }
                <KEYWORD>else</KEYWORD>
                  {
                    <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>" * State "</STRING> <OPERATOR>+</OPERATOR> i
                                     <OPERATOR>+</OPERATOR> <STRING>" [accepting, line "</STRING>
                                     <OPERATOR>+</OPERATOR> <OBJ>accept</OBJ>.<OO>m_line_number</OO>
                                     <OPERATOR>+</OPERATOR> <STRING>" &lt;"</STRING>
                                     <OPERATOR>+</OPERATOR> (<KEYWORD>new</KEYWORD> <TYPE>String</TYPE>(<OBJ>accept</OBJ>.<OO>m_action</OO>,<NUMERIC>0</NUMERIC>,
                                                   <OBJ>accept</OBJ>.<OO>m_action_read</OO>))
                                     <OPERATOR>+</OPERATOR> <STRING>"&gt;]"</STRING>);
                    <KEYWORD>if</KEYWORD> (<OBJ>CSpec</OBJ>.<OO>NONE</OO> <OPERATOR>!=</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_anchor_array</OO>[i])
                      {
                        <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>" Anchor: "</STRING>
                                         <OPERATOR>+</OPERATOR> ((<NUMERIC>0</NUMERIC> <OPERATOR>!=</OPERATOR> (<OBJ>m_spec</OBJ>.<OO>m_anchor_array</OO>[i] <OPERATOR>&amp;</OPERATOR> <OBJ>CSpec</OBJ>.<OO>START</OO>))
                                            <OPERATOR>?</OPERATOR> <STRING>"start "</STRING> <OPERATOR>:</OPERATOR> <STRING>""</STRING>)
                                         <OPERATOR>+</OPERATOR> ((<NUMERIC>0</NUMERIC> <OPERATOR>!=</OPERATOR> (<OBJ>m_spec</OBJ>.<OO>m_anchor_array</OO>[i] <OPERATOR>&amp;</OPERATOR> <OBJ>CSpec</OBJ>.<OO>END</OO>))
                                            <OPERATOR>?</OPERATOR> <STRING>"end "</STRING> <OPERATOR>:</OPERATOR> <STRING>""</STRING>));
                      }
                  }
              }

            last_transition <OPERATOR>=</OPERATOR> <OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC>;
            <KEYWORD>for</KEYWORD> (j <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; j <OPERATOR>&lt;</OPERATOR> <OBJ>m_spec</OBJ>.<OO>m_dtrans_ncols</OO>; <OPERATOR>++</OPERATOR>j)
              {
                <KEYWORD>if</KEYWORD> (<OBJ>CDTrans</OBJ>.<OO>F</OO> <OPERATOR>!=</OPERATOR> <OBJ>dtrans</OBJ>.<OO>m_dtrans</OO>[j])
                  {
                    <KEYWORD>if</KEYWORD> (last_transition <OPERATOR>!=</OPERATOR> <OBJ>dtrans</OBJ>.<OO>m_dtrans</OO>[j])
                      {
                        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>();
                        <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>" *    goto "</STRING> <OPERATOR>+</OPERATOR> <OBJ>dtrans</OBJ>.<OO>m_dtrans</OO>[j]
                                         <OPERATOR>+</OPERATOR> <STRING>" on "</STRING>);
                        chars_printed <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
                      }

                    str <OPERATOR>=</OPERATOR> interp_int((<TYPE>int</TYPE>) j);
                    <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(str);

                    chars_printed <OPERATOR>=</OPERATOR> chars_printed <OPERATOR>+</OPERATOR> <OBJ>str</OBJ>.<OO>length</OO>();
                    <KEYWORD>if</KEYWORD> (<NUMERIC>56</NUMERIC> <OPERATOR>&lt;</OPERATOR> chars_printed)
                      {
                        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>();
                        <OBJ>System</OBJ>.<OO>out</OO>.<OO>print</OO>(<STRING>" *             "</STRING>);
                        chars_printed <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
                      }

                    last_transition <OPERATOR>=</OPERATOR> <OBJ>dtrans</OBJ>.<OO>m_dtrans</OO>[j];
                  }
              }
            <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>();
          }
        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>" */"</STRING>);
        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>();
      }
}

<COMMENT>/*</COMMENT>
<COMMENT> * SparseBitSet 25-Jul-1999.</COMMENT>
<COMMENT> * C. Scott Ananian &lt;cananian@alumni.princeton.edu&gt;</COMMENT>
<COMMENT> *</COMMENT>
<COMMENT> * Re-implementation of the standard java.util.BitSet to support sparse</COMMENT>
<COMMENT> * sets, which we need to efficiently support unicode character classes.</COMMENT>
<COMMENT> */</COMMENT>

<DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT> * A set of bits. The set automatically grows as more bits are</DOCCOMMENT>
<DOCCOMMENT> * needed.</DOCCOMMENT>
<DOCCOMMENT> *</DOCCOMMENT>
<DOCCOMMENT> * <DOCTAG>@version</DOCTAG>     1.00, 25 Jul 1999</DOCCOMMENT>
<DOCCOMMENT> * <DOCTAG>@author</DOCTAG> C. Scott Ananian</DOCCOMMENT>
<DOCCOMMENT> */</DOCCOMMENT>
<KEYWORD>final</KEYWORD> <KEYWORD>class</KEYWORD> SparseBitSet <KEYWORD>implements</KEYWORD> <TYPE>Cloneable</TYPE> {
    <DOCCOMMENT>/** Sorted array of bit-block offsets. */</DOCCOMMENT>
    <TYPE>int</TYPE>  offs[];
    <DOCCOMMENT>/** Array of bit-blocks; each holding BITS bits. */</DOCCOMMENT>
    <TYPE>long</TYPE> bits[];
    <DOCCOMMENT>/** Number of blocks currently in use. */</DOCCOMMENT>
    <TYPE>int</TYPE> size;
    <DOCCOMMENT>/** log base 2 of BITS, for the identity: x/BITS == x &gt;&gt; LG_BITS */</DOCCOMMENT>
    <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <KEYWORD>private</KEYWORD> <TYPE>int</TYPE> <CONSTANT>LG_BITS</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>6</NUMERIC>;
    <DOCCOMMENT>/** Number of bits in a block. */</DOCCOMMENT>
    <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <KEYWORD>private</KEYWORD> <TYPE>int</TYPE> <CONSTANT>BITS</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC><OPERATOR>&lt;&lt;</OPERATOR><CONSTANT>LG_BITS</CONSTANT>;
    <DOCCOMMENT>/** BITS-1, using the identity: x % BITS == x &amp; (BITS-1) */</DOCCOMMENT>
    <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <KEYWORD>private</KEYWORD> <TYPE>int</TYPE> <CONSTANT>BITS_M1</CONSTANT> <OPERATOR>=</OPERATOR> <CONSTANT>BITS</CONSTANT><OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC>;

    <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>     * Creates an empty set.</DOCCOMMENT>
<DOCCOMMENT>     */</DOCCOMMENT>
    <KEYWORD>public</KEYWORD> SparseBitSet() {
        bits <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>long</TYPE>[<NUMERIC>4</NUMERIC>];
        offs <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>int</TYPE> [<NUMERIC>4</NUMERIC>];
        size <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
    }

    <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>     * Creates an empty set with the specified size.</DOCCOMMENT>
<DOCCOMMENT>     * <DOCTAG>@param</DOCTAG><DOCPROPERTY> nbits</DOCPROPERTY> the size of the set</DOCCOMMENT>
<DOCCOMMENT>     */</DOCCOMMENT>
    <KEYWORD>public</KEYWORD> SparseBitSet(<TYPE>int</TYPE> nbits) {
        <KEYWORD>this</KEYWORD>();
    }

    <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>     * Creates an empty set with the same size as the given set.</DOCCOMMENT>
<DOCCOMMENT>     */</DOCCOMMENT>
    <KEYWORD>public</KEYWORD> SparseBitSet(SparseBitSet set) {
        bits <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>long</TYPE>[<OBJ>set</OBJ>.<OO>size</OO>];
        offs <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>int</TYPE> [<OBJ>set</OBJ>.<OO>size</OO>];
        size <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
    }

    <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> new_block(<TYPE>int</TYPE> bnum) {
        new_block(bsearch(bnum), bnum);
    }
    <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> new_block(<TYPE>int</TYPE> idx, <TYPE>int</TYPE> bnum) {
        <KEYWORD>if</KEYWORD> (size<OPERATOR>==</OPERATOR><OBJ>bits</OBJ>.<OO>length</OO>) { <COMMENT>// resize</COMMENT>
            <TYPE>long</TYPE>[] nbits <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>long</TYPE>[size<OPERATOR>*</OPERATOR><NUMERIC>3</NUMERIC>];
            <TYPE>int</TYPE> [] noffs <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>int</TYPE> [size<OPERATOR>*</OPERATOR><NUMERIC>3</NUMERIC>];
            <OBJ>System</OBJ>.<OO>arraycopy</OO>(bits, <NUMERIC>0</NUMERIC>, nbits, <NUMERIC>0</NUMERIC>, size);
            <OBJ>System</OBJ>.<OO>arraycopy</OO>(offs, <NUMERIC>0</NUMERIC>, noffs, <NUMERIC>0</NUMERIC>, size);
            bits <OPERATOR>=</OPERATOR> nbits;
            offs <OPERATOR>=</OPERATOR> noffs;
        }
        <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(size<OPERATOR>&lt;</OPERATOR><OBJ>bits</OBJ>.<OO>length</OO>);
        insert_block(idx, bnum);
    }
    <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> insert_block(<TYPE>int</TYPE> idx, <TYPE>int</TYPE> bnum) {
        <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(idx<OPERATOR>&lt;=</OPERATOR>size);
        <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(idx<OPERATOR>==</OPERATOR>size <OPERATOR>||</OPERATOR> offs[idx]<OPERATOR>!=</OPERATOR>bnum);
        <OBJ>System</OBJ>.<OO>arraycopy</OO>(bits, idx, bits, idx<OPERATOR>+</OPERATOR><NUMERIC>1</NUMERIC>, size<OPERATOR>-</OPERATOR>idx);
        <OBJ>System</OBJ>.<OO>arraycopy</OO>(offs, idx, offs, idx<OPERATOR>+</OPERATOR><NUMERIC>1</NUMERIC>, size<OPERATOR>-</OPERATOR>idx);
        offs[idx]<OPERATOR>=</OPERATOR>bnum;
        bits[idx]<OPERATOR>=</OPERATOR><NUMERIC>0</NUMERIC>; <COMMENT>//clear them bits.</COMMENT>
        size<OPERATOR>++</OPERATOR>;
    }
    <KEYWORD>private</KEYWORD> <TYPE>int</TYPE> bsearch(<TYPE>int</TYPE> bnum) {
        <TYPE>int</TYPE> l<OPERATOR>=</OPERATOR><NUMERIC>0</NUMERIC>, r<OPERATOR>=</OPERATOR>size; <COMMENT>// search interval is [l, r)</COMMENT>
        <KEYWORD>while</KEYWORD> (l<OPERATOR>&lt;</OPERATOR>r) {
            <TYPE>int</TYPE> p <OPERATOR>=</OPERATOR> (l<OPERATOR>+</OPERATOR>r)/<NUMERIC>2</NUMERIC>;
            <KEYWORD>if</KEYWORD> (bnum<OPERATOR>&lt;</OPERATOR>offs[p]) r<OPERATOR>=</OPERATOR>p;
            <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (bnum<OPERATOR>&gt;</OPERATOR>offs[p]) l<OPERATOR>=</OPERATOR>p<OPERATOR>+</OPERATOR><NUMERIC>1</NUMERIC>;
            <KEYWORD>else</KEYWORD> <KEYWORD>return</KEYWORD> p;
        }
        <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(l<OPERATOR>==</OPERATOR>r);
        <KEYWORD>return</KEYWORD> l; <COMMENT>// index at which the bnum *should* be, if it's not.</COMMENT>
    }

    <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>     * Sets a bit.</DOCCOMMENT>
<DOCCOMMENT>     * <DOCTAG>@param</DOCTAG><DOCPROPERTY> bit</DOCPROPERTY> the bit to be set</DOCCOMMENT>
<DOCCOMMENT>     */</DOCCOMMENT>
    <KEYWORD>public</KEYWORD> <TYPE>void</TYPE> set(<TYPE>int</TYPE> bit) {
        <TYPE>int</TYPE> bnum <OPERATOR>=</OPERATOR> bit <OPERATOR>&gt;&gt;</OPERATOR> <CONSTANT>LG_BITS</CONSTANT>;
        <TYPE>int</TYPE> idx  <OPERATOR>=</OPERATOR> bsearch(bnum);
        <KEYWORD>if</KEYWORD> (idx <OPERATOR>&gt;=</OPERATOR> size <OPERATOR>||</OPERATOR> offs[idx]<OPERATOR>!=</OPERATOR>bnum)
            new_block(idx, bnum);
        bits[idx] <OPERATOR>|=</OPERATOR> (<NUMERIC>1</NUMERIC>L <OPERATOR>&lt;&lt;</OPERATOR> (bit <OPERATOR>&amp;</OPERATOR> <CONSTANT>BITS_M1</CONSTANT>) );
    }

    <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>     * Clears a bit.</DOCCOMMENT>
<DOCCOMMENT>     * <DOCTAG>@param</DOCTAG><DOCPROPERTY> bit</DOCPROPERTY> the bit to be cleared</DOCCOMMENT>
<DOCCOMMENT>     */</DOCCOMMENT>
    <KEYWORD>public</KEYWORD> <TYPE>void</TYPE> clear(<TYPE>int</TYPE> bit) {
        <TYPE>int</TYPE> bnum <OPERATOR>=</OPERATOR> bit <OPERATOR>&gt;&gt;</OPERATOR> <CONSTANT>LG_BITS</CONSTANT>;
        <TYPE>int</TYPE> idx  <OPERATOR>=</OPERATOR> bsearch(bnum);
        <KEYWORD>if</KEYWORD> (idx <OPERATOR>&gt;=</OPERATOR> size <OPERATOR>||</OPERATOR> offs[idx]<OPERATOR>!=</OPERATOR>bnum)
            new_block(idx, bnum);
        bits[idx] <OPERATOR>&amp;=</OPERATOR> ~(<NUMERIC>1</NUMERIC>L <OPERATOR>&lt;&lt;</OPERATOR> (bit <OPERATOR>&amp;</OPERATOR> <CONSTANT>BITS_M1</CONSTANT>) );
    }

    <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>     * Clears all bits.</DOCCOMMENT>
<DOCCOMMENT>     */</DOCCOMMENT>
    <KEYWORD>public</KEYWORD> <TYPE>void</TYPE> clearAll() {
        size <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
    }

    <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>     * Gets a bit.</DOCCOMMENT>
<DOCCOMMENT>     * <DOCTAG>@param</DOCTAG><DOCPROPERTY> bit</DOCPROPERTY> the bit to be gotten</DOCCOMMENT>
<DOCCOMMENT>     */</DOCCOMMENT>
    <KEYWORD>public</KEYWORD> <TYPE>boolean</TYPE> get(<TYPE>int</TYPE> bit) {
        <TYPE>int</TYPE> bnum <OPERATOR>=</OPERATOR> bit <OPERATOR>&gt;&gt;</OPERATOR> <CONSTANT>LG_BITS</CONSTANT>;
        <TYPE>int</TYPE> idx  <OPERATOR>=</OPERATOR> bsearch(bnum);
        <KEYWORD>if</KEYWORD> (idx <OPERATOR>&gt;=</OPERATOR> size <OPERATOR>||</OPERATOR> offs[idx]<OPERATOR>!=</OPERATOR>bnum)
            <KEYWORD>return</KEYWORD> <KEYWORD>false</KEYWORD>;
        <KEYWORD>return</KEYWORD> <NUMERIC>0</NUMERIC> <OPERATOR>!=</OPERATOR> ( bits[idx] <OPERATOR>&amp;</OPERATOR> (<NUMERIC>1</NUMERIC>L <OPERATOR>&lt;&lt;</OPERATOR> (bit <OPERATOR>&amp;</OPERATOR> <CONSTANT>BITS_M1</CONSTANT>) ) );
    }

    <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>     * Logically ANDs this bit set with the specified set of bits.</DOCCOMMENT>
<DOCCOMMENT>     * <DOCTAG>@param</DOCTAG><DOCPROPERTY> set</DOCPROPERTY> the bit set to be ANDed with</DOCCOMMENT>
<DOCCOMMENT>     */</DOCCOMMENT>
    <KEYWORD>public</KEYWORD> <TYPE>void</TYPE> and(SparseBitSet set) {
        binop(<KEYWORD>this</KEYWORD>, set, AND);
    }

    <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>     * Logically ORs this bit set with the specified set of bits.</DOCCOMMENT>
<DOCCOMMENT>     * <DOCTAG>@param</DOCTAG><DOCPROPERTY> set</DOCPROPERTY> the bit set to be ORed with</DOCCOMMENT>
<DOCCOMMENT>     */</DOCCOMMENT>
    <KEYWORD>public</KEYWORD> <TYPE>void</TYPE> or(SparseBitSet set) {
        binop(<KEYWORD>this</KEYWORD>, set, OR);
    }

    <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>     * Logically XORs this bit set with the specified set of bits.</DOCCOMMENT>
<DOCCOMMENT>     * <DOCTAG>@param</DOCTAG><DOCPROPERTY> set</DOCPROPERTY> the bit set to be XORed with</DOCCOMMENT>
<DOCCOMMENT>     */</DOCCOMMENT>
    <KEYWORD>public</KEYWORD> <TYPE>void</TYPE> xor(SparseBitSet set) {
        binop(<KEYWORD>this</KEYWORD>, set, XOR);
    }

    <COMMENT>// BINARY OPERATION MACHINERY</COMMENT>
    <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>interface</KEYWORD> BinOp {
        <KEYWORD>public</KEYWORD> <TYPE>long</TYPE> op(<TYPE>long</TYPE> a, <TYPE>long</TYPE> b);
    }
    <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> BinOp AND <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> BinOp() {
        <KEYWORD>public</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>long</TYPE> op(<TYPE>long</TYPE> a, <TYPE>long</TYPE> b) { <KEYWORD>return</KEYWORD> a <OPERATOR>&amp;</OPERATOR> b; }
    };
    <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> BinOp OR <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> BinOp() {
        <KEYWORD>public</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>long</TYPE> op(<TYPE>long</TYPE> a, <TYPE>long</TYPE> b) { <KEYWORD>return</KEYWORD> a <OPERATOR>|</OPERATOR> b; }
    };
    <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> BinOp XOR <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> BinOp() {
        <KEYWORD>public</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>long</TYPE> op(<TYPE>long</TYPE> a, <TYPE>long</TYPE> b) { <KEYWORD>return</KEYWORD> a <OPERATOR>^</OPERATOR> b; }
    };
    <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>final</KEYWORD> <TYPE>void</TYPE> binop(SparseBitSet a, SparseBitSet b, BinOp op) {
        <TYPE>int</TYPE>  nsize <OPERATOR>=</OPERATOR> <OBJ>a</OBJ>.<OO>size</OO> <OPERATOR>+</OPERATOR> <OBJ>b</OBJ>.<OO>size</OO>;
        <TYPE>long</TYPE>[] nbits;
        <TYPE>int</TYPE> [] noffs;
        <TYPE>int</TYPE> a_zero, a_size;
        <COMMENT>// be very clever and avoid allocating more memory if we can.</COMMENT>
        <KEYWORD>if</KEYWORD> (<OBJ>a</OBJ>.<OO>bits</OO>.<OO>length</OO> <OPERATOR>&lt;</OPERATOR> nsize) { <COMMENT>// oh well, have to make working space.</COMMENT>
            nbits <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>long</TYPE>[nsize];
            noffs <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>int</TYPE> [nsize];
            a_zero  <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; a_size <OPERATOR>=</OPERATOR> <OBJ>a</OBJ>.<OO>size</OO>;
        } <KEYWORD>else</KEYWORD> { <COMMENT>// reduce, reuse, recycle!</COMMENT>
            nbits <OPERATOR>=</OPERATOR> <OBJ>a</OBJ>.<OO>bits</OO>;
            noffs <OPERATOR>=</OPERATOR> <OBJ>a</OBJ>.<OO>offs</OO>;
            a_zero <OPERATOR>=</OPERATOR> <OBJ>a</OBJ>.<OO>bits</OO>.<OO>length</OO> <OPERATOR>-</OPERATOR> <OBJ>a</OBJ>.<OO>size</OO>; a_size <OPERATOR>=</OPERATOR> <OBJ>a</OBJ>.<OO>bits</OO>.<OO>length</OO>;
            <OBJ>System</OBJ>.<OO>arraycopy</OO>(<OBJ>a</OBJ>.<OO>bits</OO>, <NUMERIC>0</NUMERIC>, <OBJ>a</OBJ>.<OO>bits</OO>, a_zero, <OBJ>a</OBJ>.<OO>size</OO>);
            <OBJ>System</OBJ>.<OO>arraycopy</OO>(<OBJ>a</OBJ>.<OO>offs</OO>, <NUMERIC>0</NUMERIC>, <OBJ>a</OBJ>.<OO>offs</OO>, a_zero, <OBJ>a</OBJ>.<OO>size</OO>);
        }
        <COMMENT>// ok, crunch through and binop those sets!</COMMENT>
        nsize <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
        <KEYWORD>for</KEYWORD> (<TYPE>int</TYPE> i<OPERATOR>=</OPERATOR>a_zero, j<OPERATOR>=</OPERATOR><NUMERIC>0</NUMERIC>; i<OPERATOR>&lt;</OPERATOR>a_size <OPERATOR>||</OPERATOR> j<OPERATOR>&lt;</OPERATOR><OBJ>b</OBJ>.<OO>size</OO>; ) {
            <TYPE>long</TYPE> nb; <TYPE>int</TYPE> no;
            <KEYWORD>if</KEYWORD> (i<OPERATOR>&lt;</OPERATOR>a_size <OPERATOR>&amp;&amp;</OPERATOR> (j<OPERATOR>&gt;=</OPERATOR><OBJ>b</OBJ>.<OO>size</OO> <OPERATOR>||</OPERATOR> <OBJ>a</OBJ>.<OO>offs</OO>[i] <OPERATOR>&lt;</OPERATOR> <OBJ>b</OBJ>.<OO>offs</OO>[j])) {
                nb <OPERATOR>=</OPERATOR> <OBJ>op</OBJ>.<OO>op</OO>(<OBJ>a</OBJ>.<OO>bits</OO>[i], <NUMERIC>0</NUMERIC>);
                no <OPERATOR>=</OPERATOR> <OBJ>a</OBJ>.<OO>offs</OO>[i];
                i<OPERATOR>++</OPERATOR>;
            } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (j<OPERATOR>&lt;</OPERATOR><OBJ>b</OBJ>.<OO>size</OO> <OPERATOR>&amp;&amp;</OPERATOR> (i<OPERATOR>&gt;=</OPERATOR>a_size <OPERATOR>||</OPERATOR> <OBJ>a</OBJ>.<OO>offs</OO>[i] <OPERATOR>&gt;</OPERATOR> <OBJ>b</OBJ>.<OO>offs</OO>[j])) {
                nb <OPERATOR>=</OPERATOR> <OBJ>op</OBJ>.<OO>op</OO>(<NUMERIC>0</NUMERIC>, <OBJ>b</OBJ>.<OO>bits</OO>[j]);
                no <OPERATOR>=</OPERATOR> <OBJ>b</OBJ>.<OO>offs</OO>[j];
                j<OPERATOR>++</OPERATOR>;
            } <KEYWORD>else</KEYWORD> { <COMMENT>// equal keys; merge.</COMMENT>
                nb <OPERATOR>=</OPERATOR> <OBJ>op</OBJ>.<OO>op</OO>(<OBJ>a</OBJ>.<OO>bits</OO>[i], <OBJ>b</OBJ>.<OO>bits</OO>[j]);
                no <OPERATOR>=</OPERATOR> <OBJ>a</OBJ>.<OO>offs</OO>[i];
                i<OPERATOR>++</OPERATOR>; j<OPERATOR>++</OPERATOR>;
            }
            <KEYWORD>if</KEYWORD> (nb<OPERATOR>!=</OPERATOR><NUMERIC>0</NUMERIC>) {
                nbits[nsize] <OPERATOR>=</OPERATOR> nb;
                noffs[nsize] <OPERATOR>=</OPERATOR> no;
                nsize<OPERATOR>++</OPERATOR>;
            }
        }
        <OBJ>a</OBJ>.<OO>bits</OO> <OPERATOR>=</OPERATOR> nbits;
        <OBJ>a</OBJ>.<OO>offs</OO> <OPERATOR>=</OPERATOR> noffs;
        <OBJ>a</OBJ>.<OO>size</OO> <OPERATOR>=</OPERATOR> nsize;
    }

    <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>     * Gets the hashcode.</DOCCOMMENT>
<DOCCOMMENT>     */</DOCCOMMENT>
    <KEYWORD>public</KEYWORD> <TYPE>int</TYPE> hashCode() {
        <TYPE>long</TYPE> h <OPERATOR>=</OPERATOR> <NUMERIC>1234</NUMERIC>;
        <KEYWORD>for</KEYWORD> (<TYPE>int</TYPE> i<OPERATOR>=</OPERATOR><NUMERIC>0</NUMERIC>; i<OPERATOR>&lt;</OPERATOR>size; i<OPERATOR>++</OPERATOR>)
            h <OPERATOR>^=</OPERATOR> bits[i] <OPERATOR>*</OPERATOR> offs[i];
        <KEYWORD>return</KEYWORD> (<TYPE>int</TYPE>)((h <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>32</NUMERIC>) <OPERATOR>^</OPERATOR> h);
    }

    <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>     * Calculates and returns the set's size</DOCCOMMENT>
<DOCCOMMENT>     */</DOCCOMMENT>
    <KEYWORD>public</KEYWORD> <TYPE>int</TYPE> size() {
        <KEYWORD>return</KEYWORD> (size<OPERATOR>==</OPERATOR><NUMERIC>0</NUMERIC>)<OPERATOR>?</OPERATOR><NUMERIC>0</NUMERIC><OPERATOR>:</OPERATOR>((<NUMERIC>1</NUMERIC><OPERATOR>+</OPERATOR>offs[size<OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC>]) <OPERATOR>&lt;&lt;</OPERATOR> <CONSTANT>LG_BITS</CONSTANT>);
    }

    <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>     * Compares this object against the specified object.</DOCCOMMENT>
<DOCCOMMENT>     * <DOCTAG>@param</DOCTAG><DOCPROPERTY> obj</DOCPROPERTY> the object to commpare with</DOCCOMMENT>
<DOCCOMMENT>     * <DOCTAG>@return</DOCTAG> true if the objects are the same; false otherwise.</DOCCOMMENT>
<DOCCOMMENT>     */</DOCCOMMENT>
    <KEYWORD>public</KEYWORD> <TYPE>boolean</TYPE> equals(<TYPE>Object</TYPE> obj) {
        <KEYWORD>if</KEYWORD> ((obj <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>) <OPERATOR>&amp;&amp;</OPERATOR> (obj <KEYWORD>instanceof</KEYWORD> SparseBitSet))
            <KEYWORD>return</KEYWORD> equals(<KEYWORD>this</KEYWORD>, (SparseBitSet)obj);
        <KEYWORD>return</KEYWORD> <KEYWORD>false</KEYWORD>;
    }
    <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>     * Compares two SparseBitSets for equality.</DOCCOMMENT>
<DOCCOMMENT>     * <DOCTAG>@return</DOCTAG> true if the objects are the same; false otherwise.</DOCCOMMENT>
<DOCCOMMENT>     */</DOCCOMMENT>
    <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>boolean</TYPE> equals(SparseBitSet a, SparseBitSet b) {
        <KEYWORD>for</KEYWORD> (<TYPE>int</TYPE> i<OPERATOR>=</OPERATOR><NUMERIC>0</NUMERIC>, j<OPERATOR>=</OPERATOR><NUMERIC>0</NUMERIC>; i<OPERATOR>&lt;</OPERATOR><OBJ>a</OBJ>.<OO>size</OO> <OPERATOR>||</OPERATOR> j<OPERATOR>&lt;</OPERATOR><OBJ>b</OBJ>.<OO>size</OO>; ) {
            <KEYWORD>if</KEYWORD> (i<OPERATOR>&lt;</OPERATOR><OBJ>a</OBJ>.<OO>size</OO> <OPERATOR>&amp;&amp;</OPERATOR> (j<OPERATOR>&gt;=</OPERATOR><OBJ>b</OBJ>.<OO>size</OO> <OPERATOR>||</OPERATOR> <OBJ>a</OBJ>.<OO>offs</OO>[i] <OPERATOR>&lt;</OPERATOR> <OBJ>b</OBJ>.<OO>offs</OO>[j])) {
                <KEYWORD>if</KEYWORD> (<OBJ>a</OBJ>.<OO>bits</OO>[i<OPERATOR>++</OPERATOR>]<OPERATOR>!=</OPERATOR><NUMERIC>0</NUMERIC>) <KEYWORD>return</KEYWORD> <KEYWORD>false</KEYWORD>;
            } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (j<OPERATOR>&lt;</OPERATOR><OBJ>b</OBJ>.<OO>size</OO> <OPERATOR>&amp;&amp;</OPERATOR> (i<OPERATOR>&gt;=</OPERATOR><OBJ>a</OBJ>.<OO>size</OO> <OPERATOR>||</OPERATOR> <OBJ>a</OBJ>.<OO>offs</OO>[i] <OPERATOR>&gt;</OPERATOR> <OBJ>b</OBJ>.<OO>offs</OO>[j])) {
                <KEYWORD>if</KEYWORD> (<OBJ>b</OBJ>.<OO>bits</OO>[j<OPERATOR>++</OPERATOR>]<OPERATOR>!=</OPERATOR><NUMERIC>0</NUMERIC>) <KEYWORD>return</KEYWORD> <KEYWORD>false</KEYWORD>;
            } <KEYWORD>else</KEYWORD> { <COMMENT>// equal keys</COMMENT>
                <KEYWORD>if</KEYWORD> (<OBJ>a</OBJ>.<OO>bits</OO>[i<OPERATOR>++</OPERATOR>]<OPERATOR>!=</OPERATOR><OBJ>b</OBJ>.<OO>bits</OO>[j<OPERATOR>++</OPERATOR>]) <KEYWORD>return</KEYWORD> <KEYWORD>false</KEYWORD>;
            }
        }
        <KEYWORD>return</KEYWORD> <KEYWORD>true</KEYWORD>;
    }

    <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>     * Clones the SparseBitSet.</DOCCOMMENT>
<DOCCOMMENT>     */</DOCCOMMENT>
    <KEYWORD>public</KEYWORD> <TYPE>Object</TYPE> clone() {
        <KEYWORD>try</KEYWORD> {
            SparseBitSet set <OPERATOR>=</OPERATOR> (SparseBitSet)<OBJ>super</OBJ>.<OO>clone</OO>();
            <OBJ>set</OBJ>.<OO>bits</OO> <OPERATOR>=</OPERATOR> (<TYPE>long</TYPE>[]) <OBJ>bits</OBJ>.<OO>clone</OO>();
            <OBJ>set</OBJ>.<OO>offs</OO> <OPERATOR>=</OPERATOR> (<TYPE>int</TYPE> []) <OBJ>offs</OBJ>.<OO>clone</OO>();
            <KEYWORD>return</KEYWORD> set;
        } <KEYWORD>catch</KEYWORD> (<TYPE>CloneNotSupportedException</TYPE> e) {
            <COMMENT>// this shouldn't happen, since we are Cloneable</COMMENT>
            <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> <TYPE>InternalError</TYPE>();
        }
    }

    <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>     * Return an &lt;code&gt;Enumeration&lt;/code&gt; of &lt;code&gt;Integer&lt;/code&gt;s</DOCCOMMENT>
<DOCCOMMENT>     * which represent set bit indices in this SparseBitSet.</DOCCOMMENT>
<DOCCOMMENT>     */</DOCCOMMENT>
    <KEYWORD>public</KEYWORD> <TYPE>Enumeration</TYPE> elements() {
        <KEYWORD>return</KEYWORD> <KEYWORD>new</KEYWORD> <TYPE>Enumeration</TYPE>() {
            <TYPE>int</TYPE> idx<OPERATOR>=-</OPERATOR><NUMERIC>1</NUMERIC>, bit<OPERATOR>=</OPERATOR><CONSTANT>BITS</CONSTANT>;
            { advance(); }
            <KEYWORD>public</KEYWORD> <TYPE>boolean</TYPE> hasMoreElements() {
                <KEYWORD>return</KEYWORD> (idx<OPERATOR>&lt;</OPERATOR>size);
            }
            <KEYWORD>public</KEYWORD> <TYPE>Object</TYPE> nextElement() {
                <TYPE>int</TYPE> r <OPERATOR>=</OPERATOR> bit <OPERATOR>+</OPERATOR> (offs[idx] <OPERATOR>&lt;&lt;</OPERATOR> <CONSTANT>LG_BITS</CONSTANT>);
                advance();
                <KEYWORD>return</KEYWORD> <KEYWORD>new</KEYWORD> <TYPE>Integer</TYPE>(r);
            }
            <KEYWORD>private</KEYWORD> <TYPE>void</TYPE> advance() {
                <KEYWORD>while</KEYWORD> (idx<OPERATOR>&lt;</OPERATOR>size) {
                    <KEYWORD>while</KEYWORD> (<OPERATOR>++</OPERATOR>bit<OPERATOR>&lt;</OPERATOR><CONSTANT>BITS</CONSTANT>)
                        <KEYWORD>if</KEYWORD> (<NUMERIC>0</NUMERIC><OPERATOR>!=</OPERATOR>(bits[idx] <OPERATOR>&amp;</OPERATOR> (<NUMERIC>1</NUMERIC>L<OPERATOR>&lt;&lt;</OPERATOR>bit)))
                            <KEYWORD>return</KEYWORD>;
                    idx<OPERATOR>++</OPERATOR>; bit<OPERATOR>=-</OPERATOR><NUMERIC>1</NUMERIC>;
                }
            }
        };
    }
    <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>     * Converts the SparseBitSet to a String.</DOCCOMMENT>
<DOCCOMMENT>     */</DOCCOMMENT>
    <KEYWORD>public</KEYWORD> <TYPE>String</TYPE> toString() {
        <TYPE>StringBuffer</TYPE> sb <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>StringBuffer</TYPE>();
        <OBJ>sb</OBJ>.<OO>append</OO>(<CHARACTER>'{'</CHARACTER>);
        <KEYWORD>for</KEYWORD> (<TYPE>Enumeration</TYPE> e<OPERATOR>=</OPERATOR>elements(); <OBJ>e</OBJ>.<OO>hasMoreElements</OO>(); ) {
            <KEYWORD>if</KEYWORD> (<OBJ>sb</OBJ>.<OO>length</OO>() <OPERATOR>&gt;</OPERATOR> <NUMERIC>1</NUMERIC>) <OBJ>sb</OBJ>.<OO>append</OO>(<STRING>", "</STRING>);
            <OBJ>sb</OBJ>.<OO>append</OO>(<OBJ>e</OBJ>.<OO>nextElement</OO>());
        }
        <OBJ>sb</OBJ>.<OO>append</OO>(<CHARACTER>'}'</CHARACTER>);
        <KEYWORD>return</KEYWORD> <OBJ>sb</OBJ>.<OO>toString</OO>();
    }

    <DOCCOMMENT>/** Check validity. */</DOCCOMMENT>
    <KEYWORD>private</KEYWORD> <TYPE>boolean</TYPE> isValid() {
        <KEYWORD>if</KEYWORD> (<OBJ>bits</OBJ>.<OO>length</OO><OPERATOR>!=</OPERATOR><OBJ>offs</OBJ>.<OO>length</OO>) <KEYWORD>return</KEYWORD> <KEYWORD>false</KEYWORD>;
        <KEYWORD>if</KEYWORD> (size<OPERATOR>&gt;</OPERATOR><OBJ>bits</OBJ>.<OO>length</OO>) <KEYWORD>return</KEYWORD> <KEYWORD>false</KEYWORD>;
        <KEYWORD>if</KEYWORD> (size<OPERATOR>!=</OPERATOR><NUMERIC>0</NUMERIC> <OPERATOR>&amp;&amp;</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>&lt;=</OPERATOR>offs[<NUMERIC>0</NUMERIC>]) <KEYWORD>return</KEYWORD> <KEYWORD>false</KEYWORD>;
        <KEYWORD>for</KEYWORD> (<TYPE>int</TYPE> i<OPERATOR>=</OPERATOR><NUMERIC>1</NUMERIC>; i<OPERATOR>&lt;</OPERATOR>size; i<OPERATOR>++</OPERATOR>)
            <KEYWORD>if</KEYWORD> (offs[i] <OPERATOR>&lt;</OPERATOR> offs[i<OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC>])
                    <KEYWORD>return</KEYWORD> <KEYWORD>false</KEYWORD>;
        <KEYWORD>return</KEYWORD> <KEYWORD>true</KEYWORD>;
    }
    <DOCCOMMENT>/** Self-test. */</DOCCOMMENT>
    <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>void</TYPE> main(<TYPE>String</TYPE>[] args) {
        <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>ITER</CONSTANT> <OPERATOR>=</OPERATOR> <NUMERIC>500</NUMERIC>;
        <KEYWORD>final</KEYWORD> <TYPE>int</TYPE> <CONSTANT>RANGE</CONSTANT><OPERATOR>=</OPERATOR> <NUMERIC>65536</NUMERIC>;
        SparseBitSet a <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> SparseBitSet();
        <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OPERATOR>!</OPERATOR><OBJ>a</OBJ>.<OO>get</OO>(<NUMERIC>0</NUMERIC>) <OPERATOR>&amp;&amp;</OPERATOR> <OPERATOR>!</OPERATOR><OBJ>a</OBJ>.<OO>get</OO>(<NUMERIC>1</NUMERIC>));
        <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OPERATOR>!</OPERATOR><OBJ>a</OBJ>.<OO>get</OO>(<NUMERIC>123329</NUMERIC>));
        <OBJ>a</OBJ>.<OO>set</OO>(<NUMERIC>0</NUMERIC>); <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>a</OBJ>.<OO>get</OO>(<NUMERIC>0</NUMERIC>) <OPERATOR>&amp;&amp;</OPERATOR> <OPERATOR>!</OPERATOR><OBJ>a</OBJ>.<OO>get</OO>(<NUMERIC>1</NUMERIC>));
        <OBJ>a</OBJ>.<OO>set</OO>(<NUMERIC>1</NUMERIC>); <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>a</OBJ>.<OO>get</OO>(<NUMERIC>0</NUMERIC>) <OPERATOR>&amp;&amp;</OPERATOR> <OBJ>a</OBJ>.<OO>get</OO>(<NUMERIC>1</NUMERIC>));
        <OBJ>a</OBJ>.<OO>clearAll</OO>();
        <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OPERATOR>!</OPERATOR><OBJ>a</OBJ>.<OO>get</OO>(<NUMERIC>0</NUMERIC>) <OPERATOR>&amp;&amp;</OPERATOR> <OPERATOR>!</OPERATOR><OBJ>a</OBJ>.<OO>get</OO>(<NUMERIC>1</NUMERIC>));
        <OBJ>java</OBJ>.<OO>util</OO>.<OO>Random</OO> r <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <OBJ>java</OBJ>.<OO>util</OO>.<OO>Random</OO>();
        <OBJ>java</OBJ>.<OO>util</OO>.<OO>Vector</OO> v <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <OBJ>java</OBJ>.<OO>util</OO>.<OO>Vector</OO>();
        <KEYWORD>for</KEYWORD> (<TYPE>int</TYPE> n<OPERATOR>=</OPERATOR><NUMERIC>0</NUMERIC>; n<OPERATOR>&lt;</OPERATOR><CONSTANT>ITER</CONSTANT>; n<OPERATOR>++</OPERATOR>) {
            <TYPE>int</TYPE> rr <OPERATOR>=</OPERATOR> ((<OBJ>r</OBJ>.<OO>nextInt</OO>()<OPERATOR>&gt;&gt;&gt;</OPERATOR><NUMERIC>1</NUMERIC>) <OPERATOR>%</OPERATOR> <CONSTANT>RANGE</CONSTANT>) <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>1</NUMERIC>;
            <OBJ>a</OBJ>.<OO>set</OO>(rr); <OBJ>v</OBJ>.<OO>addElement</OO>(<KEYWORD>new</KEYWORD> <TYPE>Integer</TYPE>(rr));
            <COMMENT>// check that all the numbers are there.</COMMENT>
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>a</OBJ>.<OO>get</OO>(rr) <OPERATOR>&amp;&amp;</OPERATOR> <OPERATOR>!</OPERATOR><OBJ>a</OBJ>.<OO>get</OO>(rr<OPERATOR>+</OPERATOR><NUMERIC>1</NUMERIC>) <OPERATOR>&amp;&amp;</OPERATOR> <OPERATOR>!</OPERATOR><OBJ>a</OBJ>.<OO>get</OO>(rr<OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC>));
            <KEYWORD>for</KEYWORD> (<TYPE>int</TYPE> i<OPERATOR>=</OPERATOR><NUMERIC>0</NUMERIC>; i<OPERATOR>&lt;</OPERATOR><OBJ>v</OBJ>.<OO>size</OO>(); i<OPERATOR>++</OPERATOR>)
                <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>a</OBJ>.<OO>get</OO>(((<TYPE>Integer</TYPE>)<OBJ>v</OBJ>.<OO>elementAt</OO>(i)).intValue()));
        }
        SparseBitSet b <OPERATOR>=</OPERATOR> (SparseBitSet) <OBJ>a</OBJ>.<OO>clone</OO>();
        <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>a</OBJ>.<OO>equals</OO>(b) <OPERATOR>&amp;&amp;</OPERATOR> <OBJ>b</OBJ>.<OO>equals</OO>(a));
        <KEYWORD>for</KEYWORD> (<TYPE>int</TYPE> n<OPERATOR>=</OPERATOR><NUMERIC>0</NUMERIC>; n<OPERATOR>&lt;</OPERATOR><CONSTANT>ITER</CONSTANT>/<NUMERIC>2</NUMERIC>; n<OPERATOR>++</OPERATOR>) {
            <TYPE>int</TYPE> rr <OPERATOR>=</OPERATOR> (<OBJ>r</OBJ>.<OO>nextInt</OO>()<OPERATOR>&gt;&gt;&gt;</OPERATOR><NUMERIC>1</NUMERIC>) <OPERATOR>%</OPERATOR> <OBJ>v</OBJ>.<OO>size</OO>();
            <TYPE>int</TYPE> m <OPERATOR>=</OPERATOR> ((<TYPE>Integer</TYPE>)<OBJ>v</OBJ>.<OO>elementAt</OO>(rr)).intValue();
            <OBJ>b</OBJ>.<OO>clear</OO>(m); <OBJ>v</OBJ>.<OO>removeElementAt</OO>(rr);
            <COMMENT>// check that numbers are removed properly.</COMMENT>
            <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OPERATOR>!</OPERATOR><OBJ>b</OBJ>.<OO>get</OO>(m));
        }
        <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OPERATOR>!</OPERATOR><OBJ>a</OBJ>.<OO>equals</OO>(b));
        SparseBitSet c <OPERATOR>=</OPERATOR> (SparseBitSet) <OBJ>a</OBJ>.<OO>clone</OO>();
        SparseBitSet d <OPERATOR>=</OPERATOR> (SparseBitSet) <OBJ>a</OBJ>.<OO>clone</OO>();
        <OBJ>c</OBJ>.<OO>and</OO>(a);
        <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>c</OBJ>.<OO>equals</OO>(a) <OPERATOR>&amp;&amp;</OPERATOR> <OBJ>a</OBJ>.<OO>equals</OO>(c));
        <OBJ>c</OBJ>.<OO>xor</OO>(a);
        <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OPERATOR>!</OPERATOR><OBJ>c</OBJ>.<OO>equals</OO>(a) <OPERATOR>&amp;&amp;</OPERATOR> <OBJ>c</OBJ>.<OO>size</OO>()<OPERATOR>==</OPERATOR><NUMERIC>0</NUMERIC>);
        <OBJ>d</OBJ>.<OO>or</OO>(b);
        <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>d</OBJ>.<OO>equals</OO>(a) <OPERATOR>&amp;&amp;</OPERATOR> <OPERATOR>!</OPERATOR><OBJ>b</OBJ>.<OO>equals</OO>(d));
        <OBJ>d</OBJ>.<OO>and</OO>(b);
        <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OPERATOR>!</OPERATOR><OBJ>d</OBJ>.<OO>equals</OO>(a) <OPERATOR>&amp;&amp;</OPERATOR> <OBJ>b</OBJ>.<OO>equals</OO>(d));
        <OBJ>d</OBJ>.<OO>xor</OO>(a);
        <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OPERATOR>!</OPERATOR><OBJ>d</OBJ>.<OO>equals</OO>(a) <OPERATOR>&amp;&amp;</OPERATOR> <OPERATOR>!</OPERATOR><OBJ>b</OBJ>.<OO>equals</OO>(d));
        <OBJ>c</OBJ>.<OO>or</OO>(d); <OBJ>c</OBJ>.<OO>or</OO>(b);
        <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>c</OBJ>.<OO>equals</OO>(a) <OPERATOR>&amp;&amp;</OPERATOR> <OBJ>a</OBJ>.<OO>equals</OO>(c));
        c <OPERATOR>=</OPERATOR> (SparseBitSet) <OBJ>d</OBJ>.<OO>clone</OO>();
        <OBJ>c</OBJ>.<OO>and</OO>(b);
        <OBJ>CUtility</OBJ>.<OO>ASSERT</OO>(<OBJ>c</OBJ>.<OO>size</OO>()<OPERATOR>==</OPERATOR><NUMERIC>0</NUMERIC>);
        <OBJ>System</OBJ>.<OO>out</OO>.<OO>println</OO>(<STRING>"Success."</STRING>);
    }
}

<COMMENT>/************************************************************************</COMMENT>
<COMMENT>  JLEX COPYRIGHT NOTICE, LICENSE AND DISCLAIMER.</COMMENT>
<COMMENT></COMMENT>
<COMMENT>  Copyright 1996 by Elliot Joel Berk</COMMENT>
<COMMENT></COMMENT>
<COMMENT>  Permission to use, copy, modify, and distribute this software and its</COMMENT>
<COMMENT>  documentation for any purpose and without fee is hereby granted,</COMMENT>
<COMMENT>  provided that the above copyright notice appear in all copies and that</COMMENT>
<COMMENT>  both the copyright notice and this permission notice and warranty</COMMENT>
<COMMENT>  disclaimer appear in supporting documentation, and that the name of</COMMENT>
<COMMENT>  Elliot Joel Berk not be used in advertising or publicity pertaining</COMMENT>
<COMMENT>  to distribution of the software without specific, written prior permission.</COMMENT>
<COMMENT></COMMENT>
<COMMENT>  Elliot Joel Berk disclaims all warranties with regard to this software,</COMMENT>
<COMMENT>  including all implied warranties of merchantability and fitness.  In no event</COMMENT>
<COMMENT>  shall Elliot Joel Berk be liable for any special, indirect or consequential</COMMENT>
<COMMENT>  damages or any damages whatsoever resulting from loss of use, data or</COMMENT>
<COMMENT>  profits, whether in an action of contract, negligence or other</COMMENT>
<COMMENT>  tortious action, arising out of or in connection with the use or</COMMENT>
<COMMENT>  performance of this software.</COMMENT>
<COMMENT>  ***********************************************************************/</COMMENT>
<COMMENT>// set emacs indentation</COMMENT>
<COMMENT>// Local Variables:</COMMENT>
<COMMENT>// c-basic-offset:2</COMMENT>
<COMMENT>// End:</COMMENT>