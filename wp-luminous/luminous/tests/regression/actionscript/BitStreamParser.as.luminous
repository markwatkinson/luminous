<COMMENT>/*</COMMENT>
<COMMENT> * Copyright 2008 ZXing authors</COMMENT>
<COMMENT> *</COMMENT>
<COMMENT> * Licensed under the Apache License, Version 2.0 (the "License");</COMMENT>
<COMMENT> * you may not use this file except in compliance with the License.</COMMENT>
<COMMENT> * You may obtain a copy of the License at</COMMENT>
<COMMENT> *</COMMENT>
<COMMENT> *      http://www.apache.org/licenses/LICENSE-2.0</COMMENT>
<COMMENT> *</COMMENT>
<COMMENT> * Unless required by applicable law or agreed to in writing, software</COMMENT>
<COMMENT> * distributed under the License is distributed on an "AS IS" BASIS,</COMMENT>
<COMMENT> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</COMMENT>
<COMMENT> * See the License for the specific language governing permissions and</COMMENT>
<COMMENT> * limitations under the License.</COMMENT>
<COMMENT> */</COMMENT>
<KEYWORD>package</KEYWORD> <OBJ>com</OBJ><OPERATOR>.</OPERATOR><OO>google</OO><OPERATOR>.</OPERATOR><OO>zxing</OO><OPERATOR>.</OPERATOR><OO>datamatrix</OO><OPERATOR>.</OPERATOR><OO>decoder</OO>
{
         <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT> * &lt;p&gt;Data Matrix Codes can encode text as bits in one of several modes, and can use multiple modes</DOCCOMMENT>
<DOCCOMMENT> * in one Data Matrix Code. This class decodes the bits back into text.&lt;/p&gt;</DOCCOMMENT>
<DOCCOMMENT> *</DOCCOMMENT>
<DOCCOMMENT> * &lt;p&gt;See ISO 16022:2006, 5.2.1 - 5.2.9.2&lt;/p&gt;</DOCCOMMENT>
<DOCCOMMENT> *</DOCCOMMENT>
<DOCCOMMENT> * <DOCTAG>@author</DOCTAG> bbrown@google.com (Brian Brown)</DOCCOMMENT>
<DOCCOMMENT> * <DOCTAG>@author</DOCTAG> Sean Owen</DOCCOMMENT>
<DOCCOMMENT> */</DOCCOMMENT>

    <KEYWORD>public</KEYWORD> <KEYWORD>class</KEYWORD> DecodedBitStreamParser
    {
        <KEYWORD>import</KEYWORD> <OBJ>com</OBJ><OPERATOR>.</OPERATOR><OO>google</OO><OPERATOR>.</OPERATOR><OO>zxing</OO><OPERATOR>.</OPERATOR><OO>common</OO><OPERATOR>.</OPERATOR><OO>flexdatatypes</OO><OPERATOR>.</OPERATOR><OO>ArrayList</OO><OPERATOR>;</OPERATOR>
        <KEYWORD>import</KEYWORD> <OBJ>com</OBJ><OPERATOR>.</OPERATOR><OO>google</OO><OPERATOR>.</OPERATOR><OO>zxing</OO><OPERATOR>.</OPERATOR><OO>common</OO><OPERATOR>.</OPERATOR><OO>BitMatrix</OO><OPERATOR>;</OPERATOR>
        <KEYWORD>import</KEYWORD> <OBJ>com</OBJ><OPERATOR>.</OPERATOR><OO>google</OO><OPERATOR>.</OPERATOR><OO>zxing</OO><OPERATOR>.</OPERATOR><OO>common</OO><OPERATOR>.</OPERATOR><OO>BitSource</OO><OPERATOR>;</OPERATOR>
        <KEYWORD>import</KEYWORD> <OBJ>com</OBJ><OPERATOR>.</OPERATOR><OO>google</OO><OPERATOR>.</OPERATOR><OO>zxing</OO><OPERATOR>.</OPERATOR><OO>common</OO><OPERATOR>.</OPERATOR><OO>DecoderResult</OO><OPERATOR>;</OPERATOR>
        <KEYWORD>import</KEYWORD> <OBJ>com</OBJ><OPERATOR>.</OPERATOR><OO>google</OO><OPERATOR>.</OPERATOR><OO>zxing</OO><OPERATOR>.</OPERATOR><OO>common</OO><OPERATOR>.</OPERATOR><OO>flexdatatypes</OO><OPERATOR>.</OPERATOR><OO>StringBuilder</OO><OPERATOR>;</OPERATOR>
        <KEYWORD>import</KEYWORD> <OBJ>com</OBJ><OPERATOR>.</OPERATOR><OO>google</OO><OPERATOR>.</OPERATOR><OO>zxing</OO><OPERATOR>.</OPERATOR><OO>common</OO><OPERATOR>.</OPERATOR><OO>zxingByteArray</OO><OPERATOR>;</OPERATOR>
        <KEYWORD>import</KEYWORD> <OBJ>com</OBJ><OPERATOR>.</OPERATOR><OO>google</OO><OPERATOR>.</OPERATOR><OO>zxing</OO><OPERATOR>.</OPERATOR><OO>ReaderException</OO><OPERATOR>;</OPERATOR>
           <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>           * See ISO 16022:2006, Annex C Table C.1</DOCCOMMENT>
<DOCCOMMENT>           * The C40 Basic Character Set (*'s used for placeholders for the shift values)</DOCCOMMENT>
<DOCCOMMENT>           */</DOCCOMMENT>
          <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD>  <KEYWORD>var</KEYWORD> <CONSTANT>C40_BASIC_SET_CHARS</CONSTANT><OPERATOR>:</OPERATOR><TYPE>Array</TYPE> <OPERATOR>=</OPERATOR> [
              <STRING>'*'</STRING><OPERATOR>,</OPERATOR> <STRING>'*'</STRING><OPERATOR>,</OPERATOR> <STRING>'*'</STRING><OPERATOR>,</OPERATOR> <STRING>' '</STRING><OPERATOR>,</OPERATOR> <STRING>'0'</STRING><OPERATOR>,</OPERATOR> <STRING>'1'</STRING><OPERATOR>,</OPERATOR> <STRING>'2'</STRING><OPERATOR>,</OPERATOR> <STRING>'3'</STRING><OPERATOR>,</OPERATOR> <STRING>'4'</STRING><OPERATOR>,</OPERATOR> <STRING>'5'</STRING><OPERATOR>,</OPERATOR> <STRING>'6'</STRING><OPERATOR>,</OPERATOR> <STRING>'7'</STRING><OPERATOR>,</OPERATOR> <STRING>'8'</STRING><OPERATOR>,</OPERATOR> <STRING>'9'</STRING><OPERATOR>,</OPERATOR>
              <STRING>'A'</STRING><OPERATOR>,</OPERATOR> <STRING>'B'</STRING><OPERATOR>,</OPERATOR> <STRING>'C'</STRING><OPERATOR>,</OPERATOR> <STRING>'D'</STRING><OPERATOR>,</OPERATOR> <STRING>'E'</STRING><OPERATOR>,</OPERATOR> <STRING>'F'</STRING><OPERATOR>,</OPERATOR> <STRING>'G'</STRING><OPERATOR>,</OPERATOR> <STRING>'H'</STRING><OPERATOR>,</OPERATOR> <STRING>'I'</STRING><OPERATOR>,</OPERATOR> <STRING>'J'</STRING><OPERATOR>,</OPERATOR> <STRING>'K'</STRING><OPERATOR>,</OPERATOR> <STRING>'L'</STRING><OPERATOR>,</OPERATOR> <STRING>'M'</STRING><OPERATOR>,</OPERATOR> <STRING>'N'</STRING><OPERATOR>,</OPERATOR>
              <STRING>'O'</STRING><OPERATOR>,</OPERATOR> <STRING>'P'</STRING><OPERATOR>,</OPERATOR> <STRING>'Q'</STRING><OPERATOR>,</OPERATOR> <STRING>'R'</STRING><OPERATOR>,</OPERATOR> <STRING>'S'</STRING><OPERATOR>,</OPERATOR> <STRING>'T'</STRING><OPERATOR>,</OPERATOR> <STRING>'U'</STRING><OPERATOR>,</OPERATOR> <STRING>'V'</STRING><OPERATOR>,</OPERATOR> <STRING>'W'</STRING><OPERATOR>,</OPERATOR> <STRING>'X'</STRING><OPERATOR>,</OPERATOR> <STRING>'Y'</STRING><OPERATOR>,</OPERATOR> <STRING>'Z'</STRING>
          ]<OPERATOR>;</OPERATOR>
          
          <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD>  <KEYWORD>var</KEYWORD> <CONSTANT>C40_SHIFT2_SET_CHARS</CONSTANT><OPERATOR>:</OPERATOR><TYPE>Array</TYPE> <OPERATOR>=</OPERATOR> [
            <STRING>'!'</STRING><OPERATOR>,</OPERATOR> <STRING>'"'</STRING><OPERATOR>,</OPERATOR> <STRING>'#'</STRING><OPERATOR>,</OPERATOR> <STRING>'$'</STRING><OPERATOR>,</OPERATOR> <STRING>'%'</STRING><OPERATOR>,</OPERATOR> <STRING>'&amp;'</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\'</ESC>'</STRING><OPERATOR>,</OPERATOR> <STRING>'('</STRING><OPERATOR>,</OPERATOR> <STRING>')'</STRING><OPERATOR>,</OPERATOR> <STRING>'*'</STRING><OPERATOR>,</OPERATOR> <STRING>'+'</STRING><OPERATOR>,</OPERATOR> <STRING>','</STRING><OPERATOR>,</OPERATOR> <STRING>'-'</STRING><OPERATOR>,</OPERATOR> <STRING>'.'</STRING><OPERATOR>,</OPERATOR>
            <STRING>'/'</STRING><OPERATOR>,</OPERATOR> <STRING>':'</STRING><OPERATOR>,</OPERATOR> <STRING>';'</STRING><OPERATOR>,</OPERATOR> <STRING>'&lt;'</STRING><OPERATOR>,</OPERATOR> <STRING>'='</STRING><OPERATOR>,</OPERATOR> <STRING>'&gt;'</STRING><OPERATOR>,</OPERATOR> <STRING>'?'</STRING><OPERATOR>,</OPERATOR> <STRING>'@'</STRING><OPERATOR>,</OPERATOR> <STRING>'['</STRING><OPERATOR>,</OPERATOR> <STRING>'<ESC>\\</ESC>'</STRING><OPERATOR>,</OPERATOR> <STRING>']'</STRING><OPERATOR>,</OPERATOR> <STRING>'^'</STRING><OPERATOR>,</OPERATOR> <STRING>'_'</STRING>
                ]<OPERATOR>;</OPERATOR>
          
          <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>           * See ISO 16022:2006, Annex C Table C.2</DOCCOMMENT>
<DOCCOMMENT>           * The Text Basic Character Set (*'s used for placeholders for the shift values)</DOCCOMMENT>
<DOCCOMMENT>           */</DOCCOMMENT>
          <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD>  <KEYWORD>var</KEYWORD> <CONSTANT>TEXT_BASIC_SET_CHARS</CONSTANT><OPERATOR>:</OPERATOR><TYPE>Array</TYPE> <OPERATOR>=</OPERATOR> [
            <STRING>'*'</STRING><OPERATOR>,</OPERATOR> <STRING>'*'</STRING><OPERATOR>,</OPERATOR> <STRING>'*'</STRING><OPERATOR>,</OPERATOR> <STRING>' '</STRING><OPERATOR>,</OPERATOR> <STRING>'0'</STRING><OPERATOR>,</OPERATOR> <STRING>'1'</STRING><OPERATOR>,</OPERATOR> <STRING>'2'</STRING><OPERATOR>,</OPERATOR> <STRING>'3'</STRING><OPERATOR>,</OPERATOR> <STRING>'4'</STRING><OPERATOR>,</OPERATOR> <STRING>'5'</STRING><OPERATOR>,</OPERATOR> <STRING>'6'</STRING><OPERATOR>,</OPERATOR> <STRING>'7'</STRING><OPERATOR>,</OPERATOR> <STRING>'8'</STRING><OPERATOR>,</OPERATOR> <STRING>'9'</STRING><OPERATOR>,</OPERATOR>
            <STRING>'a'</STRING><OPERATOR>,</OPERATOR> <STRING>'b'</STRING><OPERATOR>,</OPERATOR> <STRING>'c'</STRING><OPERATOR>,</OPERATOR> <STRING>'d'</STRING><OPERATOR>,</OPERATOR> <STRING>'e'</STRING><OPERATOR>,</OPERATOR> <STRING>'f'</STRING><OPERATOR>,</OPERATOR> <STRING>'g'</STRING><OPERATOR>,</OPERATOR> <STRING>'h'</STRING><OPERATOR>,</OPERATOR> <STRING>'i'</STRING><OPERATOR>,</OPERATOR> <STRING>'j'</STRING><OPERATOR>,</OPERATOR> <STRING>'k'</STRING><OPERATOR>,</OPERATOR> <STRING>'l'</STRING><OPERATOR>,</OPERATOR> <STRING>'m'</STRING><OPERATOR>,</OPERATOR> <STRING>'n'</STRING><OPERATOR>,</OPERATOR>
            <STRING>'o'</STRING><OPERATOR>,</OPERATOR> <STRING>'p'</STRING><OPERATOR>,</OPERATOR> <STRING>'q'</STRING><OPERATOR>,</OPERATOR> <STRING>'r'</STRING><OPERATOR>,</OPERATOR> <STRING>'s'</STRING><OPERATOR>,</OPERATOR> <STRING>'t'</STRING><OPERATOR>,</OPERATOR> <STRING>'u'</STRING><OPERATOR>,</OPERATOR> <STRING>'v'</STRING><OPERATOR>,</OPERATOR> <STRING>'w'</STRING><OPERATOR>,</OPERATOR> <STRING>'x'</STRING><OPERATOR>,</OPERATOR> <STRING>'y'</STRING><OPERATOR>,</OPERATOR> <STRING>'z'</STRING>
          ]<OPERATOR>;</OPERATOR>
          
          <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD>  <KEYWORD>var</KEYWORD> <CONSTANT>TEXT_SHIFT3_SET_CHARS</CONSTANT><OPERATOR>:</OPERATOR><TYPE>Array</TYPE> <OPERATOR>=</OPERATOR> [
            <STRING>'<ESC>\'</ESC>'</STRING><OPERATOR>,</OPERATOR> <STRING>'A'</STRING><OPERATOR>,</OPERATOR> <STRING>'B'</STRING><OPERATOR>,</OPERATOR> <STRING>'C'</STRING><OPERATOR>,</OPERATOR> <STRING>'D'</STRING><OPERATOR>,</OPERATOR> <STRING>'E'</STRING><OPERATOR>,</OPERATOR> <STRING>'F'</STRING><OPERATOR>,</OPERATOR> <STRING>'G'</STRING><OPERATOR>,</OPERATOR> <STRING>'H'</STRING><OPERATOR>,</OPERATOR> <STRING>'I'</STRING><OPERATOR>,</OPERATOR> <STRING>'J'</STRING><OPERATOR>,</OPERATOR> <STRING>'K'</STRING><OPERATOR>,</OPERATOR> <STRING>'L'</STRING><OPERATOR>,</OPERATOR> <STRING>'M'</STRING><OPERATOR>,</OPERATOR> <STRING>'N'</STRING><OPERATOR>,</OPERATOR>
            <STRING>'O'</STRING><OPERATOR>,</OPERATOR> <STRING>'P'</STRING><OPERATOR>,</OPERATOR> <STRING>'Q'</STRING><OPERATOR>,</OPERATOR> <STRING>'R'</STRING><OPERATOR>,</OPERATOR> <STRING>'S'</STRING><OPERATOR>,</OPERATOR> <STRING>'T'</STRING><OPERATOR>,</OPERATOR> <STRING>'U'</STRING><OPERATOR>,</OPERATOR> <STRING>'V'</STRING><OPERATOR>,</OPERATOR> <STRING>'W'</STRING><OPERATOR>,</OPERATOR> <STRING>'X'</STRING><OPERATOR>,</OPERATOR> <STRING>'Y'</STRING><OPERATOR>,</OPERATOR> <STRING>'Z'</STRING><OPERATOR>,</OPERATOR> <STRING>'{'</STRING><OPERATOR>,</OPERATOR> <STRING>'|'</STRING><OPERATOR>,</OPERATOR> <STRING>'}'</STRING><OPERATOR>,</OPERATOR> <STRING>'~'</STRING><OPERATOR>,</OPERATOR> <OBJ>String</OBJ><OPERATOR>.</OPERATOR><OO>fromCharCode</OO>(<NUMERIC>0x127</NUMERIC>)
          ]<OPERATOR>;</OPERATOR>
          
          <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>const</KEYWORD> <CONSTANT>PAD_ENCODE</CONSTANT><OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>  <COMMENT>// Not really an encoding</COMMENT>
          <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>const</KEYWORD> <CONSTANT>ASCII_ENCODE</CONSTANT><OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC><OPERATOR>;</OPERATOR>
          <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>const</KEYWORD> <CONSTANT>C40_ENCODE</CONSTANT><OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> <NUMERIC>2</NUMERIC><OPERATOR>;</OPERATOR>
          <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>const</KEYWORD> <CONSTANT>TEXT_ENCODE</CONSTANT><OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> <NUMERIC>3</NUMERIC><OPERATOR>;</OPERATOR>
          <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>const</KEYWORD> <CONSTANT>ANSIX12_ENCODE</CONSTANT><OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> <NUMERIC>4</NUMERIC><OPERATOR>;</OPERATOR>
          <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>const</KEYWORD> <CONSTANT>EDIFACT_ENCODE</CONSTANT><OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> <NUMERIC>5</NUMERIC><OPERATOR>;</OPERATOR>
          <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>const</KEYWORD> <CONSTANT>BASE256_ENCODE</CONSTANT><OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> <NUMERIC>6</NUMERIC><OPERATOR>;</OPERATOR>

          <KEYWORD>public</KEYWORD> <KEYWORD>function</KEYWORD> DecodedBitStreamParser() {
          }

          <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>function</KEYWORD>  decode(bytes<OPERATOR>:</OPERATOR><TYPE>Array</TYPE> )<OPERATOR>:</OPERATOR>DecoderResult {
            <KEYWORD>var</KEYWORD> bits<OPERATOR>:</OPERATOR>BitSource  <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> BitSource(bytes)<OPERATOR>;</OPERATOR>
            <KEYWORD>var</KEYWORD> result<OPERATOR>:</OPERATOR>StringBuilder <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> StringBuilder()<OPERATOR>;</OPERATOR>
            <KEYWORD>var</KEYWORD> resultTrailer<OPERATOR>:</OPERATOR>StringBuilder  <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> StringBuilder(<NUMERIC>0</NUMERIC>)<OPERATOR>;</OPERATOR>
            <KEYWORD>var</KEYWORD>  byteSegments<OPERATOR>:</OPERATOR>ArrayList <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> ArrayList(<NUMERIC>1</NUMERIC>)<OPERATOR>;</OPERATOR>
            <KEYWORD>var</KEYWORD> mode<OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> <OBJ>DecodedBitStreamParser</OBJ><OPERATOR>.</OPERATOR><OO>ASCII_ENCODE</OO><OPERATOR>;</OPERATOR>
            <KEYWORD>do</KEYWORD> {
              <KEYWORD>if</KEYWORD> (mode <OPERATOR>==</OPERATOR> <CONSTANT>ASCII_ENCODE</CONSTANT>) {
                mode <OPERATOR>=</OPERATOR> decodeAsciiSegment(bits<OPERATOR>,</OPERATOR> result<OPERATOR>,</OPERATOR> resultTrailer)<OPERATOR>;</OPERATOR>
              } <KEYWORD>else</KEYWORD> {
                <KEYWORD>switch</KEYWORD> (mode) {
                  <KEYWORD>case</KEYWORD> <CONSTANT>C40_ENCODE</CONSTANT><OPERATOR>:</OPERATOR>
                    decodeC40Segment(bits<OPERATOR>,</OPERATOR> result)<OPERATOR>;</OPERATOR>
                    <KEYWORD>break</KEYWORD><OPERATOR>;</OPERATOR>
                  <KEYWORD>case</KEYWORD> <CONSTANT>TEXT_ENCODE</CONSTANT><OPERATOR>:</OPERATOR>
                    decodeTextSegment(bits<OPERATOR>,</OPERATOR> result)<OPERATOR>;</OPERATOR>
                    <KEYWORD>break</KEYWORD><OPERATOR>;</OPERATOR>
                  <KEYWORD>case</KEYWORD> <CONSTANT>ANSIX12_ENCODE</CONSTANT><OPERATOR>:</OPERATOR>
                    decodeAnsiX12Segment(bits<OPERATOR>,</OPERATOR> result)<OPERATOR>;</OPERATOR>
                    <KEYWORD>break</KEYWORD><OPERATOR>;</OPERATOR>
                  <KEYWORD>case</KEYWORD> <CONSTANT>EDIFACT_ENCODE</CONSTANT><OPERATOR>:</OPERATOR>
                    decodeEdifactSegment(bits<OPERATOR>,</OPERATOR> result)<OPERATOR>;</OPERATOR>
                    <KEYWORD>break</KEYWORD><OPERATOR>;</OPERATOR>
                  <KEYWORD>case</KEYWORD> <CONSTANT>BASE256_ENCODE</CONSTANT><OPERATOR>:</OPERATOR>
                    decodeBase256Segment(bits<OPERATOR>,</OPERATOR> result<OPERATOR>,</OPERATOR> byteSegments)<OPERATOR>;</OPERATOR>
                    <KEYWORD>break</KEYWORD><OPERATOR>;</OPERATOR>
                  <KEYWORD>default</KEYWORD><OPERATOR>:</OPERATOR>
                    <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> ReaderException(<STRING>"DecodedBitStreamParser : decode : unknown mode : "</STRING><OPERATOR>+</OPERATOR>mode)<OPERATOR>;</OPERATOR>
                }
                mode <OPERATOR>=</OPERATOR> <CONSTANT>ASCII_ENCODE</CONSTANT><OPERATOR>;</OPERATOR>
              }
            } <KEYWORD>while</KEYWORD> (mode <OPERATOR>!=</OPERATOR> <CONSTANT>PAD_ENCODE</CONSTANT> <OPERATOR>&amp;&amp;</OPERATOR> <OBJ>bits</OBJ><OPERATOR>.</OPERATOR><OO>available</OO>() <OPERATOR>&gt;</OPERATOR> <NUMERIC>0</NUMERIC>)<OPERATOR>;</OPERATOR>
            <KEYWORD>if</KEYWORD> (<OBJ>resultTrailer</OBJ><OPERATOR>.</OPERATOR><OO>length</OO> <OPERATOR>&gt;</OPERATOR> <NUMERIC>0</NUMERIC>) {
              <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(resultTrailer)<OPERATOR>;</OPERATOR>
            }
            <KEYWORD>return</KEYWORD> <KEYWORD>new</KEYWORD> DecoderResult(bytes<OPERATOR>,</OPERATOR> <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>ToString</OO>()<OPERATOR>,</OPERATOR> (<OBJ>byteSegments</OBJ><OPERATOR>.</OPERATOR><OO>Count</OO> <OPERATOR>===</OPERATOR> <NUMERIC>0</NUMERIC>) <OPERATOR>?</OPERATOR> <KEYWORD>null</KEYWORD> <OPERATOR>:</OPERATOR> byteSegments<OPERATOR>,</OPERATOR> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>
          }
          
          <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>           * See ISO 16022:2006, 5.2.3 and Annex C, Table C.2</DOCCOMMENT>
<DOCCOMMENT>           */</DOCCOMMENT>
          <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>function</KEYWORD> decodeAsciiSegment(bits<OPERATOR>:</OPERATOR>BitSource<OPERATOR>,</OPERATOR> result<OPERATOR>:</OPERATOR>StringBuilder<OPERATOR>,</OPERATOR> resultTrailer<OPERATOR>:</OPERATOR>StringBuilder)<OPERATOR>:</OPERATOR><TYPE>int</TYPE>
              {
            <KEYWORD>var</KEYWORD> upperShift<OPERATOR>:</OPERATOR><TYPE>Boolean</TYPE> <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD><OPERATOR>;</OPERATOR>
            <KEYWORD>do</KEYWORD> {
              <KEYWORD>var</KEYWORD> oneByte<OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> <OBJ>bits</OBJ><OPERATOR>.</OPERATOR><OO>readBits</OO>(<NUMERIC>8</NUMERIC>)<OPERATOR>;</OPERATOR>
              <KEYWORD>if</KEYWORD> (oneByte <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC>) {
                        <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> ReaderException(<STRING>"DecodedBitStreamParser : decodeAsciiSegment : oneByte = 0"</STRING>)<OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (oneByte <OPERATOR>&lt;=</OPERATOR> <NUMERIC>128</NUMERIC>) {  <COMMENT>// ASCII data (ASCII value + 1)</COMMENT>
                        oneByte <OPERATOR>=</OPERATOR> upperShift <OPERATOR>?</OPERATOR> (oneByte <OPERATOR>+</OPERATOR> <NUMERIC>128</NUMERIC>) <OPERATOR>:</OPERATOR> oneByte<OPERATOR>;</OPERATOR>
                        upperShift <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD><OPERATOR>;</OPERATOR>
                        <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(<OBJ>String</OBJ><OPERATOR>.</OPERATOR><OO>fromCharCode</OO>(oneByte <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>))<OPERATOR>;</OPERATOR>
                        <KEYWORD>return</KEYWORD> <CONSTANT>ASCII_ENCODE</CONSTANT><OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (oneByte <OPERATOR>==</OPERATOR> <NUMERIC>129</NUMERIC>) {  <COMMENT>// Pad</COMMENT>
                        <KEYWORD>return</KEYWORD> <CONSTANT>PAD_ENCODE</CONSTANT><OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (oneByte <OPERATOR>&lt;=</OPERATOR> <NUMERIC>229</NUMERIC>) {  <COMMENT>// 2-digit data 00-99 (Numeric Value + 130)</COMMENT>
                      <KEYWORD>var</KEYWORD> value<OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> oneByte <OPERATOR>-</OPERATOR> <NUMERIC>130</NUMERIC><OPERATOR>;</OPERATOR>
                      <KEYWORD>if</KEYWORD> (value <OPERATOR>&lt;</OPERATOR> <NUMERIC>10</NUMERIC>) { <COMMENT>// padd with '0' for single digit values</COMMENT>
                        <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(<STRING>'0'</STRING>)<OPERATOR>;</OPERATOR>
                      }
                        <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(value)<OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (oneByte <OPERATOR>==</OPERATOR> <NUMERIC>230</NUMERIC>) {  <COMMENT>// Latch to C40 encodation</COMMENT>
                        <KEYWORD>return</KEYWORD> <CONSTANT>C40_ENCODE</CONSTANT><OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (oneByte <OPERATOR>==</OPERATOR> <NUMERIC>231</NUMERIC>) {  <COMMENT>// Latch to Base 256 encodation</COMMENT>
                        <KEYWORD>return</KEYWORD> <CONSTANT>BASE256_ENCODE</CONSTANT><OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (oneByte <OPERATOR>==</OPERATOR> <NUMERIC>232</NUMERIC>) {  <COMMENT>// FNC1</COMMENT>
                        <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> ReaderException(<STRING>"DecodedBitStreamParser : decodeAsciiSegment : oneByte = 232 "</STRING>)<OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (oneByte <OPERATOR>==</OPERATOR> <NUMERIC>233</NUMERIC>) {  <COMMENT>// Structured Append</COMMENT>
                        <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> ReaderException(<STRING>"DecodedBitStreamParser : decodeAsciiSegment : oneByte = 233"</STRING>)<OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (oneByte <OPERATOR>==</OPERATOR> <NUMERIC>234</NUMERIC>) {  <COMMENT>// Reader Programming</COMMENT>
                        <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> ReaderException(<STRING>"DecodedBitStreamParser : decodeAsciiSegment : oneByte = 234"</STRING>)<OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (oneByte <OPERATOR>==</OPERATOR> <NUMERIC>235</NUMERIC>) {  <COMMENT>// Upper Shift (shift to Extended ASCII)</COMMENT>
                        upperShift <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD><OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (oneByte <OPERATOR>==</OPERATOR> <NUMERIC>236</NUMERIC>) {  <COMMENT>// 05 Macro</COMMENT>
                <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(<STRING>"[)&gt;<ESC>\u001E05</ESC><ESC>\u001D</ESC>"</STRING>)<OPERATOR>;</OPERATOR>
                <OBJ>resultTrailer</OBJ><OPERATOR>.</OPERATOR><OO>Insert</OO>(<NUMERIC>0</NUMERIC><OPERATOR>,</OPERATOR> <STRING>"<ESC>\u001E</ESC><ESC>\u0004</ESC>"</STRING>)<OPERATOR>;</OPERATOR>
              } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (oneByte <OPERATOR>==</OPERATOR> <NUMERIC>237</NUMERIC>) {  <COMMENT>// 06 Macro</COMMENT>
                        <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(<STRING>"[)&gt;<ESC>\u001E06</ESC><ESC>\u001D</ESC>"</STRING>)<OPERATOR>;</OPERATOR>
                <OBJ>resultTrailer</OBJ><OPERATOR>.</OPERATOR><OO>Insert</OO>(<NUMERIC>0</NUMERIC><OPERATOR>,</OPERATOR> <STRING>"<ESC>\u001E</ESC><ESC>\u0004</ESC>"</STRING>)<OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (oneByte <OPERATOR>==</OPERATOR> <NUMERIC>238</NUMERIC>) {  <COMMENT>// Latch to ANSI X12 encodation</COMMENT>
                        <KEYWORD>return</KEYWORD> <CONSTANT>ANSIX12_ENCODE</CONSTANT><OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (oneByte <OPERATOR>==</OPERATOR> <NUMERIC>239</NUMERIC>) {  <COMMENT>// Latch to Text encodation</COMMENT>
                        <KEYWORD>return</KEYWORD> <CONSTANT>TEXT_ENCODE</CONSTANT><OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (oneByte <OPERATOR>==</OPERATOR> <NUMERIC>240</NUMERIC>) {  <COMMENT>// Latch to EDIFACT encodation</COMMENT>
                        <KEYWORD>return</KEYWORD> <CONSTANT>EDIFACT_ENCODE</CONSTANT><OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (oneByte <OPERATOR>==</OPERATOR> <NUMERIC>241</NUMERIC>) {  <COMMENT>// ECI Character</COMMENT>
                        <COMMENT>// <COMMENT_NOTE>TODO</COMMENT_NOTE>(bbrown): I think we need to support ECI</COMMENT>
                        <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> ReaderException(<STRING>"DecodedBitStreamParser : decodeAsciiSegment : oneByte = 241"</STRING>)<OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (oneByte <OPERATOR>&gt;=</OPERATOR> <NUMERIC>242</NUMERIC>) {  <COMMENT>// Not to be used in ASCII encodation</COMMENT>
                        <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> ReaderException(<STRING>"DecodedBitStreamParser : decodeAsciiSegment : oneByte = 242"</STRING>)<OPERATOR>;</OPERATOR>
                    }
            } <KEYWORD>while</KEYWORD> (<OBJ>bits</OBJ><OPERATOR>.</OPERATOR><OO>available</OO>() <OPERATOR>&gt;</OPERATOR> <NUMERIC>0</NUMERIC>)<OPERATOR>;</OPERATOR>
            <KEYWORD>return</KEYWORD> <CONSTANT>ASCII_ENCODE</CONSTANT><OPERATOR>;</OPERATOR>
          }

          <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>           * See ISO 16022:2006, 5.2.5 and Annex C, Table C.1</DOCCOMMENT>
<DOCCOMMENT>           */</DOCCOMMENT>
          <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>function</KEYWORD> decodeC40Segment(bits<OPERATOR>:</OPERATOR>BitSource <OPERATOR>,</OPERATOR> result<OPERATOR>:</OPERATOR>StringBuilder )<OPERATOR>:</OPERATOR><KEYWORD>void</KEYWORD> {
            <COMMENT>// Three C40 values are encoded in a 16-bit value as</COMMENT>
            <COMMENT>// (1600 * C1) + (40 * C2) + C3 + 1</COMMENT>
            <COMMENT>// <COMMENT_NOTE>TODO</COMMENT_NOTE>(bbrown): The Upper Shift with C40 doesn't work in the 4 value scenario all the time</COMMENT>
            <KEYWORD>var</KEYWORD> upperShift<OPERATOR>:</OPERATOR><TYPE>Boolean</TYPE> <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD><OPERATOR>;</OPERATOR>

            <KEYWORD>var</KEYWORD> cValues<OPERATOR>:</OPERATOR><TYPE>Array</TYPE> <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Array</TYPE>(<NUMERIC>3</NUMERIC>)<OPERATOR>;</OPERATOR>
            <KEYWORD>do</KEYWORD> {
              <COMMENT>// If there is only one byte left then it will be encoded as ASCII</COMMENT>
              <KEYWORD>if</KEYWORD> (<OBJ>bits</OBJ><OPERATOR>.</OPERATOR><OO>available</OO>() <OPERATOR>==</OPERATOR> <NUMERIC>8</NUMERIC>) {
                <KEYWORD>return</KEYWORD><OPERATOR>;</OPERATOR>
              }
              <KEYWORD>var</KEYWORD> firstByte<OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> <OBJ>bits</OBJ><OPERATOR>.</OPERATOR><OO>readBits</OO>(<NUMERIC>8</NUMERIC>)<OPERATOR>;</OPERATOR>
              <KEYWORD>if</KEYWORD> (firstByte <OPERATOR>==</OPERATOR> <NUMERIC>254</NUMERIC>) {  <COMMENT>// Unlatch codeword</COMMENT>
                <KEYWORD>return</KEYWORD><OPERATOR>;</OPERATOR>
              }

              parseTwoBytes(firstByte<OPERATOR>,</OPERATOR> <OBJ>bits</OBJ><OPERATOR>.</OPERATOR><OO>readBits</OO>(<NUMERIC>8</NUMERIC>)<OPERATOR>,</OPERATOR> cValues)<OPERATOR>;</OPERATOR>

              <KEYWORD>var</KEYWORD> shift<OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
              <KEYWORD>for</KEYWORD> (<KEYWORD>var</KEYWORD> i<OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR> i <OPERATOR>&lt;</OPERATOR> <NUMERIC>3</NUMERIC><OPERATOR>;</OPERATOR> i<OPERATOR>++</OPERATOR>) {
                <KEYWORD>var</KEYWORD> cValue<OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> cValues[i]<OPERATOR>;</OPERATOR>
                <KEYWORD>switch</KEYWORD> (shift) {
                  <KEYWORD>case</KEYWORD> <NUMERIC>0</NUMERIC><OPERATOR>:</OPERATOR>
                    <KEYWORD>if</KEYWORD> (cValue <OPERATOR>&lt;</OPERATOR> <NUMERIC>3</NUMERIC>) {
                      shift <OPERATOR>=</OPERATOR> cValue <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC><OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> {
                      <KEYWORD>if</KEYWORD> (upperShift) {
                        <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(<CONSTANT>C40_BASIC_SET_CHARS</CONSTANT>[cValue] <OPERATOR>+</OPERATOR> <NUMERIC>128</NUMERIC>)<OPERATOR>;</OPERATOR>
                        upperShift <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD><OPERATOR>;</OPERATOR>
                      } <KEYWORD>else</KEYWORD> {
                        <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(<CONSTANT>C40_BASIC_SET_CHARS</CONSTANT>[cValue])<OPERATOR>;</OPERATOR>
                      }
                    }
                    <KEYWORD>break</KEYWORD><OPERATOR>;</OPERATOR>
                  <KEYWORD>case</KEYWORD> <NUMERIC>1</NUMERIC><OPERATOR>:</OPERATOR>
                    <KEYWORD>if</KEYWORD> (upperShift) {
                      <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(cValue <OPERATOR>+</OPERATOR> <NUMERIC>128</NUMERIC>)<OPERATOR>;</OPERATOR>
                      upperShift <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD><OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> {
                      <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(cValue)<OPERATOR>;</OPERATOR>
                    }
                    shift <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
                    <KEYWORD>break</KEYWORD><OPERATOR>;</OPERATOR>
                  <KEYWORD>case</KEYWORD> <NUMERIC>2</NUMERIC><OPERATOR>:</OPERATOR>
                    <KEYWORD>if</KEYWORD> (cValue <OPERATOR>&lt;</OPERATOR> <NUMERIC>27</NUMERIC>) {
                      <KEYWORD>if</KEYWORD> (upperShift) {
                        <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(<CONSTANT>C40_SHIFT2_SET_CHARS</CONSTANT>[cValue] <OPERATOR>+</OPERATOR> <NUMERIC>128</NUMERIC>)<OPERATOR>;</OPERATOR>
                        upperShift <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD><OPERATOR>;</OPERATOR>
                      } <KEYWORD>else</KEYWORD> {
                        <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(<CONSTANT>C40_SHIFT2_SET_CHARS</CONSTANT>[cValue])<OPERATOR>;</OPERATOR>
                      }
                    } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (cValue <OPERATOR>==</OPERATOR> <NUMERIC>27</NUMERIC>) {  <COMMENT>// FNC1</COMMENT>
                      <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> ReaderException(<STRING>"DecodedBitStreamParser : decodeC40Segment : cValue = 27"</STRING>)<OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (cValue <OPERATOR>==</OPERATOR> <NUMERIC>30</NUMERIC>) {  <COMMENT>// Upper Shift</COMMENT>
                      upperShift <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD><OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> {
                      <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> ReaderException(<STRING>"DecodedBitStreamParser : decodeC40Segment : cValue = no match:"</STRING><OPERATOR>+</OPERATOR>cValue)<OPERATOR>;</OPERATOR>
                    }
                    shift <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
                    <KEYWORD>break</KEYWORD><OPERATOR>;</OPERATOR>
                  <KEYWORD>case</KEYWORD> <NUMERIC>3</NUMERIC><OPERATOR>:</OPERATOR>
                    <KEYWORD>if</KEYWORD> (upperShift) {
                      <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(cValue <OPERATOR>+</OPERATOR> <NUMERIC>224</NUMERIC>)<OPERATOR>;</OPERATOR>
                      upperShift <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD><OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> {
                      <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(cValue <OPERATOR>+</OPERATOR> <NUMERIC>96</NUMERIC>)<OPERATOR>;</OPERATOR>
                    }
                    shift <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
                    <KEYWORD>break</KEYWORD><OPERATOR>;</OPERATOR>
                  <KEYWORD>default</KEYWORD><OPERATOR>:</OPERATOR>
                    <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> ReaderException(<STRING>"DecodedBitStreamParser : decodeC40Segment : no match for shift:"</STRING><OPERATOR>+</OPERATOR>shift)<OPERATOR>;</OPERATOR>
                }
              }
            } <KEYWORD>while</KEYWORD> (<OBJ>bits</OBJ><OPERATOR>.</OPERATOR><OO>available</OO>() <OPERATOR>&gt;</OPERATOR> <NUMERIC>0</NUMERIC>)<OPERATOR>;</OPERATOR>
          }
          
          <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>           * See ISO 16022:2006, 5.2.6 and Annex C, Table C.2</DOCCOMMENT>
<DOCCOMMENT>           */</DOCCOMMENT>
          <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>function</KEYWORD> decodeTextSegment(bits<OPERATOR>:</OPERATOR>BitSource <OPERATOR>,</OPERATOR> result<OPERATOR>:</OPERATOR>StringBuilder )<OPERATOR>:</OPERATOR><KEYWORD>void</KEYWORD> {
            <COMMENT>// Three Text values are encoded in a 16-bit value as</COMMENT>
            <COMMENT>// (1600 * C1) + (40 * C2) + C3 + 1</COMMENT>
            <COMMENT>// <COMMENT_NOTE>TODO</COMMENT_NOTE>(bbrown): The Upper Shift with Text doesn't work in the 4 value scenario all the time</COMMENT>
            <KEYWORD>var</KEYWORD> upperShift<OPERATOR>:</OPERATOR><TYPE>Boolean</TYPE> <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD><OPERATOR>;</OPERATOR>

            <KEYWORD>var</KEYWORD> cValues<OPERATOR>:</OPERATOR><TYPE>Array</TYPE> <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Array</TYPE>(<NUMERIC>3</NUMERIC>)<OPERATOR>;</OPERATOR>
            <KEYWORD>do</KEYWORD> {
              <COMMENT>// If there is only one byte left then it will be encoded as ASCII</COMMENT>
              <KEYWORD>if</KEYWORD> (<OBJ>bits</OBJ><OPERATOR>.</OPERATOR><OO>available</OO>() <OPERATOR>==</OPERATOR> <NUMERIC>8</NUMERIC>) {
                <KEYWORD>return</KEYWORD><OPERATOR>;</OPERATOR>
              }
              <KEYWORD>var</KEYWORD> firstByte<OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> <OBJ>bits</OBJ><OPERATOR>.</OPERATOR><OO>readBits</OO>(<NUMERIC>8</NUMERIC>)<OPERATOR>;</OPERATOR>
              <KEYWORD>if</KEYWORD> (firstByte <OPERATOR>==</OPERATOR> <NUMERIC>254</NUMERIC>) {  <COMMENT>// Unlatch codeword</COMMENT>
                <KEYWORD>return</KEYWORD><OPERATOR>;</OPERATOR>
              }

              parseTwoBytes(firstByte<OPERATOR>,</OPERATOR> <OBJ>bits</OBJ><OPERATOR>.</OPERATOR><OO>readBits</OO>(<NUMERIC>8</NUMERIC>)<OPERATOR>,</OPERATOR> cValues)<OPERATOR>;</OPERATOR>

              <KEYWORD>var</KEYWORD> shift<OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
              <KEYWORD>for</KEYWORD> (<KEYWORD>var</KEYWORD> i<OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR> i <OPERATOR>&lt;</OPERATOR> <NUMERIC>3</NUMERIC><OPERATOR>;</OPERATOR> i<OPERATOR>++</OPERATOR>) {
                <KEYWORD>var</KEYWORD> cValue<OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> cValues[i]<OPERATOR>;</OPERATOR>
                <KEYWORD>switch</KEYWORD> (shift) {
                  <KEYWORD>case</KEYWORD> <NUMERIC>0</NUMERIC><OPERATOR>:</OPERATOR>
                    <KEYWORD>if</KEYWORD> (cValue <OPERATOR>&lt;</OPERATOR> <NUMERIC>3</NUMERIC>) {
                      shift <OPERATOR>=</OPERATOR> cValue <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC><OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> {
                      <KEYWORD>if</KEYWORD> (upperShift) {
                        <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(<CONSTANT>TEXT_BASIC_SET_CHARS</CONSTANT>[cValue])<OPERATOR>;</OPERATOR>
                        upperShift <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD><OPERATOR>;</OPERATOR>
                      } <KEYWORD>else</KEYWORD> {
                        <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(<CONSTANT>TEXT_BASIC_SET_CHARS</CONSTANT>[cValue])<OPERATOR>;</OPERATOR>
                      }
                    }
                    <KEYWORD>break</KEYWORD><OPERATOR>;</OPERATOR>
                  <KEYWORD>case</KEYWORD> <NUMERIC>1</NUMERIC><OPERATOR>:</OPERATOR>
                    <KEYWORD>if</KEYWORD> (upperShift) {
                      <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(cValue <OPERATOR>+</OPERATOR> <NUMERIC>128</NUMERIC>)<OPERATOR>;</OPERATOR>
                      upperShift <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD><OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> {
                      <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(cValue)<OPERATOR>;</OPERATOR>
                    }
                    shift <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
                    <KEYWORD>break</KEYWORD><OPERATOR>;</OPERATOR>
                  <KEYWORD>case</KEYWORD> <NUMERIC>2</NUMERIC><OPERATOR>:</OPERATOR>
                    <COMMENT>// Shift 2 for Text is the same encoding as C40</COMMENT>
                    <KEYWORD>if</KEYWORD> (cValue <OPERATOR>&lt;</OPERATOR> <NUMERIC>27</NUMERIC>) {
                      <KEYWORD>if</KEYWORD> (upperShift) {
                        <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(<CONSTANT>C40_SHIFT2_SET_CHARS</CONSTANT>[cValue] <OPERATOR>+</OPERATOR> <NUMERIC>128</NUMERIC>)<OPERATOR>;</OPERATOR>
                        upperShift <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD><OPERATOR>;</OPERATOR>
                      } <KEYWORD>else</KEYWORD> {
                        <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(<CONSTANT>C40_SHIFT2_SET_CHARS</CONSTANT>[cValue])<OPERATOR>;</OPERATOR>
                      }
                    } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (cValue <OPERATOR>==</OPERATOR> <NUMERIC>27</NUMERIC>) {  <COMMENT>// FNC1</COMMENT>
                      <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> ReaderException( <STRING>"DecodedBitStreamParser : decodeTextSegment : cValue = 27"</STRING>)<OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (cValue <OPERATOR>==</OPERATOR> <NUMERIC>30</NUMERIC>) {  <COMMENT>// Upper Shift</COMMENT>
                      upperShift <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD><OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> {
                      <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> ReaderException(<STRING>"DecodedBitStreamParser : decodeTextSegment : no match for cValue:"</STRING><OPERATOR>+</OPERATOR>cValue)<OPERATOR>;</OPERATOR>
                    }
                    shift <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
                    <KEYWORD>break</KEYWORD><OPERATOR>;</OPERATOR>
                  <KEYWORD>case</KEYWORD> <NUMERIC>3</NUMERIC><OPERATOR>:</OPERATOR>
                    <KEYWORD>if</KEYWORD> (upperShift) {
                      <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(<CONSTANT>TEXT_SHIFT3_SET_CHARS</CONSTANT>[cValue] <OPERATOR>+</OPERATOR> <NUMERIC>128</NUMERIC>)<OPERATOR>;</OPERATOR>
                      upperShift <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD><OPERATOR>;</OPERATOR>
                    } <KEYWORD>else</KEYWORD> {
                      <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(<CONSTANT>TEXT_SHIFT3_SET_CHARS</CONSTANT>[cValue])<OPERATOR>;</OPERATOR>
                    }
                    shift <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
                    <KEYWORD>break</KEYWORD><OPERATOR>;</OPERATOR>
                  <KEYWORD>default</KEYWORD><OPERATOR>:</OPERATOR>
                    <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> ReaderException(<STRING>"DecodedBitStreamParser : decodeTextSegment : no match for shift"</STRING><OPERATOR>+</OPERATOR>shift)<OPERATOR>;</OPERATOR>
                }
              }
            } <KEYWORD>while</KEYWORD> (<OBJ>bits</OBJ><OPERATOR>.</OPERATOR><OO>available</OO>() <OPERATOR>&gt;</OPERATOR> <NUMERIC>0</NUMERIC>)<OPERATOR>;</OPERATOR>
          }
          
          <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>           * See ISO 16022:2006, 5.2.7</DOCCOMMENT>
<DOCCOMMENT>           */</DOCCOMMENT>
          <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>function</KEYWORD> decodeAnsiX12Segment(bits<OPERATOR>:</OPERATOR>BitSource<OPERATOR>,</OPERATOR> result<OPERATOR>:</OPERATOR>StringBuilder)<OPERATOR>:</OPERATOR><KEYWORD>void</KEYWORD> {
            <COMMENT>// Three ANSI X12 values are encoded in a 16-bit value as</COMMENT>
            <COMMENT>// (1600 * C1) + (40 * C2) + C3 + 1</COMMENT>

            <KEYWORD>var</KEYWORD> cValues<OPERATOR>:</OPERATOR><TYPE>Array</TYPE> <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Array</TYPE>(<NUMERIC>3</NUMERIC>)<OPERATOR>;</OPERATOR>
            <KEYWORD>do</KEYWORD> {
              <COMMENT>// If there is only one byte left then it will be encoded as ASCII</COMMENT>
              <KEYWORD>if</KEYWORD> (<OBJ>bits</OBJ><OPERATOR>.</OPERATOR><OO>available</OO>() <OPERATOR>==</OPERATOR> <NUMERIC>8</NUMERIC>) {
                <KEYWORD>return</KEYWORD><OPERATOR>;</OPERATOR>
              }
              <KEYWORD>var</KEYWORD> firstByte<OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> <OBJ>bits</OBJ><OPERATOR>.</OPERATOR><OO>readBits</OO>(<NUMERIC>8</NUMERIC>)<OPERATOR>;</OPERATOR>
              <KEYWORD>if</KEYWORD> (firstByte <OPERATOR>==</OPERATOR> <NUMERIC>254</NUMERIC>) {  <COMMENT>// Unlatch codeword</COMMENT>
                <KEYWORD>return</KEYWORD><OPERATOR>;</OPERATOR>
              }

              parseTwoBytes(firstByte<OPERATOR>,</OPERATOR> <OBJ>bits</OBJ><OPERATOR>.</OPERATOR><OO>readBits</OO>(<NUMERIC>8</NUMERIC>)<OPERATOR>,</OPERATOR> cValues)<OPERATOR>;</OPERATOR>

              <KEYWORD>for</KEYWORD> (<KEYWORD>var</KEYWORD> i<OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR> i <OPERATOR>&lt;</OPERATOR> <NUMERIC>3</NUMERIC><OPERATOR>;</OPERATOR> i<OPERATOR>++</OPERATOR>) {
                <KEYWORD>var</KEYWORD> cValue<OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> cValues[i]<OPERATOR>;</OPERATOR>
                <KEYWORD>if</KEYWORD> (cValue <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC>) {  <COMMENT>// X12 segment terminator &lt;CR&gt;</COMMENT>
                  <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(<STRING>'<ESC>\r</ESC>'</STRING>)<OPERATOR>;</OPERATOR>
                } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (cValue <OPERATOR>==</OPERATOR> <NUMERIC>1</NUMERIC>) {  <COMMENT>// X12 segment separator *</COMMENT>
                  <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(<STRING>'*'</STRING>)<OPERATOR>;</OPERATOR>
                } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (cValue <OPERATOR>==</OPERATOR> <NUMERIC>2</NUMERIC>) {  <COMMENT>// X12 sub-element separator &gt;</COMMENT>
                  <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(<STRING>'&gt;'</STRING>)<OPERATOR>;</OPERATOR>
                } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (cValue <OPERATOR>==</OPERATOR> <NUMERIC>3</NUMERIC>) {  <COMMENT>// space</COMMENT>
                  <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(<STRING>' '</STRING>)<OPERATOR>;</OPERATOR>
                } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (cValue <OPERATOR>&lt;</OPERATOR> <NUMERIC>14</NUMERIC>) {  <COMMENT>// 0 - 9</COMMENT>
                  <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(cValue <OPERATOR>+</OPERATOR> <NUMERIC>44</NUMERIC>)<OPERATOR>;</OPERATOR>
                } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (cValue <OPERATOR>&lt;</OPERATOR> <NUMERIC>40</NUMERIC>) {  <COMMENT>// A - Z</COMMENT>
                  <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(cValue <OPERATOR>+</OPERATOR> <NUMERIC>51</NUMERIC>)<OPERATOR>;</OPERATOR>
                } <KEYWORD>else</KEYWORD> {
                  <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> ReaderException(<STRING>"DecodedBitStreamParser : decodeTextSegment : no match for cValue : "</STRING><OPERATOR>+</OPERATOR> cValue)<OPERATOR>;</OPERATOR>
                }
              }
            } <KEYWORD>while</KEYWORD> (<OBJ>bits</OBJ><OPERATOR>.</OPERATOR><OO>available</OO>() <OPERATOR>&gt;</OPERATOR> <NUMERIC>0</NUMERIC>)<OPERATOR>;</OPERATOR>
          }

          <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>function</KEYWORD> parseTwoBytes(firstByte<OPERATOR>:</OPERATOR><TYPE>int</TYPE><OPERATOR>,</OPERATOR> secondByte<OPERATOR>:</OPERATOR><TYPE>int</TYPE><OPERATOR>,</OPERATOR> result<OPERATOR>:</OPERATOR><TYPE>Array</TYPE>)<OPERATOR>:</OPERATOR><KEYWORD>void</KEYWORD> {
            <KEYWORD>var</KEYWORD> fullBitValue<OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> (firstByte <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>8</NUMERIC>) <OPERATOR>+</OPERATOR> secondByte <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC><OPERATOR>;</OPERATOR>
            <KEYWORD>var</KEYWORD> temp<OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> fullBitValue <OPERATOR>/</OPERATOR> <NUMERIC>1600</NUMERIC><OPERATOR>;</OPERATOR>
            result[<NUMERIC>0</NUMERIC>] <OPERATOR>=</OPERATOR> temp<OPERATOR>;</OPERATOR>
            fullBitValue <OPERATOR>-=</OPERATOR> temp <OPERATOR>*</OPERATOR> <NUMERIC>1600</NUMERIC><OPERATOR>;</OPERATOR>
            temp <OPERATOR>=</OPERATOR> fullBitValue <OPERATOR>/</OPERATOR> <NUMERIC>40</NUMERIC><OPERATOR>;</OPERATOR>
            result[<NUMERIC>1</NUMERIC>] <OPERATOR>=</OPERATOR> temp<OPERATOR>;</OPERATOR>
            result[<NUMERIC>2</NUMERIC>] <OPERATOR>=</OPERATOR> fullBitValue <OPERATOR>-</OPERATOR> temp <OPERATOR>*</OPERATOR> <NUMERIC>40</NUMERIC><OPERATOR>;</OPERATOR>
          }
          
          <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>           * See ISO 16022:2006, 5.2.8 and Annex C Table C.3</DOCCOMMENT>
<DOCCOMMENT>           */</DOCCOMMENT>
          <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>function</KEYWORD> decodeEdifactSegment(bits<OPERATOR>:</OPERATOR>BitSource<OPERATOR>,</OPERATOR> result<OPERATOR>:</OPERATOR>StringBuilder)<OPERATOR>:</OPERATOR><KEYWORD>void</KEYWORD> {
            <KEYWORD>var</KEYWORD> unlatch<OPERATOR>:</OPERATOR><TYPE>Boolean</TYPE> <OPERATOR>=</OPERATOR> <KEYWORD>false</KEYWORD><OPERATOR>;</OPERATOR>
            <KEYWORD>do</KEYWORD> {
              <COMMENT>// If there is only two or less bytes left then it will be encoded as ASCII</COMMENT>
              <KEYWORD>if</KEYWORD> (<OBJ>bits</OBJ><OPERATOR>.</OPERATOR><OO>available</OO>() <OPERATOR>&lt;=</OPERATOR> <NUMERIC>16</NUMERIC>) {
                <KEYWORD>return</KEYWORD><OPERATOR>;</OPERATOR>
              }

              <KEYWORD>for</KEYWORD> (<KEYWORD>var</KEYWORD> i<OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR> i <OPERATOR>&lt;</OPERATOR> <NUMERIC>4</NUMERIC><OPERATOR>;</OPERATOR> i<OPERATOR>++</OPERATOR>) {
                <KEYWORD>var</KEYWORD> edifactValue<OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> <OBJ>bits</OBJ><OPERATOR>.</OPERATOR><OO>readBits</OO>(<NUMERIC>6</NUMERIC>)<OPERATOR>;</OPERATOR>

                <COMMENT>// Check for the unlatch character</COMMENT>
                <KEYWORD>if</KEYWORD> (edifactValue <OPERATOR>==</OPERATOR> <NUMERIC>0x2B67</NUMERIC>) {  <COMMENT>// 011111</COMMENT>
                  unlatch <OPERATOR>=</OPERATOR> <KEYWORD>true</KEYWORD><OPERATOR>;</OPERATOR>
                  <COMMENT>// If we encounter the unlatch code then continue reading because the Codeword triple</COMMENT>
                  <COMMENT>// is padded with 0's</COMMENT>
                }
                
                <KEYWORD>if</KEYWORD> (<OPERATOR>!</OPERATOR>unlatch) {
                  <KEYWORD>if</KEYWORD> ((edifactValue <OPERATOR>&amp;</OPERATOR> <NUMERIC>32</NUMERIC>) <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC>) {  <COMMENT>// no 1 in the leading (6th) bit</COMMENT>
                    edifactValue <OPERATOR>|=</OPERATOR> <NUMERIC>64</NUMERIC><OPERATOR>;</OPERATOR>  <COMMENT>// Add a leading 01 to the 6 bit binary value</COMMENT>
                  }
                  <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(edifactValue)<OPERATOR>;</OPERATOR>
                }
              }
            } <KEYWORD>while</KEYWORD> (<OPERATOR>!</OPERATOR>unlatch <OPERATOR>&amp;&amp;</OPERATOR> <OBJ>bits</OBJ><OPERATOR>.</OPERATOR><OO>available</OO>() <OPERATOR>&gt;</OPERATOR> <NUMERIC>0</NUMERIC>)<OPERATOR>;</OPERATOR>
          }
          
          <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>           * See ISO 16022:2006, 5.2.9 and Annex B, B.2</DOCCOMMENT>
<DOCCOMMENT>           */</DOCCOMMENT>
          <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>function</KEYWORD> decodeBase256Segment(bits<OPERATOR>:</OPERATOR>BitSource<OPERATOR>,</OPERATOR> result<OPERATOR>:</OPERATOR>StringBuilder <OPERATOR>,</OPERATOR> byteSegments<OPERATOR>:</OPERATOR>ArrayList )<OPERATOR>:</OPERATOR><KEYWORD>void</KEYWORD> {
            <COMMENT>// Figure out how long the Base 256 Segment is.</COMMENT>
            <KEYWORD>var</KEYWORD> d1<OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> <OBJ>bits</OBJ><OPERATOR>.</OPERATOR><OO>readBits</OO>(<NUMERIC>8</NUMERIC>)<OPERATOR>;</OPERATOR>
            <KEYWORD>var</KEYWORD> count<OPERATOR>:</OPERATOR><TYPE>int</TYPE><OPERATOR>;</OPERATOR>
            <KEYWORD>if</KEYWORD> (d1 <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC>) {  <COMMENT>// Read the remainder of the symbol</COMMENT>
              count <OPERATOR>=</OPERATOR> <OBJ>bits</OBJ><OPERATOR>.</OPERATOR><OO>available</OO>() <OPERATOR>/</OPERATOR> <NUMERIC>8</NUMERIC><OPERATOR>;</OPERATOR>
            } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (d1 <OPERATOR>&lt;</OPERATOR> <NUMERIC>250</NUMERIC>) {
              count <OPERATOR>=</OPERATOR> d1<OPERATOR>;</OPERATOR>
            } <KEYWORD>else</KEYWORD> {
              count <OPERATOR>=</OPERATOR> <NUMERIC>250</NUMERIC> <OPERATOR>*</OPERATOR> (d1 <OPERATOR>-</OPERATOR> <NUMERIC>249</NUMERIC>) <OPERATOR>+</OPERATOR> <OBJ>bits</OBJ><OPERATOR>.</OPERATOR><OO>readBits</OO>(<NUMERIC>8</NUMERIC>)<OPERATOR>;</OPERATOR>
            }
            <KEYWORD>var</KEYWORD> bytes<OPERATOR>:</OPERATOR><TYPE>Array</TYPE> <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Array</TYPE>(count)<OPERATOR>;</OPERATOR>
            <KEYWORD>for</KEYWORD> (<KEYWORD>var</KEYWORD> i<OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR> i <OPERATOR>&lt;</OPERATOR> count<OPERATOR>;</OPERATOR> i<OPERATOR>++</OPERATOR>) 
            {
              bytes[i] <OPERATOR>=</OPERATOR> unrandomize255State(<OBJ>bits</OBJ><OPERATOR>.</OPERATOR><OO>readBits</OO>(<NUMERIC>8</NUMERIC>)<OPERATOR>,</OPERATOR> i)<OPERATOR>;</OPERATOR>
            }
            <OBJ>byteSegments</OBJ><OPERATOR>.</OPERATOR><OO>Add</OO>(bytes)<OPERATOR>;</OPERATOR>
            <KEYWORD>try</KEYWORD> 
            {
                <COMMENT>//result.Append(System.Text.Encoding.GetEncoding("iso-8859-1").GetString(bytes));</COMMENT>
                <KEYWORD>var</KEYWORD> str<OPERATOR>:</OPERATOR><TYPE>String</TYPE> <OPERATOR>=</OPERATOR> <STRING>""</STRING><OPERATOR>;</OPERATOR>
                <KEYWORD>for</KEYWORD>(<KEYWORD>var</KEYWORD> i2<OPERATOR>:</OPERATOR><TYPE>int</TYPE><OPERATOR>=</OPERATOR><NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>i2<OPERATOR>&lt;</OPERATOR><OBJ>bytes</OBJ><OPERATOR>.</OPERATOR><OO>length</OO><OPERATOR>;</OPERATOR>i2<OPERATOR>++</OPERATOR>)
                {
                        str <OPERATOR>=</OPERATOR> str <OPERATOR>+</OPERATOR> <OBJ>String</OBJ><OPERATOR>.</OPERATOR><OO>fromCharCode</OO>(bytes[i2])<OPERATOR>;</OPERATOR>
                }
                <OBJ>result</OBJ><OPERATOR>.</OPERATOR><OO>Append</OO>(str)<OPERATOR>;</OPERATOR>

                
            } <KEYWORD>catch</KEYWORD> (uee<OPERATOR>:</OPERATOR><TYPE>Error</TYPE> ) {
              <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> <TYPE>Error</TYPE>(<STRING>"Platform does not support required encoding: "</STRING> <OPERATOR>+</OPERATOR> uee)<OPERATOR>;</OPERATOR>
            }
          }
          
          <DOCCOMMENT>/**</DOCCOMMENT>
<DOCCOMMENT>           * See ISO 16022:2006, Annex B, B.2</DOCCOMMENT>
<DOCCOMMENT>           */</DOCCOMMENT>
          <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>function</KEYWORD> unrandomize255State(randomizedBase256Codeword<OPERATOR>:</OPERATOR><TYPE>int</TYPE><OPERATOR>,</OPERATOR>
                                                  base256CodewordPosition<OPERATOR>:</OPERATOR><TYPE>int</TYPE> )<OPERATOR>:</OPERATOR><TYPE>int</TYPE> {
            <KEYWORD>var</KEYWORD> pseudoRandomNumber<OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> ((<NUMERIC>149</NUMERIC> <OPERATOR>*</OPERATOR> base256CodewordPosition) <OPERATOR>%</OPERATOR> <NUMERIC>255</NUMERIC>) <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC><OPERATOR>;</OPERATOR>
            <KEYWORD>var</KEYWORD> tempVariable<OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> randomizedBase256Codeword <OPERATOR>-</OPERATOR> pseudoRandomNumber<OPERATOR>;</OPERATOR>
            <KEYWORD>var</KEYWORD> result<OPERATOR>:</OPERATOR><TYPE>int</TYPE> <OPERATOR>=</OPERATOR> (tempVariable <OPERATOR>&gt;=</OPERATOR> <NUMERIC>0</NUMERIC> <OPERATOR>?</OPERATOR> tempVariable <OPERATOR>:</OPERATOR> (tempVariable <OPERATOR>+</OPERATOR> <NUMERIC>256</NUMERIC>))<OPERATOR>;</OPERATOR> 
            <KEYWORD>return</KEYWORD> result<OPERATOR>;</OPERATOR> 
          }
    }

}
