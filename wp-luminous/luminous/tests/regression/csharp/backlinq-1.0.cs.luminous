<PREPROCESSOR>#region License, Terms and Author(s)</PREPROCESSOR>
<COMMENT>//</COMMENT>
<COMMENT>// BackLINQ</COMMENT>
<COMMENT>// Copyright (c) 2008 Atif Aziz. All rights reserved.</COMMENT>
<COMMENT>//</COMMENT>
<COMMENT>//  Author(s):</COMMENT>
<COMMENT>//</COMMENT>
<COMMENT>//      Atif Aziz, http://www.raboof.com</COMMENT>
<COMMENT>//</COMMENT>
<COMMENT>// New BSD License</COMMENT>
<COMMENT>//</COMMENT>
<COMMENT>// Redistribution and use in source and binary forms, with or without </COMMENT>
<COMMENT>// modification, are permitted provided that the following conditions </COMMENT>
<COMMENT>// are met:</COMMENT>
<COMMENT>//</COMMENT>
<COMMENT>// - Redistributions of source code must retain the above copyright </COMMENT>
<COMMENT>//   notice, this list of conditions and the following disclaimer. </COMMENT>
<COMMENT>//</COMMENT>
<COMMENT>// - Redistributions in binary form must reproduce the above copyright </COMMENT>
<COMMENT>//   notice, this list of conditions and the following disclaimer in </COMMENT>
<COMMENT>//   the documentation and/or other materials provided with the </COMMENT>
<COMMENT>//   distribution. </COMMENT>
<COMMENT>//</COMMENT>
<COMMENT>// - Neither the name of the original author (Atif Aziz) nor the names </COMMENT>
<COMMENT>//   of its contributors may be used to endorse or promote products </COMMENT>
<COMMENT>//   derived from this software without specific prior written </COMMENT>
<COMMENT>//   permission. </COMMENT>
<COMMENT>//</COMMENT>
<COMMENT>// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS </COMMENT>
<COMMENT>// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT </COMMENT>
<COMMENT>// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS </COMMENT>
<COMMENT>// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE </COMMENT>
<COMMENT>// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, </COMMENT>
<COMMENT>// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, </COMMENT>
<COMMENT>// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; </COMMENT>
<COMMENT>// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER </COMMENT>
<COMMENT>// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT </COMMENT>
<COMMENT>// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN </COMMENT>
<COMMENT>// ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE </COMMENT>
<COMMENT>// POSSIBILITY OF SUCH DAMAGE.</COMMENT>
<COMMENT>//</COMMENT>
<PREPROCESSOR>#endregion</PREPROCESSOR>

<COMMENT>// $Id: Enumerable.cs 214 2008-11-17 09:27:41Z azizatif $</COMMENT>

<KEYWORD>namespace</KEYWORD> <OBJ>System</OBJ><OPERATOR>.</OPERATOR><OO>Linq</OO>
{
    <PREPROCESSOR>#region Imports</PREPROCESSOR>

    <KEYWORD>using</KEYWORD> System<OPERATOR>;</OPERATOR>
    <KEYWORD>using</KEYWORD> <OBJ>System</OBJ><OPERATOR>.</OPERATOR><OO>Collections</OO><OPERATOR>;</OPERATOR>
    <KEYWORD>using</KEYWORD> <OBJ>System</OBJ><OPERATOR>.</OPERATOR><OO>Collections</OO><OPERATOR>.</OPERATOR><OO>Generic</OO><OPERATOR>;</OPERATOR>
    <KEYWORD>using</KEYWORD> <OBJ>System</OBJ><OPERATOR>.</OPERATOR><OO>Diagnostics</OO><OPERATOR>;</OPERATOR>
    <KEYWORD>using</KEYWORD> BackLinq<OPERATOR>;</OPERATOR>

    <PREPROCESSOR>#endregion</PREPROCESSOR>

    <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
    <DOCCOMMENT>/// Provides a set of static (Shared in Visual Basic) methods for </DOCCOMMENT>
    <DOCCOMMENT>/// querying objects that implement &lt;see cref="IEnumerable{T}" /&gt;.</DOCCOMMENT>
    <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

    <PREPROCESSOR>#region Access modifier</PREPROCESSOR>
    <PREPROCESSOR>#if BACKLINQ_LIB</PREPROCESSOR>
        <KEYWORD>public</KEYWORD> 
    <PREPROCESSOR>#else</PREPROCESSOR>
        <KEYWORD>internal</KEYWORD>
    <PREPROCESSOR>#endif</PREPROCESSOR>
    <PREPROCESSOR>#endregion</PREPROCESSOR>

    <KEYWORD>static</KEYWORD> partial <KEYWORD>class</KEYWORD> Enumerable
    {
        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the input typed as &lt;see cref="IEnumerable{T}"/&gt;.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> AsEnumerable<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(<TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source)
        {
            <KEYWORD>return</KEYWORD> source<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns an empty &lt;see cref="IEnumerable{T}"/&gt; that has the </DOCCOMMENT>
        <DOCCOMMENT>/// specified type argument.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR> Empty<OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR>()
        {
            <KEYWORD>return</KEYWORD> Sequence<OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;.</OPERATOR>Empty<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Converts the elements of an &lt;see cref="IEnumerable"/&gt; to the </DOCCOMMENT>
        <DOCCOMMENT>/// specified type.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR> Cast<OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> CastYield<OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR>(source)<OPERATOR>;</OPERATOR>
        }

        <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR> CastYield<OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR>(
            <TYPE>IEnumerable</TYPE> source)
        {
            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> item <KEYWORD>in</KEYWORD> source)
                <KEYWORD>yield</KEYWORD> <KEYWORD>return</KEYWORD> (TResult) item<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Filters the elements of an &lt;see cref="IEnumerable"/&gt; based on a specified type.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR> OfType<OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> OfTypeYield<OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR>(source)<OPERATOR>;</OPERATOR>
        }

        <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR> OfTypeYield<OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR>(
            <TYPE>IEnumerable</TYPE> source)
        {
            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> item <KEYWORD>in</KEYWORD> source)
                <KEYWORD>if</KEYWORD> (item <KEYWORD>is</KEYWORD> TResult)
                    <KEYWORD>yield</KEYWORD> <KEYWORD>return</KEYWORD> (TResult) item<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Generates a sequence of integral numbers within a specified range.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;param name="start"&gt;The value of the first integer in the sequence.&lt;/param&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;param name="count"&gt;The number of sequential integers to generate.&lt;/param&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>int</TYPE><OPERATOR>&gt;</OPERATOR> Range(<TYPE>int</TYPE> start<OPERATOR>,</OPERATOR> <TYPE>int</TYPE> count)
        {
            <KEYWORD>if</KEYWORD> (count <OPERATOR>&lt;</OPERATOR> <NUMERIC>0</NUMERIC>)
                <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> <TYPE>ArgumentOutOfRangeException</TYPE>(<STRING>"count"</STRING><OPERATOR>,</OPERATOR> count<OPERATOR>,</OPERATOR> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>

            <KEYWORD>var</KEYWORD> end <OPERATOR>=</OPERATOR> (<TYPE>long</TYPE>) start <OPERATOR>+</OPERATOR> count<OPERATOR>;</OPERATOR>
            <KEYWORD>if</KEYWORD> (end <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC> <OPERATOR>&gt;=</OPERATOR> <OBJ>int</OBJ><OPERATOR>.</OPERATOR><OO>MaxValue</OO>)
                <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> <TYPE>ArgumentOutOfRangeException</TYPE>(<STRING>"count"</STRING><OPERATOR>,</OPERATOR> count<OPERATOR>,</OPERATOR> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> RangeYield(start<OPERATOR>,</OPERATOR> end)<OPERATOR>;</OPERATOR>
        }

        <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>int</TYPE><OPERATOR>&gt;</OPERATOR> RangeYield(<TYPE>int</TYPE> start<OPERATOR>,</OPERATOR> <TYPE>long</TYPE> end)
        {
            <KEYWORD>for</KEYWORD> (<KEYWORD>var</KEYWORD> i <OPERATOR>=</OPERATOR> start<OPERATOR>;</OPERATOR> i <OPERATOR>&lt;</OPERATOR> end<OPERATOR>;</OPERATOR> i<OPERATOR>++</OPERATOR>)
                <KEYWORD>yield</KEYWORD> <KEYWORD>return</KEYWORD> i<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Generates a sequence that contains one repeated value.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR> Repeat<OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR>(TResult element<OPERATOR>,</OPERATOR> <TYPE>int</TYPE> count)
        {
            <KEYWORD>if</KEYWORD> (count <OPERATOR>&lt;</OPERATOR> <NUMERIC>0</NUMERIC>) <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> <TYPE>ArgumentOutOfRangeException</TYPE>(<STRING>"count"</STRING><OPERATOR>,</OPERATOR> count<OPERATOR>,</OPERATOR> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> RepeatYield(element<OPERATOR>,</OPERATOR> count)<OPERATOR>;</OPERATOR>
        }

        <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR> RepeatYield<OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR>(TResult element<OPERATOR>,</OPERATOR> <TYPE>int</TYPE> count)
        {
            <KEYWORD>for</KEYWORD> (<KEYWORD>var</KEYWORD> i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR> i <OPERATOR>&lt;</OPERATOR> count<OPERATOR>;</OPERATOR> i<OPERATOR>++</OPERATOR>)
                <KEYWORD>yield</KEYWORD> <KEYWORD>return</KEYWORD> element<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Filters a sequence of values based on a predicate.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> Where<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>bool</TYPE><OPERATOR>&gt;</OPERATOR> predicate)
        {
            CheckNotNull(predicate<OPERATOR>,</OPERATOR> <STRING>"predicate"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>((item<OPERATOR>,</OPERATOR> i) <OPERATOR>=&gt;</OPERATOR> predicate(item))<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Filters a sequence of values based on a predicate. </DOCCOMMENT>
        <DOCCOMMENT>/// Each element's index is used in the logic of the predicate function.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> Where<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>int</TYPE><OPERATOR>,</OPERATOR> <TYPE>bool</TYPE><OPERATOR>&gt;</OPERATOR> predicate)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(predicate<OPERATOR>,</OPERATOR> <STRING>"predicate"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> WhereYield(source<OPERATOR>,</OPERATOR> predicate)<OPERATOR>;</OPERATOR>
        }

        <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> WhereYield<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>int</TYPE><OPERATOR>,</OPERATOR> <TYPE>bool</TYPE><OPERATOR>&gt;</OPERATOR> predicate)
        {
            <KEYWORD>var</KEYWORD> i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> item <KEYWORD>in</KEYWORD> source)
                <KEYWORD>if</KEYWORD> (predicate(item<OPERATOR>,</OPERATOR> i<OPERATOR>++</OPERATOR>))
                    <KEYWORD>yield</KEYWORD> <KEYWORD>return</KEYWORD> item<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Projects each element of a sequence into a new form.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR> Select<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR> selector)
        {
            CheckNotNull(selector<OPERATOR>,</OPERATOR> <STRING>"selector"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>((item<OPERATOR>,</OPERATOR> i) <OPERATOR>=&gt;</OPERATOR> selector(item))<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Projects each element of a sequence into a new form by </DOCCOMMENT>
        <DOCCOMMENT>/// incorporating the element's index.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR> Select<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>int</TYPE><OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR> selector)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(selector<OPERATOR>,</OPERATOR> <STRING>"selector"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> SelectYield(source<OPERATOR>,</OPERATOR> selector)<OPERATOR>;</OPERATOR>
        }

        <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR> SelectYield<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR>(
            <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>int</TYPE><OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR> selector)
        {
            <KEYWORD>var</KEYWORD> i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> item <KEYWORD>in</KEYWORD> source)
                <KEYWORD>yield</KEYWORD> <KEYWORD>return</KEYWORD> selector(item<OPERATOR>,</OPERATOR> i<OPERATOR>++</OPERATOR>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Projects each element of a sequence to an &lt;see cref="IEnumerable{T}" /&gt; </DOCCOMMENT>
        <DOCCOMMENT>/// and flattens the resulting sequences into one sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR> SelectMany<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;&gt;</OPERATOR> selector)
        {
            CheckNotNull(selector<OPERATOR>,</OPERATOR> <STRING>"selector"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>SelectMany</OO>((item<OPERATOR>,</OPERATOR> i) <OPERATOR>=&gt;</OPERATOR> selector(item))<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Projects each element of a sequence to an &lt;see cref="IEnumerable{T}" /&gt;, </DOCCOMMENT>
        <DOCCOMMENT>/// and flattens the resulting sequences into one sequence. The </DOCCOMMENT>
        <DOCCOMMENT>/// index of each source element is used in the projected form of </DOCCOMMENT>
        <DOCCOMMENT>/// that element.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR> SelectMany<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>int</TYPE><OPERATOR>,</OPERATOR> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;&gt;</OPERATOR> selector)
        {
            CheckNotNull(selector<OPERATOR>,</OPERATOR> <STRING>"selector"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>SelectMany</OO>(selector<OPERATOR>,</OPERATOR> (item<OPERATOR>,</OPERATOR> subitem) <OPERATOR>=&gt;</OPERATOR> subitem)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Projects each element of a sequence to an &lt;see cref="IEnumerable{T}" /&gt;, </DOCCOMMENT>
        <DOCCOMMENT>/// flattens the resulting sequences into one sequence, and invokes </DOCCOMMENT>
        <DOCCOMMENT>/// a result selector function on each element therein.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR> SelectMany<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TCollection<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TCollection<OPERATOR>&gt;&gt;</OPERATOR> collectionSelector<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TCollection<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR> resultSelector)
        {
            CheckNotNull(collectionSelector<OPERATOR>,</OPERATOR> <STRING>"collectionSelector"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>SelectMany</OO>((item<OPERATOR>,</OPERATOR> i) <OPERATOR>=&gt;</OPERATOR> collectionSelector(item)<OPERATOR>,</OPERATOR> resultSelector)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Projects each element of a sequence to an &lt;see cref="IEnumerable{T}" /&gt;, </DOCCOMMENT>
        <DOCCOMMENT>/// flattens the resulting sequences into one sequence, and invokes </DOCCOMMENT>
        <DOCCOMMENT>/// a result selector function on each element therein. The index of </DOCCOMMENT>
        <DOCCOMMENT>/// each source element is used in the intermediate projected form </DOCCOMMENT>
        <DOCCOMMENT>/// of that element.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR> SelectMany<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TCollection<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>int</TYPE><OPERATOR>,</OPERATOR> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TCollection<OPERATOR>&gt;&gt;</OPERATOR> collectionSelector<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TCollection<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR> resultSelector)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(collectionSelector<OPERATOR>,</OPERATOR> <STRING>"collectionSelector"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(resultSelector<OPERATOR>,</OPERATOR> <STRING>"resultSelector"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> SelectManyYield(source<OPERATOR>,</OPERATOR> collectionSelector<OPERATOR>,</OPERATOR> resultSelector)<OPERATOR>;</OPERATOR>
        }

        <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR> SelectManyYield<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TCollection<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>int</TYPE><OPERATOR>,</OPERATOR> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TCollection<OPERATOR>&gt;&gt;</OPERATOR> collectionSelector<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TCollection<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR> resultSelector)
        {
            <KEYWORD>var</KEYWORD> i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> item <KEYWORD>in</KEYWORD> source)
                <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> subitem <KEYWORD>in</KEYWORD> collectionSelector(item<OPERATOR>,</OPERATOR> i<OPERATOR>++</OPERATOR>))
                    <KEYWORD>yield</KEYWORD> <KEYWORD>return</KEYWORD> resultSelector(item<OPERATOR>,</OPERATOR> subitem)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns elements from a sequence as long as a specified condition is true.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> TakeWhile<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>bool</TYPE><OPERATOR>&gt;</OPERATOR> predicate)
        {
            CheckNotNull(predicate<OPERATOR>,</OPERATOR> <STRING>"predicate"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>TakeWhile</OO>((item<OPERATOR>,</OPERATOR> i) <OPERATOR>=&gt;</OPERATOR> predicate(item))<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns elements from a sequence as long as a specified condition is true.</DOCCOMMENT>
        <DOCCOMMENT>/// The element's index is used in the logic of the predicate function.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> TakeWhile<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>int</TYPE><OPERATOR>,</OPERATOR> <TYPE>bool</TYPE><OPERATOR>&gt;</OPERATOR> predicate)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(predicate<OPERATOR>,</OPERATOR> <STRING>"predicate"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> TakeWhileYield(source<OPERATOR>,</OPERATOR> predicate)<OPERATOR>;</OPERATOR>
        }

        <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> TakeWhileYield<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>int</TYPE><OPERATOR>,</OPERATOR> <TYPE>bool</TYPE><OPERATOR>&gt;</OPERATOR> predicate)
        {
            <KEYWORD>var</KEYWORD> i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> item <KEYWORD>in</KEYWORD> source)
                <KEYWORD>if</KEYWORD> (predicate(item<OPERATOR>,</OPERATOR> i<OPERATOR>++</OPERATOR>))
                    <KEYWORD>yield</KEYWORD> <KEYWORD>return</KEYWORD> item<OPERATOR>;</OPERATOR>
                <KEYWORD>else</KEYWORD>
                    <KEYWORD>break</KEYWORD><OPERATOR>;</OPERATOR>
        }

        <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>class</KEYWORD> Futures<OPERATOR>&lt;</OPERATOR>T<OPERATOR>&gt;</OPERATOR>
        {
            <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>readonly</KEYWORD> Func<OPERATOR>&lt;</OPERATOR>T<OPERATOR>&gt;</OPERATOR> Default <OPERATOR>=</OPERATOR> () <OPERATOR>=&gt;</OPERATOR> <KEYWORD>default</KEYWORD>(T)<OPERATOR>;</OPERATOR>
            <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>readonly</KEYWORD> Func<OPERATOR>&lt;</OPERATOR>T<OPERATOR>&gt;</OPERATOR> Undefined <OPERATOR>=</OPERATOR> () <OPERATOR>=&gt;</OPERATOR> { <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> <TYPE>InvalidOperationException</TYPE>()<OPERATOR>;</OPERATOR> }<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Base implementation of First operator.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>
        
        <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> TSource FirstImpl<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> empty)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            <OBJ>Debug</OBJ><OPERATOR>.</OPERATOR><OO>Assert</OO>(empty <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>

            <KEYWORD>var</KEYWORD> list <OPERATOR>=</OPERATOR> source <KEYWORD>as</KEYWORD> <TYPE>IList</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;;</OPERATOR>    <COMMENT>// optimized case for lists</COMMENT>
            <KEYWORD>if</KEYWORD> (list <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>)
                <KEYWORD>return</KEYWORD> <OBJ>list</OBJ><OPERATOR>.</OPERATOR><OO>Count</OO> <OPERATOR>&gt;</OPERATOR> <NUMERIC>0</NUMERIC> <OPERATOR>?</OPERATOR> list[<NUMERIC>0</NUMERIC>] <OPERATOR>:</OPERATOR> empty()<OPERATOR>;</OPERATOR>

            <KEYWORD>using</KEYWORD> (<KEYWORD>var</KEYWORD> e <OPERATOR>=</OPERATOR> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>GetEnumerator</OO>())  <COMMENT>// fallback for enumeration</COMMENT>
                <KEYWORD>return</KEYWORD> e<OPERATOR>.</OPERATOR><OO>MoveNext</OO>() <OPERATOR>?</OPERATOR> e<OPERATOR>.</OPERATOR><OO>Current</OO> <OPERATOR>:</OPERATOR> empty()<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the first element of a sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> TSource First<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>FirstImpl</OO>(Futures<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;.</OPERATOR>Undefined)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the first element in a sequence that satisfies a specified condition.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> TSource First<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>bool</TYPE><OPERATOR>&gt;</OPERATOR> predicate)
        {
            <KEYWORD>return</KEYWORD> First(<OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(predicate))<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the first element of a sequence, or a default value if </DOCCOMMENT>
        <DOCCOMMENT>/// the sequence contains no elements.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> TSource FirstOrDefault<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>FirstImpl</OO>(Futures<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;.</OPERATOR>Default)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the first element of the sequence that satisfies a </DOCCOMMENT>
        <DOCCOMMENT>/// condition or a default value if no such element is found.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> TSource FirstOrDefault<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>bool</TYPE><OPERATOR>&gt;</OPERATOR> predicate)
        {
            <KEYWORD>return</KEYWORD> FirstOrDefault(<OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(predicate))<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Base implementation of Last operator.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> TSource LastImpl<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> empty)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>var</KEYWORD> list <OPERATOR>=</OPERATOR> source <KEYWORD>as</KEYWORD> <TYPE>IList</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;;</OPERATOR>    <COMMENT>// optimized case for lists</COMMENT>
            <KEYWORD>if</KEYWORD> (list <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>)
                <KEYWORD>return</KEYWORD> <OBJ>list</OBJ><OPERATOR>.</OPERATOR><OO>Count</OO> <OPERATOR>&gt;</OPERATOR> <NUMERIC>0</NUMERIC> <OPERATOR>?</OPERATOR> list[<OBJ>list</OBJ><OPERATOR>.</OPERATOR><OO>Count</OO> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>] <OPERATOR>:</OPERATOR> empty()<OPERATOR>;</OPERATOR>

            <KEYWORD>using</KEYWORD> (<KEYWORD>var</KEYWORD> e <OPERATOR>=</OPERATOR> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>GetEnumerator</OO>())
            {
                <KEYWORD>if</KEYWORD> (<OPERATOR>!</OPERATOR>e<OPERATOR>.</OPERATOR><OO>MoveNext</OO>())
                    <KEYWORD>return</KEYWORD> empty()<OPERATOR>;</OPERATOR>

                <KEYWORD>var</KEYWORD> last <OPERATOR>=</OPERATOR> e<OPERATOR>.</OPERATOR><OO>Current</OO><OPERATOR>;</OPERATOR>
                <KEYWORD>while</KEYWORD> (e<OPERATOR>.</OPERATOR><OO>MoveNext</OO>())
                    last <OPERATOR>=</OPERATOR> e<OPERATOR>.</OPERATOR><OO>Current</OO><OPERATOR>;</OPERATOR>

                <KEYWORD>return</KEYWORD> last<OPERATOR>;</OPERATOR>
            }
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the last element of a sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>
        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> TSource Last<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>LastImpl</OO>(Futures<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;.</OPERATOR>Undefined)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the last element of a sequence that satisfies a </DOCCOMMENT>
        <DOCCOMMENT>/// specified condition.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> TSource Last<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>bool</TYPE><OPERATOR>&gt;</OPERATOR> predicate)
        {
            <KEYWORD>return</KEYWORD> Last(<OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(predicate))<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the last element of a sequence, or a default value if </DOCCOMMENT>
        <DOCCOMMENT>/// the sequence contains no elements.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> TSource LastOrDefault<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>LastImpl</OO>(Futures<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;.</OPERATOR>Default)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the last element of a sequence that satisfies a </DOCCOMMENT>
        <DOCCOMMENT>/// condition or a default value if no such element is found.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> TSource LastOrDefault<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>bool</TYPE><OPERATOR>&gt;</OPERATOR> predicate)
        {
            <KEYWORD>return</KEYWORD> LastOrDefault(<OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(predicate))<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Base implementation of Single operator.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>
        
        <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> TSource SingleImpl<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> empty)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>using</KEYWORD> (<KEYWORD>var</KEYWORD> e <OPERATOR>=</OPERATOR> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>GetEnumerator</OO>())
            {
                <KEYWORD>if</KEYWORD> (e<OPERATOR>.</OPERATOR><OO>MoveNext</OO>())
                {
                    <KEYWORD>var</KEYWORD> single <OPERATOR>=</OPERATOR> e<OPERATOR>.</OPERATOR><OO>Current</OO><OPERATOR>;</OPERATOR>
                    <KEYWORD>if</KEYWORD> (<OPERATOR>!</OPERATOR>e<OPERATOR>.</OPERATOR><OO>MoveNext</OO>())
                        <KEYWORD>return</KEYWORD> single<OPERATOR>;</OPERATOR>

                    <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> <TYPE>InvalidOperationException</TYPE>()<OPERATOR>;</OPERATOR>
                }

                <KEYWORD>return</KEYWORD> empty()<OPERATOR>;</OPERATOR>
            }
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the only element of a sequence, and throws an exception </DOCCOMMENT>
        <DOCCOMMENT>/// if there is not exactly one element in the sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> TSource <TYPE>Single</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>SingleImpl</OO>(Futures<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;.</OPERATOR>Undefined)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the only element of a sequence that satisfies a </DOCCOMMENT>
        <DOCCOMMENT>/// specified condition, and throws an exception if more than one </DOCCOMMENT>
        <DOCCOMMENT>/// such element exists.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> TSource <TYPE>Single</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>bool</TYPE><OPERATOR>&gt;</OPERATOR> predicate)
        {
            <KEYWORD>return</KEYWORD> <TYPE>Single</TYPE>(<OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(predicate))<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the only element of a sequence, or a default value if </DOCCOMMENT>
        <DOCCOMMENT>/// the sequence is empty; this method throws an exception if there </DOCCOMMENT>
        <DOCCOMMENT>/// is more than one element in the sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> TSource SingleOrDefault<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>SingleImpl</OO>(Futures<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;.</OPERATOR>Default)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the only element of a sequence that satisfies a </DOCCOMMENT>
        <DOCCOMMENT>/// specified condition or a default value if no such element </DOCCOMMENT>
        <DOCCOMMENT>/// exists; this method throws an exception if more than one element </DOCCOMMENT>
        <DOCCOMMENT>/// satisfies the condition.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> TSource SingleOrDefault<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>bool</TYPE><OPERATOR>&gt;</OPERATOR> predicate)
        {
            <KEYWORD>return</KEYWORD> SingleOrDefault(<OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(predicate))<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the element at a specified index in a sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> TSource ElementAt<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            <TYPE>int</TYPE> index)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>if</KEYWORD> (index <OPERATOR>&lt;</OPERATOR> <NUMERIC>0</NUMERIC>)
                <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> <TYPE>ArgumentOutOfRangeException</TYPE>(<STRING>"index"</STRING><OPERATOR>,</OPERATOR> index<OPERATOR>,</OPERATOR> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>

            <KEYWORD>var</KEYWORD> list <OPERATOR>=</OPERATOR> source <KEYWORD>as</KEYWORD> <TYPE>IList</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;;</OPERATOR>
            <KEYWORD>if</KEYWORD> (list <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>)
                <KEYWORD>return</KEYWORD> list[index]<OPERATOR>;</OPERATOR>

            <KEYWORD>try</KEYWORD>
            {
                <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>SkipWhile</OO>((item<OPERATOR>,</OPERATOR> i) <OPERATOR>=&gt;</OPERATOR> i <OPERATOR>&lt;</OPERATOR> index)<OPERATOR>.</OPERATOR><OO>First</OO>()<OPERATOR>;</OPERATOR>
            }
            <KEYWORD>catch</KEYWORD> (<TYPE>InvalidOperationException</TYPE>) <COMMENT>// if thrown by First</COMMENT>
            {
                <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> <TYPE>ArgumentOutOfRangeException</TYPE>(<STRING>"index"</STRING><OPERATOR>,</OPERATOR> index<OPERATOR>,</OPERATOR> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>
            }
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the element at a specified index in a sequence or a </DOCCOMMENT>
        <DOCCOMMENT>/// default value if the index is out of range.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> TSource ElementAtOrDefault<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            <TYPE>int</TYPE> index)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>if</KEYWORD> (index <OPERATOR>&lt;</OPERATOR> <NUMERIC>0</NUMERIC>)
                <KEYWORD>return</KEYWORD> <KEYWORD>default</KEYWORD>(TSource)<OPERATOR>;</OPERATOR>

            <KEYWORD>var</KEYWORD> list <OPERATOR>=</OPERATOR> source <KEYWORD>as</KEYWORD> <TYPE>IList</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;;</OPERATOR>
            <KEYWORD>if</KEYWORD> (list <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>)
                <KEYWORD>return</KEYWORD> index <OPERATOR>&lt;</OPERATOR> <OBJ>list</OBJ><OPERATOR>.</OPERATOR><OO>Count</OO> <OPERATOR>?</OPERATOR> list[index] <OPERATOR>:</OPERATOR> <KEYWORD>default</KEYWORD>(TSource)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>SkipWhile</OO>((item<OPERATOR>,</OPERATOR> i) <OPERATOR>=&gt;</OPERATOR> i <OPERATOR>&lt;</OPERATOR> index)<OPERATOR>.</OPERATOR><OO>FirstOrDefault</OO>()<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Inverts the order of the elements in a sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>
 
        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> Reverse<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> ReverseYield(source)<OPERATOR>;</OPERATOR>
        }

        <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> ReverseYield<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(<TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source)
        {
            <KEYWORD>var</KEYWORD> stack <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Stack</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>()<OPERATOR>;</OPERATOR>
            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> item <KEYWORD>in</KEYWORD> source)
                <OBJ>stack</OBJ><OPERATOR>.</OPERATOR><OO>Push</OO>(item)<OPERATOR>;</OPERATOR>

            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> item <KEYWORD>in</KEYWORD> stack)
                <KEYWORD>yield</KEYWORD> <KEYWORD>return</KEYWORD> item<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns a specified number of contiguous elements from the start </DOCCOMMENT>
        <DOCCOMMENT>/// of a sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> Take<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            <TYPE>int</TYPE> count)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>((item<OPERATOR>,</OPERATOR> i) <OPERATOR>=&gt;</OPERATOR> i <OPERATOR>&lt;</OPERATOR> count)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Bypasses a specified number of elements in a sequence and then </DOCCOMMENT>
        <DOCCOMMENT>/// returns the remaining elements.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> Skip<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            <TYPE>int</TYPE> count)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>((item<OPERATOR>,</OPERATOR> i) <OPERATOR>=&gt;</OPERATOR> i <OPERATOR>&gt;=</OPERATOR> count)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Bypasses elements in a sequence as long as a specified condition </DOCCOMMENT>
        <DOCCOMMENT>/// is true and then returns the remaining elements.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> SkipWhile<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>bool</TYPE><OPERATOR>&gt;</OPERATOR> predicate)
        {
            CheckNotNull(predicate<OPERATOR>,</OPERATOR> <STRING>"predicate"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>SkipWhile</OO>((item<OPERATOR>,</OPERATOR> i) <OPERATOR>=&gt;</OPERATOR> predicate(item))<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Bypasses elements in a sequence as long as a specified condition </DOCCOMMENT>
        <DOCCOMMENT>/// is true and then returns the remaining elements. The element's </DOCCOMMENT>
        <DOCCOMMENT>/// index is used in the logic of the predicate function.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> SkipWhile<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>int</TYPE><OPERATOR>,</OPERATOR> <TYPE>bool</TYPE><OPERATOR>&gt;</OPERATOR> predicate)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(predicate<OPERATOR>,</OPERATOR> <STRING>"predicate"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> SkipWhileYield(source<OPERATOR>,</OPERATOR> predicate)<OPERATOR>;</OPERATOR>
        }

        <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> SkipWhileYield<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>int</TYPE><OPERATOR>,</OPERATOR> <TYPE>bool</TYPE><OPERATOR>&gt;</OPERATOR> predicate)
        {
            <KEYWORD>using</KEYWORD> (<KEYWORD>var</KEYWORD> e <OPERATOR>=</OPERATOR> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>GetEnumerator</OO>())
            {
                <KEYWORD>for</KEYWORD> (<KEYWORD>var</KEYWORD> i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR> <OPERATOR>;</OPERATOR> i<OPERATOR>++</OPERATOR>) 
                { 
                    <KEYWORD>if</KEYWORD> (<OPERATOR>!</OPERATOR>e<OPERATOR>.</OPERATOR><OO>MoveNext</OO>())
                        <KEYWORD>yield</KEYWORD> <KEYWORD>break</KEYWORD><OPERATOR>;</OPERATOR>
                    
                    <KEYWORD>if</KEYWORD> (<OPERATOR>!</OPERATOR>predicate(e<OPERATOR>.</OPERATOR><OO>Current</OO><OPERATOR>,</OPERATOR> i))
                        <KEYWORD>break</KEYWORD><OPERATOR>;</OPERATOR>
                }

                <KEYWORD>do</KEYWORD> { <KEYWORD>yield</KEYWORD> <KEYWORD>return</KEYWORD> e<OPERATOR>.</OPERATOR><OO>Current</OO><OPERATOR>;</OPERATOR> } <KEYWORD>while</KEYWORD> (e<OPERATOR>.</OPERATOR><OO>MoveNext</OO>())<OPERATOR>;</OPERATOR>
            }
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the number of elements in a sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>int</TYPE> Count<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>var</KEYWORD> collection <OPERATOR>=</OPERATOR> source <KEYWORD>as</KEYWORD> <TYPE>ICollection</TYPE><OPERATOR>;</OPERATOR>
            <KEYWORD>return</KEYWORD> collection <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD> 
                 <OPERATOR>?</OPERATOR> <OBJ>collection</OBJ><OPERATOR>.</OPERATOR><OO>Count</OO> 
                 <OPERATOR>:</OPERATOR> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Aggregate</OO>(<NUMERIC>0</NUMERIC><OPERATOR>,</OPERATOR> (count<OPERATOR>,</OPERATOR> item) <OPERATOR>=&gt;</OPERATOR> <KEYWORD>checked</KEYWORD>(count <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>))<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns a number that represents how many elements in the </DOCCOMMENT>
        <DOCCOMMENT>/// specified sequence satisfy a condition.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>int</TYPE> Count<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>bool</TYPE><OPERATOR>&gt;</OPERATOR> predicate)
        {
            <KEYWORD>return</KEYWORD> Count(<OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(predicate))<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns an &lt;see cref="Int64"/&gt; that represents the total number </DOCCOMMENT>
        <DOCCOMMENT>/// of elements in a sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>long</TYPE> LongCount<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>var</KEYWORD> array <OPERATOR>=</OPERATOR> source <KEYWORD>as</KEYWORD> <TYPE>Array</TYPE><OPERATOR>;</OPERATOR>
            <KEYWORD>return</KEYWORD> array <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD> 
                 <OPERATOR>?</OPERATOR> <OBJ>array</OBJ><OPERATOR>.</OPERATOR><OO>LongLength</OO> 
                 <OPERATOR>:</OPERATOR> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Aggregate</OO>(<NUMERIC>0</NUMERIC>L<OPERATOR>,</OPERATOR> (count<OPERATOR>,</OPERATOR> item) <OPERATOR>=&gt;</OPERATOR> count <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns an &lt;see cref="Int64"/&gt; that represents how many elements </DOCCOMMENT>
        <DOCCOMMENT>/// in a sequence satisfy a condition.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>long</TYPE> LongCount<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>bool</TYPE><OPERATOR>&gt;</OPERATOR> predicate)
        {
            <KEYWORD>return</KEYWORD> LongCount(<OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(predicate))<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Concatenates two sequences.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> Concat<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> first<OPERATOR>,</OPERATOR>
            <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> second)
        {
            CheckNotNull(first<OPERATOR>,</OPERATOR> <STRING>"first"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(second<OPERATOR>,</OPERATOR> <STRING>"second"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> ConcatYield(first<OPERATOR>,</OPERATOR> second)<OPERATOR>;</OPERATOR>
        }

        <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> ConcatYield<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> first<OPERATOR>,</OPERATOR> 
            <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> second)
        {
            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> item <KEYWORD>in</KEYWORD> first)
                <KEYWORD>yield</KEYWORD> <KEYWORD>return</KEYWORD> item<OPERATOR>;</OPERATOR>

            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> item <KEYWORD>in</KEYWORD> second)
                <KEYWORD>yield</KEYWORD> <KEYWORD>return</KEYWORD> item<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Creates a &lt;see cref="List{T}"/&gt; from an &lt;see cref="IEnumerable{T}"/&gt;.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>List</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> ToList<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> <KEYWORD>new</KEYWORD> <TYPE>List</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(source)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Creates an array from an &lt;see cref="IEnumerable{T}"/&gt;.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> TSource[] ToArray<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>ToList</OO>()<OPERATOR>.</OPERATOR><OO>ToArray</OO>()<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns distinct elements from a sequence by using the default </DOCCOMMENT>
        <DOCCOMMENT>/// equality comparer to compare values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> Distinct<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source)
        {
            <KEYWORD>return</KEYWORD> Distinct(source<OPERATOR>,</OPERATOR> <COMMENT>/* comparer */</COMMENT> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns distinct elements from a sequence by using a specified </DOCCOMMENT>
        <DOCCOMMENT>/// &lt;see cref="IEqualityComparer{T}"/&gt; to compare values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> Distinct<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            <TYPE>IEqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> comparer)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> DistinctYield(source<OPERATOR>,</OPERATOR> comparer)<OPERATOR>;</OPERATOR>
        }

        <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> DistinctYield<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            <TYPE>IEqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> comparer)
        {
            <KEYWORD>var</KEYWORD> set <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Dictionary</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>object</TYPE><OPERATOR>&gt;</OPERATOR>(comparer)<OPERATOR>;</OPERATOR>

            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> item <KEYWORD>in</KEYWORD> source)
            {
                <KEYWORD>if</KEYWORD> (<OBJ>set</OBJ><OPERATOR>.</OPERATOR><OO>ContainsKey</OO>(item))
                    <KEYWORD>continue</KEYWORD><OPERATOR>;</OPERATOR>

                <OBJ>set</OBJ><OPERATOR>.</OPERATOR><OO>Add</OO>(item<OPERATOR>,</OPERATOR> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>
                <KEYWORD>yield</KEYWORD> <KEYWORD>return</KEYWORD> item<OPERATOR>;</OPERATOR>
            }
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Creates a &lt;see cref="Lookup{TKey,TElement}" /&gt; from an </DOCCOMMENT>
        <DOCCOMMENT>/// &lt;see cref="IEnumerable{T}" /&gt; according to a specified key </DOCCOMMENT>
        <DOCCOMMENT>/// selector function.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> Lookup<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TSource<OPERATOR>&gt;</OPERATOR> ToLookup<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector)
        {
            <KEYWORD>return</KEYWORD> ToLookup(source<OPERATOR>,</OPERATOR> keySelector<OPERATOR>,</OPERATOR> e <OPERATOR>=&gt;</OPERATOR> e<OPERATOR>,</OPERATOR> <COMMENT>/* comparer */</COMMENT> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Creates a &lt;see cref="Lookup{TKey,TElement}" /&gt; from an </DOCCOMMENT>
        <DOCCOMMENT>/// &lt;see cref="IEnumerable{T}" /&gt; according to a specified key </DOCCOMMENT>
        <DOCCOMMENT>/// selector function and a key comparer.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> Lookup<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TSource<OPERATOR>&gt;</OPERATOR> ToLookup<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector<OPERATOR>,</OPERATOR>
            <TYPE>IEqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>&gt;</OPERATOR> comparer)
        {
            <KEYWORD>return</KEYWORD> ToLookup(source<OPERATOR>,</OPERATOR> keySelector<OPERATOR>,</OPERATOR> e <OPERATOR>=&gt;</OPERATOR> e<OPERATOR>,</OPERATOR> comparer)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Creates a &lt;see cref="Lookup{TKey,TElement}" /&gt; from an </DOCCOMMENT>
        <DOCCOMMENT>/// &lt;see cref="IEnumerable{T}" /&gt; according to specified key </DOCCOMMENT>
        <DOCCOMMENT>/// and element selector functions.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> Lookup<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR> ToLookup<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR> elementSelector)
        {
            <KEYWORD>return</KEYWORD> ToLookup(source<OPERATOR>,</OPERATOR> keySelector<OPERATOR>,</OPERATOR> elementSelector<OPERATOR>,</OPERATOR> <COMMENT>/* comparer */</COMMENT> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Creates a &lt;see cref="Lookup{TKey,TElement}" /&gt; from an </DOCCOMMENT>
        <DOCCOMMENT>/// &lt;see cref="IEnumerable{T}" /&gt; according to a specified key </DOCCOMMENT>
        <DOCCOMMENT>/// selector function, a comparer and an element selector function.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> Lookup<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR> ToLookup<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR> elementSelector<OPERATOR>,</OPERATOR>
            <TYPE>IEqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>&gt;</OPERATOR> comparer)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(keySelector<OPERATOR>,</OPERATOR> <STRING>"keySelector"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(elementSelector<OPERATOR>,</OPERATOR> <STRING>"elementSelector"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>var</KEYWORD> lookup <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> Lookup<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR>(comparer)<OPERATOR>;</OPERATOR>
            
            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> item <KEYWORD>in</KEYWORD> source)
            {
                <KEYWORD>var</KEYWORD> key <OPERATOR>=</OPERATOR> keySelector(item)<OPERATOR>;</OPERATOR>

                <KEYWORD>var</KEYWORD> grouping <OPERATOR>=</OPERATOR> (Grouping<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR>) <OBJ>lookup</OBJ><OPERATOR>.</OPERATOR><OO>Find</OO>(key)<OPERATOR>;</OPERATOR>
                <KEYWORD>if</KEYWORD> (grouping <OPERATOR>==</OPERATOR> <KEYWORD>null</KEYWORD>)
                {
                    grouping <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> Grouping<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR>(key)<OPERATOR>;</OPERATOR>
                    <OBJ>lookup</OBJ><OPERATOR>.</OPERATOR><OO>Add</OO>(grouping)<OPERATOR>;</OPERATOR>
                }

                <OBJ>grouping</OBJ><OPERATOR>.</OPERATOR><OO>Add</OO>(elementSelector(item))<OPERATOR>;</OPERATOR>
            }

            <KEYWORD>return</KEYWORD> lookup<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Groups the elements of a sequence according to a specified key </DOCCOMMENT>
        <DOCCOMMENT>/// selector function.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>IGrouping<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TSource<OPERATOR>&gt;&gt;</OPERATOR> GroupBy<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector)
        {
            <KEYWORD>return</KEYWORD> GroupBy(source<OPERATOR>,</OPERATOR> keySelector<OPERATOR>,</OPERATOR> <COMMENT>/* comparer */</COMMENT> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Groups the elements of a sequence according to a specified key </DOCCOMMENT>
        <DOCCOMMENT>/// selector function and compares the keys by using a specified </DOCCOMMENT>
        <DOCCOMMENT>/// comparer.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>IGrouping<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TSource<OPERATOR>&gt;&gt;</OPERATOR> GroupBy<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector<OPERATOR>,</OPERATOR>
            <TYPE>IEqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>&gt;</OPERATOR> comparer)
        {
            <KEYWORD>return</KEYWORD> GroupBy(source<OPERATOR>,</OPERATOR> keySelector<OPERATOR>,</OPERATOR> e <OPERATOR>=&gt;</OPERATOR> e<OPERATOR>,</OPERATOR> comparer)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Groups the elements of a sequence according to a specified key </DOCCOMMENT>
        <DOCCOMMENT>/// selector function and projects the elements for each group by </DOCCOMMENT>
        <DOCCOMMENT>/// using a specified function.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>IGrouping<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;&gt;</OPERATOR> GroupBy<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR> elementSelector)
        {
            <KEYWORD>return</KEYWORD> GroupBy(source<OPERATOR>,</OPERATOR> keySelector<OPERATOR>,</OPERATOR> elementSelector<OPERATOR>,</OPERATOR> <COMMENT>/* comparer */</COMMENT> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Groups the elements of a sequence according to a specified key </DOCCOMMENT>
        <DOCCOMMENT>/// selector function and creates a result value from each group and </DOCCOMMENT>
        <DOCCOMMENT>/// its key.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>IGrouping<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;&gt;</OPERATOR> GroupBy<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR> elementSelector<OPERATOR>,</OPERATOR>
            <TYPE>IEqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>&gt;</OPERATOR> comparer)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(keySelector<OPERATOR>,</OPERATOR> <STRING>"keySelector"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(elementSelector<OPERATOR>,</OPERATOR> <STRING>"elementSelector"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> ToLookup(source<OPERATOR>,</OPERATOR> keySelector<OPERATOR>,</OPERATOR> elementSelector<OPERATOR>,</OPERATOR> comparer)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Groups the elements of a sequence according to a key selector </DOCCOMMENT>
        <DOCCOMMENT>/// function. The keys are compared by using a comparer and each </DOCCOMMENT>
        <DOCCOMMENT>/// group's elements are projected by using a specified function.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR> GroupBy<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR> resultSelector)
        {
            <KEYWORD>return</KEYWORD> GroupBy(source<OPERATOR>,</OPERATOR> keySelector<OPERATOR>,</OPERATOR> resultSelector<OPERATOR>,</OPERATOR> <COMMENT>/* comparer */</COMMENT> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Groups the elements of a sequence according to a specified key </DOCCOMMENT>
        <DOCCOMMENT>/// selector function and creates a result value from each group and </DOCCOMMENT>
        <DOCCOMMENT>/// its key. The elements of each group are projected by using a </DOCCOMMENT>
        <DOCCOMMENT>/// specified function.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR> GroupBy<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR> resultSelector<OPERATOR>,</OPERATOR>
            <TYPE>IEqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>&gt;</OPERATOR> comparer)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(keySelector<OPERATOR>,</OPERATOR> <STRING>"keySelector"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(resultSelector<OPERATOR>,</OPERATOR> <STRING>"resultSelector"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> ToLookup(source<OPERATOR>,</OPERATOR> keySelector<OPERATOR>,</OPERATOR> comparer)<OPERATOR>.</OPERATOR><OO>Select</OO>(g <OPERATOR>=&gt;</OPERATOR> resultSelector(g<OPERATOR>.</OPERATOR><OO>Key</OO><OPERATOR>,</OPERATOR> g))<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Groups the elements of a sequence according to a specified key </DOCCOMMENT>
        <DOCCOMMENT>/// selector function and creates a result value from each group and </DOCCOMMENT>
        <DOCCOMMENT>/// its key. The keys are compared by using a specified comparer.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR> GroupBy<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR> elementSelector<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TElement<OPERATOR>&gt;,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR> resultSelector)
        {
            <KEYWORD>return</KEYWORD> GroupBy(source<OPERATOR>,</OPERATOR> keySelector<OPERATOR>,</OPERATOR> elementSelector<OPERATOR>,</OPERATOR> resultSelector<OPERATOR>,</OPERATOR> <COMMENT>/* comparer */</COMMENT> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Groups the elements of a sequence according to a specified key </DOCCOMMENT>
        <DOCCOMMENT>/// selector function and creates a result value from each group and </DOCCOMMENT>
        <DOCCOMMENT>/// its key. Key values are compared by using a specified comparer, </DOCCOMMENT>
        <DOCCOMMENT>/// and the elements of each group are projected by using a </DOCCOMMENT>
        <DOCCOMMENT>/// specified function.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR> GroupBy<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR> elementSelector<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TElement<OPERATOR>&gt;,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR> resultSelector<OPERATOR>,</OPERATOR>
            <TYPE>IEqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>&gt;</OPERATOR> comparer)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(keySelector<OPERATOR>,</OPERATOR> <STRING>"keySelector"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(elementSelector<OPERATOR>,</OPERATOR> <STRING>"elementSelector"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(resultSelector<OPERATOR>,</OPERATOR> <STRING>"resultSelector"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> ToLookup(source<OPERATOR>,</OPERATOR> keySelector<OPERATOR>,</OPERATOR> elementSelector<OPERATOR>,</OPERATOR> comparer)
                   <OPERATOR>.</OPERATOR><OO>Select</OO>(g <OPERATOR>=&gt;</OPERATOR> resultSelector(g<OPERATOR>.</OPERATOR><OO>Key</OO><OPERATOR>,</OPERATOR> g))<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Applies an accumulator function over a sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> TSource Aggregate<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TSource<OPERATOR>,</OPERATOR> TSource<OPERATOR>&gt;</OPERATOR> func)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(func<OPERATOR>,</OPERATOR> <STRING>"func"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>using</KEYWORD> (<KEYWORD>var</KEYWORD> e <OPERATOR>=</OPERATOR> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>GetEnumerator</OO>())
            {
                <KEYWORD>if</KEYWORD> (<OPERATOR>!</OPERATOR>e<OPERATOR>.</OPERATOR><OO>MoveNext</OO>())
                    <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> <TYPE>InvalidOperationException</TYPE>()<OPERATOR>;</OPERATOR>

                <KEYWORD>return</KEYWORD> e<OPERATOR>.</OPERATOR><OO>Renumerable</OO>()<OPERATOR>.</OPERATOR><OO>Skip</OO>(<NUMERIC>1</NUMERIC>)<OPERATOR>.</OPERATOR><OO>Aggregate</OO>(e<OPERATOR>.</OPERATOR><OO>Current</OO><OPERATOR>,</OPERATOR> func)<OPERATOR>;</OPERATOR>
            }
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Applies an accumulator function over a sequence. The specified </DOCCOMMENT>
        <DOCCOMMENT>/// seed value is used as the initial accumulator value.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> TAccumulate Aggregate<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TAccumulate<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            TAccumulate seed<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TAccumulate<OPERATOR>,</OPERATOR> TSource<OPERATOR>,</OPERATOR> TAccumulate<OPERATOR>&gt;</OPERATOR> func)
        {
            <KEYWORD>return</KEYWORD> Aggregate(source<OPERATOR>,</OPERATOR> seed<OPERATOR>,</OPERATOR> func<OPERATOR>,</OPERATOR> r <OPERATOR>=&gt;</OPERATOR> r)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Applies an accumulator function over a sequence. The specified </DOCCOMMENT>
        <DOCCOMMENT>/// seed value is used as the initial accumulator value, and the </DOCCOMMENT>
        <DOCCOMMENT>/// specified function is used to select the result value.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> TResult Aggregate<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TAccumulate<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            TAccumulate seed<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TAccumulate<OPERATOR>,</OPERATOR> TSource<OPERATOR>,</OPERATOR> TAccumulate<OPERATOR>&gt;</OPERATOR> func<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TAccumulate<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR> resultSelector)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(func<OPERATOR>,</OPERATOR> <STRING>"func"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(resultSelector<OPERATOR>,</OPERATOR> <STRING>"resultSelector"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>var</KEYWORD> result <OPERATOR>=</OPERATOR> seed<OPERATOR>;</OPERATOR>

            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> item <KEYWORD>in</KEYWORD> source)
                result <OPERATOR>=</OPERATOR> func(result<OPERATOR>,</OPERATOR> item)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> resultSelector(result)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Produces the set union of two sequences by using the default </DOCCOMMENT>
        <DOCCOMMENT>/// equality comparer.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> Union<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> first<OPERATOR>,</OPERATOR>
            <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> second)
        {
            <KEYWORD>return</KEYWORD> Union(first<OPERATOR>,</OPERATOR> second<OPERATOR>,</OPERATOR> <COMMENT>/* comparer */</COMMENT> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Produces the set union of two sequences by using a specified </DOCCOMMENT>
        <DOCCOMMENT>/// &lt;see cref="IEqualityComparer{T}" /&gt;.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> Union<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> first<OPERATOR>,</OPERATOR>
            <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> second<OPERATOR>,</OPERATOR>
            <TYPE>IEqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> comparer)
        {
            <KEYWORD>return</KEYWORD> <OBJ>first</OBJ><OPERATOR>.</OPERATOR><OO>Concat</OO>(second)<OPERATOR>.</OPERATOR><OO>Distinct</OO>(comparer)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the elements of the specified sequence or the type </DOCCOMMENT>
        <DOCCOMMENT>/// parameter's default value in a singleton collection if the </DOCCOMMENT>
        <DOCCOMMENT>/// sequence is empty.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> DefaultIfEmpty<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>DefaultIfEmpty</OO>(<KEYWORD>default</KEYWORD>(TSource))<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the elements of the specified sequence or the specified </DOCCOMMENT>
        <DOCCOMMENT>/// value in a singleton collection if the sequence is empty.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>
        
        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> DefaultIfEmpty<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            TSource defaultValue)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> DefaultIfEmptyYield(source<OPERATOR>,</OPERATOR> defaultValue)<OPERATOR>;</OPERATOR>
        }

        <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> DefaultIfEmptyYield<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            TSource defaultValue)
        {
            <KEYWORD>using</KEYWORD> (<KEYWORD>var</KEYWORD> e <OPERATOR>=</OPERATOR> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>GetEnumerator</OO>())
            {
                <KEYWORD>if</KEYWORD> (<OPERATOR>!</OPERATOR>e<OPERATOR>.</OPERATOR><OO>MoveNext</OO>())
                    <KEYWORD>yield</KEYWORD> <KEYWORD>return</KEYWORD> defaultValue<OPERATOR>;</OPERATOR>
                <KEYWORD>else</KEYWORD>
                    <KEYWORD>do</KEYWORD> { <KEYWORD>yield</KEYWORD> <KEYWORD>return</KEYWORD> e<OPERATOR>.</OPERATOR><OO>Current</OO><OPERATOR>;</OPERATOR> } <KEYWORD>while</KEYWORD> (e<OPERATOR>.</OPERATOR><OO>MoveNext</OO>())<OPERATOR>;</OPERATOR>
            }
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Determines whether all elements of a sequence satisfy a condition.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>bool</TYPE> All<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>bool</TYPE><OPERATOR>&gt;</OPERATOR> predicate)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(predicate<OPERATOR>,</OPERATOR> <STRING>"predicate"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> item <KEYWORD>in</KEYWORD> source)
                <KEYWORD>if</KEYWORD> (<OPERATOR>!</OPERATOR>predicate(item))
                    <KEYWORD>return</KEYWORD> <KEYWORD>false</KEYWORD><OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> <KEYWORD>true</KEYWORD><OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Determines whether a sequence contains any elements.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>bool</TYPE> Any<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>using</KEYWORD> (<KEYWORD>var</KEYWORD> e <OPERATOR>=</OPERATOR> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>GetEnumerator</OO>())
                <KEYWORD>return</KEYWORD> e<OPERATOR>.</OPERATOR><OO>MoveNext</OO>()<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Determines whether any element of a sequence satisfies a </DOCCOMMENT>
        <DOCCOMMENT>/// condition.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>bool</TYPE> Any<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>bool</TYPE><OPERATOR>&gt;</OPERATOR> predicate)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(predicate)<OPERATOR>.</OPERATOR><OO>Any</OO>()<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Determines whether a sequence contains a specified element by </DOCCOMMENT>
        <DOCCOMMENT>/// using the default equality comparer.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>bool</TYPE> Contains<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            TSource value)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Contains</OO>(value<OPERATOR>,</OPERATOR> <COMMENT>/* comparer */</COMMENT> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Determines whether a sequence contains a specified element by </DOCCOMMENT>
        <DOCCOMMENT>/// using a specified &lt;see cref="IEqualityComparer{T}" /&gt;.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>bool</TYPE> Contains<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            TSource value<OPERATOR>,</OPERATOR>
            <TYPE>IEqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> comparer)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>if</KEYWORD> (comparer <OPERATOR>==</OPERATOR> <KEYWORD>null</KEYWORD>)
            {
                <KEYWORD>var</KEYWORD> collection <OPERATOR>=</OPERATOR> source <KEYWORD>as</KEYWORD> <TYPE>ICollection</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;;</OPERATOR>
                <KEYWORD>if</KEYWORD> (collection <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>)
                    <KEYWORD>return</KEYWORD> <OBJ>collection</OBJ><OPERATOR>.</OPERATOR><OO>Contains</OO>(value)<OPERATOR>;</OPERATOR>
            }

            comparer <OPERATOR>=</OPERATOR> comparer <OPERATOR>??</OPERATOR> <TYPE>EqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;.</OPERATOR>Default<OPERATOR>;</OPERATOR>
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Any</OO>(item <OPERATOR>=&gt;</OPERATOR> <OBJ>comparer</OBJ><OPERATOR>.</OPERATOR><OO>Equals</OO>(item<OPERATOR>,</OPERATOR> value))<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Determines whether two sequences are equal by comparing the </DOCCOMMENT>
        <DOCCOMMENT>/// elements by using the default equality comparer for their type.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>bool</TYPE> SequenceEqual<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> first<OPERATOR>,</OPERATOR>
            <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> second)
        {
            <KEYWORD>return</KEYWORD> <OBJ>first</OBJ><OPERATOR>.</OPERATOR><OO>SequenceEqual</OO>(second<OPERATOR>,</OPERATOR> <COMMENT>/* comparer */</COMMENT> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Determines whether two sequences are equal by comparing their </DOCCOMMENT>
        <DOCCOMMENT>/// elements by using a specified &lt;see cref="IEqualityComparer{T}" /&gt;.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>bool</TYPE> SequenceEqual<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> first<OPERATOR>,</OPERATOR>
            <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> second<OPERATOR>,</OPERATOR>
            <TYPE>IEqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> comparer)
        {
            CheckNotNull(first<OPERATOR>,</OPERATOR> <STRING>"frist"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(second<OPERATOR>,</OPERATOR> <STRING>"second"</STRING>)<OPERATOR>;</OPERATOR>

            comparer <OPERATOR>=</OPERATOR> comparer <OPERATOR>??</OPERATOR> <TYPE>EqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;.</OPERATOR>Default<OPERATOR>;</OPERATOR>

            <KEYWORD>using</KEYWORD> (<TYPE>IEnumerator</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> lhs <OPERATOR>=</OPERATOR> <OBJ>first</OBJ><OPERATOR>.</OPERATOR><OO>GetEnumerator</OO>()<OPERATOR>,</OPERATOR> 
                                        rhs <OPERATOR>=</OPERATOR> <OBJ>second</OBJ><OPERATOR>.</OPERATOR><OO>GetEnumerator</OO>())
            {
                <KEYWORD>do</KEYWORD>
                {
                    <KEYWORD>if</KEYWORD> (<OPERATOR>!</OPERATOR><OBJ>lhs</OBJ><OPERATOR>.</OPERATOR><OO>MoveNext</OO>())
                        <KEYWORD>return</KEYWORD> <OPERATOR>!</OPERATOR><OBJ>rhs</OBJ><OPERATOR>.</OPERATOR><OO>MoveNext</OO>()<OPERATOR>;</OPERATOR>

                    <KEYWORD>if</KEYWORD> (<OPERATOR>!</OPERATOR><OBJ>rhs</OBJ><OPERATOR>.</OPERATOR><OO>MoveNext</OO>())
                        <KEYWORD>return</KEYWORD> <KEYWORD>false</KEYWORD><OPERATOR>;</OPERATOR>
                } 
                <KEYWORD>while</KEYWORD> (<OBJ>comparer</OBJ><OPERATOR>.</OPERATOR><OO>Equals</OO>(<OBJ>lhs</OBJ><OPERATOR>.</OPERATOR><OO>Current</OO><OPERATOR>,</OPERATOR> <OBJ>rhs</OBJ><OPERATOR>.</OPERATOR><OO>Current</OO>))<OPERATOR>;</OPERATOR>
            }

            <KEYWORD>return</KEYWORD> <KEYWORD>false</KEYWORD><OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Base implementation for Min/Max operator.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> TSource MinMaxImpl<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TSource<OPERATOR>,</OPERATOR> <TYPE>bool</TYPE><OPERATOR>&gt;</OPERATOR> lesser)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            <OBJ>Debug</OBJ><OPERATOR>.</OPERATOR><OO>Assert</OO>(lesser <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Aggregate</OO>((a<OPERATOR>,</OPERATOR> item) <OPERATOR>=&gt;</OPERATOR> lesser(a<OPERATOR>,</OPERATOR> item) <OPERATOR>?</OPERATOR> a <OPERATOR>:</OPERATOR> item)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Base implementation for Min/Max operator for nullable types.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> TSource<OPERATOR>?</OPERATOR> MinMaxImpl<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>?&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            TSource<OPERATOR>?</OPERATOR> seed<OPERATOR>,</OPERATOR> Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>?,</OPERATOR> TSource<OPERATOR>?,</OPERATOR> <TYPE>bool</TYPE><OPERATOR>&gt;</OPERATOR> lesser) where TSource <OPERATOR>:</OPERATOR> <KEYWORD>struct</KEYWORD>
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            <OBJ>Debug</OBJ><OPERATOR>.</OPERATOR><OO>Assert</OO>(lesser <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Aggregate</OO>(seed<OPERATOR>,</OPERATOR> (a<OPERATOR>,</OPERATOR> item) <OPERATOR>=&gt;</OPERATOR> lesser(a<OPERATOR>,</OPERATOR> item) <OPERATOR>?</OPERATOR> a <OPERATOR>:</OPERATOR> item)<OPERATOR>;</OPERATOR> 
            <COMMENT>//  == MinMaxImpl(Repeat&lt;TSource?&gt;(null, 1).Concat(source), lesser);</COMMENT>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the minimum value in a generic sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> TSource Min<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source)
        {
            <KEYWORD>var</KEYWORD> comparer <OPERATOR>=</OPERATOR> <TYPE>Comparer</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;.</OPERATOR>Default<OPERATOR>;</OPERATOR>
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>MinMaxImpl</OO>((x<OPERATOR>,</OPERATOR> y) <OPERATOR>=&gt;</OPERATOR> <OBJ>comparer</OBJ><OPERATOR>.</OPERATOR><OO>Compare</OO>(x<OPERATOR>,</OPERATOR> y) <OPERATOR>&lt;</OPERATOR> <NUMERIC>0</NUMERIC>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Invokes a transform function on each element of a generic </DOCCOMMENT>
        <DOCCOMMENT>/// sequence and returns the minimum resulting value.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> TResult Min<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR> selector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Min</OO>()<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the maximum value in a generic sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> TSource Max<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source)
        {
            <KEYWORD>var</KEYWORD> comparer <OPERATOR>=</OPERATOR> <TYPE>Comparer</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;.</OPERATOR>Default<OPERATOR>;</OPERATOR>
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>MinMaxImpl</OO>((x<OPERATOR>,</OPERATOR> y) <OPERATOR>=&gt;</OPERATOR> <OBJ>comparer</OBJ><OPERATOR>.</OPERATOR><OO>Compare</OO>(x<OPERATOR>,</OPERATOR> y) <OPERATOR>&gt;</OPERATOR> <NUMERIC>0</NUMERIC>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Invokes a transform function on each element of a generic </DOCCOMMENT>
        <DOCCOMMENT>/// sequence and returns the maximum resulting value.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> TResult Max<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR> selector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Max</OO>()<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Makes an enumerator seen as enumerable once more.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;remarks&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// The supplied enumerator must have been started. The first element</DOCCOMMENT>
        <DOCCOMMENT>/// returned is the element the enumerator was on when passed in.</DOCCOMMENT>
        <DOCCOMMENT>/// DO NOT use this method if the caller must be a generator. It is</DOCCOMMENT>
        <DOCCOMMENT>/// mostly safe among aggregate operations.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/remarks&gt;</DOCCOMMENT>

        <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>T<OPERATOR>&gt;</OPERATOR> Renumerable<OPERATOR>&lt;</OPERATOR>T<OPERATOR>&gt;</OPERATOR>(<KEYWORD>this</KEYWORD> <TYPE>IEnumerator</TYPE><OPERATOR>&lt;</OPERATOR>T<OPERATOR>&gt;</OPERATOR> e)
        {
            <OBJ>Debug</OBJ><OPERATOR>.</OPERATOR><OO>Assert</OO>(e <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>

            <KEYWORD>do</KEYWORD> { <KEYWORD>yield</KEYWORD> <KEYWORD>return</KEYWORD> e<OPERATOR>.</OPERATOR><OO>Current</OO><OPERATOR>;</OPERATOR> } <KEYWORD>while</KEYWORD> (e<OPERATOR>.</OPERATOR><OO>MoveNext</OO>())<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Sorts the elements of a sequence in ascending order according to a key.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> IOrderedEnumerable<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> OrderBy<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>OrderBy</OO>(keySelector<OPERATOR>,</OPERATOR> <COMMENT>/* comparer */</COMMENT> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Sorts the elements of a sequence in ascending order by using a </DOCCOMMENT>
        <DOCCOMMENT>/// specified comparer.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> IOrderedEnumerable<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> OrderBy<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector<OPERATOR>,</OPERATOR>
            <TYPE>IComparer</TYPE><OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>&gt;</OPERATOR> comparer)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(keySelector<OPERATOR>,</OPERATOR> <STRING>"keySelector"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> <KEYWORD>new</KEYWORD> OrderedEnumerable<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR>(source<OPERATOR>,</OPERATOR> keySelector<OPERATOR>,</OPERATOR> comparer<OPERATOR>,</OPERATOR> <COMMENT>/* descending */</COMMENT> <KEYWORD>false</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Sorts the elements of a sequence in descending order according to a key.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> IOrderedEnumerable<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> OrderByDescending<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>OrderByDescending</OO>(keySelector<OPERATOR>,</OPERATOR> <COMMENT>/* comparer */</COMMENT> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>///  Sorts the elements of a sequence in descending order by using a </DOCCOMMENT>
        <DOCCOMMENT>/// specified comparer. </DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> IOrderedEnumerable<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> OrderByDescending<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector<OPERATOR>,</OPERATOR> 
            <TYPE>IComparer</TYPE><OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>&gt;</OPERATOR> comparer)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"keySelector"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> <KEYWORD>new</KEYWORD> OrderedEnumerable<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR>(source<OPERATOR>,</OPERATOR> keySelector<OPERATOR>,</OPERATOR> comparer<OPERATOR>,</OPERATOR> <COMMENT>/* descending */</COMMENT> <KEYWORD>true</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Performs a subsequent ordering of the elements in a sequence in </DOCCOMMENT>
        <DOCCOMMENT>/// ascending order according to a key.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> IOrderedEnumerable<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> ThenBy<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> IOrderedEnumerable<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>ThenBy</OO>(keySelector<OPERATOR>,</OPERATOR> <COMMENT>/* comparer */</COMMENT> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Performs a subsequent ordering of the elements in a sequence in </DOCCOMMENT>
        <DOCCOMMENT>/// ascending order by using a specified comparer.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> IOrderedEnumerable<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> ThenBy<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> IOrderedEnumerable<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector<OPERATOR>,</OPERATOR> 
            <TYPE>IComparer</TYPE><OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>&gt;</OPERATOR> comparer)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>CreateOrderedEnumerable</OO>(keySelector<OPERATOR>,</OPERATOR> comparer<OPERATOR>,</OPERATOR> <COMMENT>/* descending */</COMMENT> <KEYWORD>false</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Performs a subsequent ordering of the elements in a sequence in </DOCCOMMENT>
        <DOCCOMMENT>/// descending order, according to a key.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> IOrderedEnumerable<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> ThenByDescending<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> IOrderedEnumerable<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>ThenByDescending</OO>(keySelector<OPERATOR>,</OPERATOR> <COMMENT>/* comparer */</COMMENT> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Performs a subsequent ordering of the elements in a sequence in </DOCCOMMENT>
        <DOCCOMMENT>/// descending order by using a specified comparer.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> IOrderedEnumerable<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> ThenByDescending<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> IOrderedEnumerable<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector<OPERATOR>,</OPERATOR> 
            <TYPE>IComparer</TYPE><OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>&gt;</OPERATOR> comparer)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>CreateOrderedEnumerable</OO>(keySelector<OPERATOR>,</OPERATOR> comparer<OPERATOR>,</OPERATOR> <COMMENT>/* descending */</COMMENT> <KEYWORD>true</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Base implementation for Intersect and Except operators.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> IntersectExceptImpl<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> first<OPERATOR>,</OPERATOR> 
            <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> second<OPERATOR>,</OPERATOR> 
            <TYPE>IEqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> comparer<OPERATOR>,</OPERATOR>
            <TYPE>bool</TYPE> flag)
        {
            CheckNotNull(first<OPERATOR>,</OPERATOR> <STRING>"first"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(second<OPERATOR>,</OPERATOR> <STRING>"second"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>var</KEYWORD> keys <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>List</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>()<OPERATOR>;</OPERATOR>
            <KEYWORD>var</KEYWORD> flags <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Dictionary</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>bool</TYPE><OPERATOR>&gt;</OPERATOR>(comparer)<OPERATOR>;</OPERATOR>

            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> item <KEYWORD>in</KEYWORD> <OBJ>first</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(k <OPERATOR>=&gt;</OPERATOR> <OPERATOR>!</OPERATOR><OBJ>flags</OBJ><OPERATOR>.</OPERATOR><OO>ContainsKey</OO>(k)))
            {
                <OBJ>flags</OBJ><OPERATOR>.</OPERATOR><OO>Add</OO>(item<OPERATOR>,</OPERATOR> <OPERATOR>!</OPERATOR>flag)<OPERATOR>;</OPERATOR>
                <OBJ>keys</OBJ><OPERATOR>.</OPERATOR><OO>Add</OO>(item)<OPERATOR>;</OPERATOR>
            }

            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> item <KEYWORD>in</KEYWORD> <OBJ>second</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(<OBJ>flags</OBJ><OPERATOR>.</OPERATOR><OO>ContainsKey</OO>))
                flags[item] <OPERATOR>=</OPERATOR> flag<OPERATOR>;</OPERATOR>

            <COMMENT>//</COMMENT>
            <COMMENT>// As per docs, "the marked elements are yielded in the order in </COMMENT>
            <COMMENT>// which they were collected.</COMMENT>
            <COMMENT>//</COMMENT>

            <KEYWORD>return</KEYWORD> <OBJ>keys</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(item <OPERATOR>=&gt;</OPERATOR> flags[item])<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Produces the set intersection of two sequences by using the </DOCCOMMENT>
        <DOCCOMMENT>/// default equality comparer to compare values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> Intersect<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> first<OPERATOR>,</OPERATOR> 
            <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> second)
        {
            <KEYWORD>return</KEYWORD> <OBJ>first</OBJ><OPERATOR>.</OPERATOR><OO>Intersect</OO>(second<OPERATOR>,</OPERATOR> <COMMENT>/* comparer */</COMMENT> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Produces the set intersection of two sequences by using the </DOCCOMMENT>
        <DOCCOMMENT>/// specified &lt;see cref="IEqualityComparer{T}" /&gt; to compare values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> Intersect<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> first<OPERATOR>,</OPERATOR> 
            <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> second<OPERATOR>,</OPERATOR> 
            <TYPE>IEqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> comparer)
        {
            <KEYWORD>return</KEYWORD> IntersectExceptImpl(first<OPERATOR>,</OPERATOR> second<OPERATOR>,</OPERATOR> comparer<OPERATOR>,</OPERATOR> <COMMENT>/* flag */</COMMENT> <KEYWORD>true</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Produces the set difference of two sequences by using the </DOCCOMMENT>
        <DOCCOMMENT>/// default equality comparer to compare values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> Except<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> first<OPERATOR>,</OPERATOR>
            <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> second)
        {
            <KEYWORD>return</KEYWORD> <OBJ>first</OBJ><OPERATOR>.</OPERATOR><OO>Except</OO>(second<OPERATOR>,</OPERATOR> <COMMENT>/* comparer */</COMMENT> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Produces the set difference of two sequences by using the </DOCCOMMENT>
        <DOCCOMMENT>/// specified &lt;see cref="IEqualityComparer{T}" /&gt; to compare values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> Except<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> first<OPERATOR>,</OPERATOR>
            <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> second<OPERATOR>,</OPERATOR>
            <TYPE>IEqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> comparer)
        {
            <KEYWORD>return</KEYWORD> IntersectExceptImpl(first<OPERATOR>,</OPERATOR> second<OPERATOR>,</OPERATOR> comparer<OPERATOR>,</OPERATOR> <COMMENT>/* flag */</COMMENT> <KEYWORD>false</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Creates a &lt;see cref="Dictionary{TKey,TValue}" /&gt; from an </DOCCOMMENT>
        <DOCCOMMENT>/// &lt;see cref="IEnumerable{T}" /&gt; according to a specified key </DOCCOMMENT>
        <DOCCOMMENT>/// selector function.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>Dictionary</TYPE><OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TSource<OPERATOR>&gt;</OPERATOR> ToDictionary<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>ToDictionary</OO>(keySelector<OPERATOR>,</OPERATOR> <COMMENT>/* comparer */</COMMENT> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Creates a &lt;see cref="Dictionary{TKey,TValue}" /&gt; from an </DOCCOMMENT>
        <DOCCOMMENT>/// &lt;see cref="IEnumerable{T}" /&gt; according to a specified key </DOCCOMMENT>
        <DOCCOMMENT>/// selector function and key comparer.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>Dictionary</TYPE><OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TSource<OPERATOR>&gt;</OPERATOR> ToDictionary<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector<OPERATOR>,</OPERATOR> 
            <TYPE>IEqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>&gt;</OPERATOR> comparer)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>ToDictionary</OO>(keySelector<OPERATOR>,</OPERATOR> e <OPERATOR>=&gt;</OPERATOR> e)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Creates a &lt;see cref="Dictionary{TKey,TValue}" /&gt; from an </DOCCOMMENT>
        <DOCCOMMENT>/// &lt;see cref="IEnumerable{T}" /&gt; according to specified key </DOCCOMMENT>
        <DOCCOMMENT>/// selector and element selector functions.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>
        
        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>Dictionary</TYPE><OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR> ToDictionary<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR> elementSelector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>ToDictionary</OO>(keySelector<OPERATOR>,</OPERATOR> elementSelector<OPERATOR>,</OPERATOR> <COMMENT>/* comparer */</COMMENT> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Creates a &lt;see cref="Dictionary{TKey,TValue}" /&gt; from an </DOCCOMMENT>
        <DOCCOMMENT>/// &lt;see cref="IEnumerable{T}" /&gt; according to a specified key </DOCCOMMENT>
        <DOCCOMMENT>/// selector function, a comparer, and an element selector function.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>Dictionary</TYPE><OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR> ToDictionary<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR> elementSelector<OPERATOR>,</OPERATOR> 
            <TYPE>IEqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>&gt;</OPERATOR> comparer)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(keySelector<OPERATOR>,</OPERATOR> <STRING>"keySelector"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(elementSelector<OPERATOR>,</OPERATOR> <STRING>"elementSelector"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>var</KEYWORD> dict <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Dictionary</TYPE><OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR>(comparer)<OPERATOR>;</OPERATOR>

            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> item <KEYWORD>in</KEYWORD> source)
            {
                <COMMENT>//</COMMENT>
                <COMMENT>// ToDictionary is meant to throw ArgumentNullException if</COMMENT>
                <COMMENT>// keySelector produces a key that is null and </COMMENT>
                <COMMENT>// Argument exception if keySelector produces duplicate keys </COMMENT>
                <COMMENT>// for two elements. Incidentally, the doucmentation for</COMMENT>
                <COMMENT>// IDictionary&lt;TKey, TValue&gt;.Add says that the Add method</COMMENT>
                <COMMENT>// throws the same exceptions under the same circumstances</COMMENT>
                <COMMENT>// so we don't need to do any additional checking or work</COMMENT>
                <COMMENT>// here and let the Add implementation do all the heavy</COMMENT>
                <COMMENT>// lifting.</COMMENT>
                <COMMENT>//</COMMENT>

                <OBJ>dict</OBJ><OPERATOR>.</OPERATOR><OO>Add</OO>(keySelector(item)<OPERATOR>,</OPERATOR> elementSelector(item))<OPERATOR>;</OPERATOR>
            }

            <KEYWORD>return</KEYWORD> dict<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Correlates the elements of two sequences based on matching keys. </DOCCOMMENT>
        <DOCCOMMENT>/// The default equality comparer is used to compare keys.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR> Join<OPERATOR>&lt;</OPERATOR>TOuter<OPERATOR>,</OPERATOR> TInner<OPERATOR>,</OPERATOR> TKey<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TOuter<OPERATOR>&gt;</OPERATOR> outer<OPERATOR>,</OPERATOR>
            <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TInner<OPERATOR>&gt;</OPERATOR> inner<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TOuter<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> outerKeySelector<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TInner<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> innerKeySelector<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TOuter<OPERATOR>,</OPERATOR> TInner<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR> resultSelector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>outer</OBJ><OPERATOR>.</OPERATOR><OO>Join</OO>(inner<OPERATOR>,</OPERATOR> outerKeySelector<OPERATOR>,</OPERATOR> innerKeySelector<OPERATOR>,</OPERATOR> resultSelector<OPERATOR>,</OPERATOR> <COMMENT>/* comparer */</COMMENT> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Correlates the elements of two sequences based on matching keys. </DOCCOMMENT>
        <DOCCOMMENT>/// The default equality comparer is used to compare keys. A </DOCCOMMENT>
        <DOCCOMMENT>/// specified &lt;see cref="IEqualityComparer{T}" /&gt; is used to compare keys.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR> Join<OPERATOR>&lt;</OPERATOR>TOuter<OPERATOR>,</OPERATOR> TInner<OPERATOR>,</OPERATOR> TKey<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TOuter<OPERATOR>&gt;</OPERATOR> outer<OPERATOR>,</OPERATOR>
            <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TInner<OPERATOR>&gt;</OPERATOR> inner<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TOuter<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> outerKeySelector<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TInner<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> innerKeySelector<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TOuter<OPERATOR>,</OPERATOR> TInner<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR> resultSelector<OPERATOR>,</OPERATOR>
            <TYPE>IEqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>&gt;</OPERATOR> comparer)
        {
            CheckNotNull(outer<OPERATOR>,</OPERATOR> <STRING>"outer"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(inner<OPERATOR>,</OPERATOR> <STRING>"inner"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(outerKeySelector<OPERATOR>,</OPERATOR> <STRING>"outerKeySelector"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(innerKeySelector<OPERATOR>,</OPERATOR> <STRING>"innerKeySelector"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(resultSelector<OPERATOR>,</OPERATOR> <STRING>"resultSelector"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>var</KEYWORD> lookup <OPERATOR>=</OPERATOR> <OBJ>inner</OBJ><OPERATOR>.</OPERATOR><OO>ToLookup</OO>(innerKeySelector<OPERATOR>,</OPERATOR> comparer)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD>
                from o <KEYWORD>in</KEYWORD> outer
                from i <KEYWORD>in</KEYWORD> lookup[outerKeySelector(o)]
                select resultSelector(o<OPERATOR>,</OPERATOR> i)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Correlates the elements of two sequences based on equality of </DOCCOMMENT>
        <DOCCOMMENT>/// keys and groups the results. The default equality comparer is </DOCCOMMENT>
        <DOCCOMMENT>/// used to compare keys.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR> GroupJoin<OPERATOR>&lt;</OPERATOR>TOuter<OPERATOR>,</OPERATOR> TInner<OPERATOR>,</OPERATOR> TKey<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TOuter<OPERATOR>&gt;</OPERATOR> outer<OPERATOR>,</OPERATOR>
            <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TInner<OPERATOR>&gt;</OPERATOR> inner<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TOuter<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> outerKeySelector<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TInner<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> innerKeySelector<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TOuter<OPERATOR>,</OPERATOR> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TInner<OPERATOR>&gt;,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR> resultSelector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>outer</OBJ><OPERATOR>.</OPERATOR><OO>GroupJoin</OO>(inner<OPERATOR>,</OPERATOR> outerKeySelector<OPERATOR>,</OPERATOR> innerKeySelector<OPERATOR>,</OPERATOR> resultSelector<OPERATOR>,</OPERATOR> <COMMENT>/* comparer */</COMMENT> <KEYWORD>null</KEYWORD>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Correlates the elements of two sequences based on equality of </DOCCOMMENT>
        <DOCCOMMENT>/// keys and groups the results. The default equality comparer is </DOCCOMMENT>
        <DOCCOMMENT>/// used to compare keys. A specified &lt;see cref="IEqualityComparer{T}" /&gt; </DOCCOMMENT>
        <DOCCOMMENT>/// is used to compare keys.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR> GroupJoin<OPERATOR>&lt;</OPERATOR>TOuter<OPERATOR>,</OPERATOR> TInner<OPERATOR>,</OPERATOR> TKey<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TOuter<OPERATOR>&gt;</OPERATOR> outer<OPERATOR>,</OPERATOR> 
            <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TInner<OPERATOR>&gt;</OPERATOR> inner<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TOuter<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> outerKeySelector<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TInner<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> innerKeySelector<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>TOuter<OPERATOR>,</OPERATOR> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TInner<OPERATOR>&gt;,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR> resultSelector<OPERATOR>,</OPERATOR> 
            <TYPE>IEqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>&gt;</OPERATOR> comparer)
        {
            CheckNotNull(outer<OPERATOR>,</OPERATOR> <STRING>"outer"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(inner<OPERATOR>,</OPERATOR> <STRING>"inner"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(outerKeySelector<OPERATOR>,</OPERATOR> <STRING>"outerKeySelector"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(innerKeySelector<OPERATOR>,</OPERATOR> <STRING>"innerKeySelector"</STRING>)<OPERATOR>;</OPERATOR>
            CheckNotNull(resultSelector<OPERATOR>,</OPERATOR> <STRING>"resultSelector"</STRING>)<OPERATOR>;</OPERATOR>

            <KEYWORD>var</KEYWORD> lookup <OPERATOR>=</OPERATOR> <OBJ>inner</OBJ><OPERATOR>.</OPERATOR><OO>ToLookup</OO>(innerKeySelector<OPERATOR>,</OPERATOR> comparer)<OPERATOR>;</OPERATOR>
            <KEYWORD>return</KEYWORD> <OBJ>outer</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(o <OPERATOR>=&gt;</OPERATOR> resultSelector(o<OPERATOR>,</OPERATOR> lookup[outerKeySelector(o)]))<OPERATOR>;</OPERATOR>
        }
        
        [DebuggerStepThrough]
        <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>void</TYPE> CheckNotNull<OPERATOR>&lt;</OPERATOR>T<OPERATOR>&gt;</OPERATOR>(T value<OPERATOR>,</OPERATOR> <TYPE>string</TYPE> name) where T <OPERATOR>:</OPERATOR> <KEYWORD>class</KEYWORD>
        {
            <KEYWORD>if</KEYWORD> (value <OPERATOR>==</OPERATOR> <KEYWORD>null</KEYWORD>) 
                <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> <TYPE>ArgumentNullException</TYPE>(name)<OPERATOR>;</OPERATOR>
        }

        <KEYWORD>private</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>class</KEYWORD> Sequence<OPERATOR>&lt;</OPERATOR>T<OPERATOR>&gt;</OPERATOR>
        {
            <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <KEYWORD>readonly</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>T<OPERATOR>&gt;</OPERATOR> Empty <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> T[<NUMERIC>0</NUMERIC>]<OPERATOR>;</OPERATOR>
        }

        <KEYWORD>private</KEYWORD> <KEYWORD>sealed</KEYWORD> <KEYWORD>class</KEYWORD> Grouping<OPERATOR>&lt;</OPERATOR>K<OPERATOR>,</OPERATOR> V<OPERATOR>&gt;</OPERATOR> <OPERATOR>:</OPERATOR> <TYPE>List</TYPE><OPERATOR>&lt;</OPERATOR>V<OPERATOR>&gt;,</OPERATOR> IGrouping<OPERATOR>&lt;</OPERATOR>K<OPERATOR>,</OPERATOR> V<OPERATOR>&gt;</OPERATOR>
        {
            <KEYWORD>internal</KEYWORD> Grouping(K key)
            {
                Key <OPERATOR>=</OPERATOR> key<OPERATOR>;</OPERATOR>
            }

            <KEYWORD>public</KEYWORD> K Key { get<OPERATOR>;</OPERATOR> <KEYWORD>private</KEYWORD> set<OPERATOR>;</OPERATOR> }
        }
    }
}

<COMMENT>// $Id: Enumerable.g.cs 224 2008-11-27 18:15:15Z azizatif $</COMMENT>

<KEYWORD>namespace</KEYWORD> <OBJ>System</OBJ><OPERATOR>.</OPERATOR><OO>Linq</OO>
{
    <PREPROCESSOR>#region Imports</PREPROCESSOR>

    <KEYWORD>using</KEYWORD> System<OPERATOR>;</OPERATOR>
    <KEYWORD>using</KEYWORD> <OBJ>System</OBJ><OPERATOR>.</OPERATOR><OO>Collections</OO><OPERATOR>.</OPERATOR><OO>Generic</OO><OPERATOR>;</OPERATOR>

    <PREPROCESSOR>#endregion</PREPROCESSOR>
    
    <COMMENT>// This partial implementation was template-generated:</COMMENT>
    <COMMENT>// Thu, 27 Nov 2008 18:14:23 GMT</COMMENT>

    partial <KEYWORD>class</KEYWORD> Enumerable
    {
        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the sum of a sequence of nullable &lt;see cref="System.Int32" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>int</TYPE> Sum(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>int</TYPE><OPERATOR>&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <TYPE>int</TYPE> sum <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> num <KEYWORD>in</KEYWORD> source)
                sum <OPERATOR>=</OPERATOR> <KEYWORD>checked</KEYWORD>(sum <OPERATOR>+</OPERATOR> num)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> sum<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the sum of a sequence of nullable &lt;see cref="System.Int32" /&gt; </DOCCOMMENT>
        <DOCCOMMENT>/// values that are obtained by invoking a transform function on </DOCCOMMENT>
        <DOCCOMMENT>/// each element of the input sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>int</TYPE> Sum<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>int</TYPE><OPERATOR>&gt;</OPERATOR> selector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Sum</OO>()<OPERATOR>;</OPERATOR>
        }
        
        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the average of a sequence of nullable &lt;see cref="System.Int32" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>double</TYPE> Average(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>int</TYPE><OPERATOR>&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <TYPE>long</TYPE> sum <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
            <TYPE>long</TYPE> count <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>

            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> num <KEYWORD>in</KEYWORD> source)
            <KEYWORD>checked</KEYWORD>
            {
                sum <OPERATOR>+=</OPERATOR> (<TYPE>int</TYPE>) num<OPERATOR>;</OPERATOR>
                count<OPERATOR>++;</OPERATOR>
            }

            <KEYWORD>if</KEYWORD> (count <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC>)
                <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> <TYPE>InvalidOperationException</TYPE>()<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> (<TYPE>double</TYPE>) sum <OPERATOR>/</OPERATOR> count<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the average of a sequence of nullable &lt;see cref="System.Int32" /&gt; values </DOCCOMMENT>
        <DOCCOMMENT>/// that are obtained by invoking a transform function on each </DOCCOMMENT>
        <DOCCOMMENT>/// element of the input sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>double</TYPE> Average<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>int</TYPE><OPERATOR>&gt;</OPERATOR> selector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Average</OO>()<OPERATOR>;</OPERATOR>
        }
        

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the sum of a sequence of &lt;see cref="System.Int32" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>int</TYPE><OPERATOR>?</OPERATOR> Sum(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>int</TYPE><OPERATOR>?&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <TYPE>int</TYPE> sum <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> num <KEYWORD>in</KEYWORD> source)
                sum <OPERATOR>=</OPERATOR> <KEYWORD>checked</KEYWORD>(sum <OPERATOR>+</OPERATOR> (num <OPERATOR>??</OPERATOR> <NUMERIC>0</NUMERIC>))<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> sum<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the sum of a sequence of &lt;see cref="System.Int32" /&gt; </DOCCOMMENT>
        <DOCCOMMENT>/// values that are obtained by invoking a transform function on </DOCCOMMENT>
        <DOCCOMMENT>/// each element of the input sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>int</TYPE><OPERATOR>?</OPERATOR> Sum<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>int</TYPE><OPERATOR>?&gt;</OPERATOR> selector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Sum</OO>()<OPERATOR>;</OPERATOR>
        }
        
        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the average of a sequence of &lt;see cref="System.Int32" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>double</TYPE><OPERATOR>?</OPERATOR> Average(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>int</TYPE><OPERATOR>?&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <TYPE>long</TYPE> sum <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
            <TYPE>long</TYPE> count <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>

            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> num <KEYWORD>in</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(n <OPERATOR>=&gt;</OPERATOR> n <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>))
            <KEYWORD>checked</KEYWORD>
            {
                sum <OPERATOR>+=</OPERATOR> (<TYPE>int</TYPE>) num<OPERATOR>;</OPERATOR>
                count<OPERATOR>++;</OPERATOR>
            }

            <KEYWORD>if</KEYWORD> (count <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC>)
                <KEYWORD>return</KEYWORD> <KEYWORD>null</KEYWORD><OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> (<TYPE>double</TYPE><OPERATOR>?</OPERATOR>) sum <OPERATOR>/</OPERATOR> count<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the average of a sequence of &lt;see cref="System.Int32" /&gt; values </DOCCOMMENT>
        <DOCCOMMENT>/// that are obtained by invoking a transform function on each </DOCCOMMENT>
        <DOCCOMMENT>/// element of the input sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>double</TYPE><OPERATOR>?</OPERATOR> Average<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>int</TYPE><OPERATOR>?&gt;</OPERATOR> selector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Average</OO>()<OPERATOR>;</OPERATOR>
        }
        
        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the minimum value in a sequence of nullable </DOCCOMMENT>
        <DOCCOMMENT>/// &lt;see cref="System.Int32" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>int</TYPE><OPERATOR>?</OPERATOR> Min(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>int</TYPE><OPERATOR>?&gt;</OPERATOR> source) 
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            
            <KEYWORD>return</KEYWORD> MinMaxImpl(<OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(x <OPERATOR>=&gt;</OPERATOR> x <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>)<OPERATOR>,</OPERATOR> <KEYWORD>null</KEYWORD><OPERATOR>,</OPERATOR> (min<OPERATOR>,</OPERATOR> x) <OPERATOR>=&gt;</OPERATOR> min <OPERATOR>&lt;</OPERATOR> x)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Invokes a transform function on each element of a sequence and </DOCCOMMENT>
        <DOCCOMMENT>/// returns the minimum nullable &lt;see cref="System.Int32" /&gt; value.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>int</TYPE><OPERATOR>?</OPERATOR> Min<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>int</TYPE><OPERATOR>?&gt;</OPERATOR> selector) 
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Min</OO>()<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the maximum value in a sequence of nullable </DOCCOMMENT>
        <DOCCOMMENT>/// &lt;see cref="System.Int32" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>int</TYPE><OPERATOR>?</OPERATOR> Max(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>int</TYPE><OPERATOR>?&gt;</OPERATOR> source) 
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            
            <KEYWORD>return</KEYWORD> MinMaxImpl(<OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(x <OPERATOR>=&gt;</OPERATOR> x <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>)<OPERATOR>,</OPERATOR> 
                <KEYWORD>null</KEYWORD><OPERATOR>,</OPERATOR> (max<OPERATOR>,</OPERATOR> x) <OPERATOR>=&gt;</OPERATOR> x <OPERATOR>==</OPERATOR> <KEYWORD>null</KEYWORD> <OPERATOR>||</OPERATOR> (max <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD> <OPERATOR>&amp;&amp;</OPERATOR> x<OPERATOR>.</OPERATOR><OO>Value</OO> <OPERATOR>&lt;</OPERATOR> <OBJ>max</OBJ><OPERATOR>.</OPERATOR><OO>Value</OO>))<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Invokes a transform function on each element of a sequence and </DOCCOMMENT>
        <DOCCOMMENT>/// returns the maximum nullable &lt;see cref="System.Int32" /&gt; value.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>int</TYPE><OPERATOR>?</OPERATOR> Max<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>int</TYPE><OPERATOR>?&gt;</OPERATOR> selector) 
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Max</OO>()<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the sum of a sequence of nullable &lt;see cref="System.Int64" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>long</TYPE> Sum(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>long</TYPE><OPERATOR>&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <TYPE>long</TYPE> sum <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> num <KEYWORD>in</KEYWORD> source)
                sum <OPERATOR>=</OPERATOR> <KEYWORD>checked</KEYWORD>(sum <OPERATOR>+</OPERATOR> num)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> sum<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the sum of a sequence of nullable &lt;see cref="System.Int64" /&gt; </DOCCOMMENT>
        <DOCCOMMENT>/// values that are obtained by invoking a transform function on </DOCCOMMENT>
        <DOCCOMMENT>/// each element of the input sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>long</TYPE> Sum<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>long</TYPE><OPERATOR>&gt;</OPERATOR> selector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Sum</OO>()<OPERATOR>;</OPERATOR>
        }
        
        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the average of a sequence of nullable &lt;see cref="System.Int64" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>double</TYPE> Average(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>long</TYPE><OPERATOR>&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <TYPE>long</TYPE> sum <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
            <TYPE>long</TYPE> count <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>

            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> num <KEYWORD>in</KEYWORD> source)
            <KEYWORD>checked</KEYWORD>
            {
                sum <OPERATOR>+=</OPERATOR> (<TYPE>long</TYPE>) num<OPERATOR>;</OPERATOR>
                count<OPERATOR>++;</OPERATOR>
            }

            <KEYWORD>if</KEYWORD> (count <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC>)
                <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> <TYPE>InvalidOperationException</TYPE>()<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> (<TYPE>double</TYPE>) sum <OPERATOR>/</OPERATOR> count<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the average of a sequence of nullable &lt;see cref="System.Int64" /&gt; values </DOCCOMMENT>
        <DOCCOMMENT>/// that are obtained by invoking a transform function on each </DOCCOMMENT>
        <DOCCOMMENT>/// element of the input sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>double</TYPE> Average<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>long</TYPE><OPERATOR>&gt;</OPERATOR> selector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Average</OO>()<OPERATOR>;</OPERATOR>
        }
        

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the sum of a sequence of &lt;see cref="System.Int64" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>long</TYPE><OPERATOR>?</OPERATOR> Sum(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>long</TYPE><OPERATOR>?&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <TYPE>long</TYPE> sum <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> num <KEYWORD>in</KEYWORD> source)
                sum <OPERATOR>=</OPERATOR> <KEYWORD>checked</KEYWORD>(sum <OPERATOR>+</OPERATOR> (num <OPERATOR>??</OPERATOR> <NUMERIC>0</NUMERIC>))<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> sum<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the sum of a sequence of &lt;see cref="System.Int64" /&gt; </DOCCOMMENT>
        <DOCCOMMENT>/// values that are obtained by invoking a transform function on </DOCCOMMENT>
        <DOCCOMMENT>/// each element of the input sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>long</TYPE><OPERATOR>?</OPERATOR> Sum<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>long</TYPE><OPERATOR>?&gt;</OPERATOR> selector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Sum</OO>()<OPERATOR>;</OPERATOR>
        }
        
        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the average of a sequence of &lt;see cref="System.Int64" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>double</TYPE><OPERATOR>?</OPERATOR> Average(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>long</TYPE><OPERATOR>?&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <TYPE>long</TYPE> sum <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
            <TYPE>long</TYPE> count <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>

            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> num <KEYWORD>in</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(n <OPERATOR>=&gt;</OPERATOR> n <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>))
            <KEYWORD>checked</KEYWORD>
            {
                sum <OPERATOR>+=</OPERATOR> (<TYPE>long</TYPE>) num<OPERATOR>;</OPERATOR>
                count<OPERATOR>++;</OPERATOR>
            }

            <KEYWORD>if</KEYWORD> (count <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC>)
                <KEYWORD>return</KEYWORD> <KEYWORD>null</KEYWORD><OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> (<TYPE>double</TYPE><OPERATOR>?</OPERATOR>) sum <OPERATOR>/</OPERATOR> count<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the average of a sequence of &lt;see cref="System.Int64" /&gt; values </DOCCOMMENT>
        <DOCCOMMENT>/// that are obtained by invoking a transform function on each </DOCCOMMENT>
        <DOCCOMMENT>/// element of the input sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>double</TYPE><OPERATOR>?</OPERATOR> Average<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>long</TYPE><OPERATOR>?&gt;</OPERATOR> selector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Average</OO>()<OPERATOR>;</OPERATOR>
        }
        
        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the minimum value in a sequence of nullable </DOCCOMMENT>
        <DOCCOMMENT>/// &lt;see cref="System.Int64" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>long</TYPE><OPERATOR>?</OPERATOR> Min(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>long</TYPE><OPERATOR>?&gt;</OPERATOR> source) 
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            
            <KEYWORD>return</KEYWORD> MinMaxImpl(<OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(x <OPERATOR>=&gt;</OPERATOR> x <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>)<OPERATOR>,</OPERATOR> <KEYWORD>null</KEYWORD><OPERATOR>,</OPERATOR> (min<OPERATOR>,</OPERATOR> x) <OPERATOR>=&gt;</OPERATOR> min <OPERATOR>&lt;</OPERATOR> x)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Invokes a transform function on each element of a sequence and </DOCCOMMENT>
        <DOCCOMMENT>/// returns the minimum nullable &lt;see cref="System.Int64" /&gt; value.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>long</TYPE><OPERATOR>?</OPERATOR> Min<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>long</TYPE><OPERATOR>?&gt;</OPERATOR> selector) 
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Min</OO>()<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the maximum value in a sequence of nullable </DOCCOMMENT>
        <DOCCOMMENT>/// &lt;see cref="System.Int64" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>long</TYPE><OPERATOR>?</OPERATOR> Max(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>long</TYPE><OPERATOR>?&gt;</OPERATOR> source) 
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            
            <KEYWORD>return</KEYWORD> MinMaxImpl(<OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(x <OPERATOR>=&gt;</OPERATOR> x <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>)<OPERATOR>,</OPERATOR> 
                <KEYWORD>null</KEYWORD><OPERATOR>,</OPERATOR> (max<OPERATOR>,</OPERATOR> x) <OPERATOR>=&gt;</OPERATOR> x <OPERATOR>==</OPERATOR> <KEYWORD>null</KEYWORD> <OPERATOR>||</OPERATOR> (max <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD> <OPERATOR>&amp;&amp;</OPERATOR> x<OPERATOR>.</OPERATOR><OO>Value</OO> <OPERATOR>&lt;</OPERATOR> <OBJ>max</OBJ><OPERATOR>.</OPERATOR><OO>Value</OO>))<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Invokes a transform function on each element of a sequence and </DOCCOMMENT>
        <DOCCOMMENT>/// returns the maximum nullable &lt;see cref="System.Int64" /&gt; value.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>long</TYPE><OPERATOR>?</OPERATOR> Max<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>long</TYPE><OPERATOR>?&gt;</OPERATOR> selector) 
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Max</OO>()<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the sum of a sequence of nullable &lt;see cref="System.Single" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>float</TYPE> Sum(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>float</TYPE><OPERATOR>&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <TYPE>float</TYPE> sum <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> num <KEYWORD>in</KEYWORD> source)
                sum <OPERATOR>=</OPERATOR> <KEYWORD>checked</KEYWORD>(sum <OPERATOR>+</OPERATOR> num)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> sum<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the sum of a sequence of nullable &lt;see cref="System.Single" /&gt; </DOCCOMMENT>
        <DOCCOMMENT>/// values that are obtained by invoking a transform function on </DOCCOMMENT>
        <DOCCOMMENT>/// each element of the input sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>float</TYPE> Sum<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>float</TYPE><OPERATOR>&gt;</OPERATOR> selector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Sum</OO>()<OPERATOR>;</OPERATOR>
        }
        
        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the average of a sequence of nullable &lt;see cref="System.Single" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>float</TYPE> Average(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>float</TYPE><OPERATOR>&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <TYPE>float</TYPE> sum <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
            <TYPE>long</TYPE> count <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>

            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> num <KEYWORD>in</KEYWORD> source)
            <KEYWORD>checked</KEYWORD>
            {
                sum <OPERATOR>+=</OPERATOR> (<TYPE>float</TYPE>) num<OPERATOR>;</OPERATOR>
                count<OPERATOR>++;</OPERATOR>
            }

            <KEYWORD>if</KEYWORD> (count <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC>)
                <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> <TYPE>InvalidOperationException</TYPE>()<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> (<TYPE>float</TYPE>) sum <OPERATOR>/</OPERATOR> count<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the average of a sequence of nullable &lt;see cref="System.Single" /&gt; values </DOCCOMMENT>
        <DOCCOMMENT>/// that are obtained by invoking a transform function on each </DOCCOMMENT>
        <DOCCOMMENT>/// element of the input sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>float</TYPE> Average<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>float</TYPE><OPERATOR>&gt;</OPERATOR> selector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Average</OO>()<OPERATOR>;</OPERATOR>
        }
        

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the sum of a sequence of &lt;see cref="System.Single" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>float</TYPE><OPERATOR>?</OPERATOR> Sum(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>float</TYPE><OPERATOR>?&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <TYPE>float</TYPE> sum <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> num <KEYWORD>in</KEYWORD> source)
                sum <OPERATOR>=</OPERATOR> <KEYWORD>checked</KEYWORD>(sum <OPERATOR>+</OPERATOR> (num <OPERATOR>??</OPERATOR> <NUMERIC>0</NUMERIC>))<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> sum<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the sum of a sequence of &lt;see cref="System.Single" /&gt; </DOCCOMMENT>
        <DOCCOMMENT>/// values that are obtained by invoking a transform function on </DOCCOMMENT>
        <DOCCOMMENT>/// each element of the input sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>float</TYPE><OPERATOR>?</OPERATOR> Sum<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>float</TYPE><OPERATOR>?&gt;</OPERATOR> selector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Sum</OO>()<OPERATOR>;</OPERATOR>
        }
        
        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the average of a sequence of &lt;see cref="System.Single" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>float</TYPE><OPERATOR>?</OPERATOR> Average(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>float</TYPE><OPERATOR>?&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <TYPE>float</TYPE> sum <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
            <TYPE>long</TYPE> count <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>

            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> num <KEYWORD>in</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(n <OPERATOR>=&gt;</OPERATOR> n <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>))
            <KEYWORD>checked</KEYWORD>
            {
                sum <OPERATOR>+=</OPERATOR> (<TYPE>float</TYPE>) num<OPERATOR>;</OPERATOR>
                count<OPERATOR>++;</OPERATOR>
            }

            <KEYWORD>if</KEYWORD> (count <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC>)
                <KEYWORD>return</KEYWORD> <KEYWORD>null</KEYWORD><OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> (<TYPE>float</TYPE><OPERATOR>?</OPERATOR>) sum <OPERATOR>/</OPERATOR> count<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the average of a sequence of &lt;see cref="System.Single" /&gt; values </DOCCOMMENT>
        <DOCCOMMENT>/// that are obtained by invoking a transform function on each </DOCCOMMENT>
        <DOCCOMMENT>/// element of the input sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>float</TYPE><OPERATOR>?</OPERATOR> Average<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>float</TYPE><OPERATOR>?&gt;</OPERATOR> selector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Average</OO>()<OPERATOR>;</OPERATOR>
        }
        
        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the minimum value in a sequence of nullable </DOCCOMMENT>
        <DOCCOMMENT>/// &lt;see cref="System.Single" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>float</TYPE><OPERATOR>?</OPERATOR> Min(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>float</TYPE><OPERATOR>?&gt;</OPERATOR> source) 
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            
            <KEYWORD>return</KEYWORD> MinMaxImpl(<OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(x <OPERATOR>=&gt;</OPERATOR> x <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>)<OPERATOR>,</OPERATOR> <KEYWORD>null</KEYWORD><OPERATOR>,</OPERATOR> (min<OPERATOR>,</OPERATOR> x) <OPERATOR>=&gt;</OPERATOR> min <OPERATOR>&lt;</OPERATOR> x)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Invokes a transform function on each element of a sequence and </DOCCOMMENT>
        <DOCCOMMENT>/// returns the minimum nullable &lt;see cref="System.Single" /&gt; value.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>float</TYPE><OPERATOR>?</OPERATOR> Min<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>float</TYPE><OPERATOR>?&gt;</OPERATOR> selector) 
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Min</OO>()<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the maximum value in a sequence of nullable </DOCCOMMENT>
        <DOCCOMMENT>/// &lt;see cref="System.Single" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>float</TYPE><OPERATOR>?</OPERATOR> Max(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>float</TYPE><OPERATOR>?&gt;</OPERATOR> source) 
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            
            <KEYWORD>return</KEYWORD> MinMaxImpl(<OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(x <OPERATOR>=&gt;</OPERATOR> x <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>)<OPERATOR>,</OPERATOR> 
                <KEYWORD>null</KEYWORD><OPERATOR>,</OPERATOR> (max<OPERATOR>,</OPERATOR> x) <OPERATOR>=&gt;</OPERATOR> x <OPERATOR>==</OPERATOR> <KEYWORD>null</KEYWORD> <OPERATOR>||</OPERATOR> (max <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD> <OPERATOR>&amp;&amp;</OPERATOR> x<OPERATOR>.</OPERATOR><OO>Value</OO> <OPERATOR>&lt;</OPERATOR> <OBJ>max</OBJ><OPERATOR>.</OPERATOR><OO>Value</OO>))<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Invokes a transform function on each element of a sequence and </DOCCOMMENT>
        <DOCCOMMENT>/// returns the maximum nullable &lt;see cref="System.Single" /&gt; value.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>float</TYPE><OPERATOR>?</OPERATOR> Max<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>float</TYPE><OPERATOR>?&gt;</OPERATOR> selector) 
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Max</OO>()<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the sum of a sequence of nullable &lt;see cref="System.Double" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>double</TYPE> Sum(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>double</TYPE><OPERATOR>&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <TYPE>double</TYPE> sum <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> num <KEYWORD>in</KEYWORD> source)
                sum <OPERATOR>=</OPERATOR> <KEYWORD>checked</KEYWORD>(sum <OPERATOR>+</OPERATOR> num)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> sum<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the sum of a sequence of nullable &lt;see cref="System.Double" /&gt; </DOCCOMMENT>
        <DOCCOMMENT>/// values that are obtained by invoking a transform function on </DOCCOMMENT>
        <DOCCOMMENT>/// each element of the input sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>double</TYPE> Sum<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>double</TYPE><OPERATOR>&gt;</OPERATOR> selector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Sum</OO>()<OPERATOR>;</OPERATOR>
        }
        
        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the average of a sequence of nullable &lt;see cref="System.Double" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>double</TYPE> Average(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>double</TYPE><OPERATOR>&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <TYPE>double</TYPE> sum <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
            <TYPE>long</TYPE> count <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>

            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> num <KEYWORD>in</KEYWORD> source)
            <KEYWORD>checked</KEYWORD>
            {
                sum <OPERATOR>+=</OPERATOR> (<TYPE>double</TYPE>) num<OPERATOR>;</OPERATOR>
                count<OPERATOR>++;</OPERATOR>
            }

            <KEYWORD>if</KEYWORD> (count <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC>)
                <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> <TYPE>InvalidOperationException</TYPE>()<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> (<TYPE>double</TYPE>) sum <OPERATOR>/</OPERATOR> count<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the average of a sequence of nullable &lt;see cref="System.Double" /&gt; values </DOCCOMMENT>
        <DOCCOMMENT>/// that are obtained by invoking a transform function on each </DOCCOMMENT>
        <DOCCOMMENT>/// element of the input sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>double</TYPE> Average<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>double</TYPE><OPERATOR>&gt;</OPERATOR> selector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Average</OO>()<OPERATOR>;</OPERATOR>
        }
        

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the sum of a sequence of &lt;see cref="System.Double" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>double</TYPE><OPERATOR>?</OPERATOR> Sum(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>double</TYPE><OPERATOR>?&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <TYPE>double</TYPE> sum <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> num <KEYWORD>in</KEYWORD> source)
                sum <OPERATOR>=</OPERATOR> <KEYWORD>checked</KEYWORD>(sum <OPERATOR>+</OPERATOR> (num <OPERATOR>??</OPERATOR> <NUMERIC>0</NUMERIC>))<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> sum<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the sum of a sequence of &lt;see cref="System.Double" /&gt; </DOCCOMMENT>
        <DOCCOMMENT>/// values that are obtained by invoking a transform function on </DOCCOMMENT>
        <DOCCOMMENT>/// each element of the input sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>double</TYPE><OPERATOR>?</OPERATOR> Sum<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>double</TYPE><OPERATOR>?&gt;</OPERATOR> selector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Sum</OO>()<OPERATOR>;</OPERATOR>
        }
        
        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the average of a sequence of &lt;see cref="System.Double" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>double</TYPE><OPERATOR>?</OPERATOR> Average(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>double</TYPE><OPERATOR>?&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <TYPE>double</TYPE> sum <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
            <TYPE>long</TYPE> count <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>

            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> num <KEYWORD>in</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(n <OPERATOR>=&gt;</OPERATOR> n <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>))
            <KEYWORD>checked</KEYWORD>
            {
                sum <OPERATOR>+=</OPERATOR> (<TYPE>double</TYPE>) num<OPERATOR>;</OPERATOR>
                count<OPERATOR>++;</OPERATOR>
            }

            <KEYWORD>if</KEYWORD> (count <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC>)
                <KEYWORD>return</KEYWORD> <KEYWORD>null</KEYWORD><OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> (<TYPE>double</TYPE><OPERATOR>?</OPERATOR>) sum <OPERATOR>/</OPERATOR> count<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the average of a sequence of &lt;see cref="System.Double" /&gt; values </DOCCOMMENT>
        <DOCCOMMENT>/// that are obtained by invoking a transform function on each </DOCCOMMENT>
        <DOCCOMMENT>/// element of the input sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>double</TYPE><OPERATOR>?</OPERATOR> Average<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>double</TYPE><OPERATOR>?&gt;</OPERATOR> selector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Average</OO>()<OPERATOR>;</OPERATOR>
        }
        
        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the minimum value in a sequence of nullable </DOCCOMMENT>
        <DOCCOMMENT>/// &lt;see cref="System.Double" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>double</TYPE><OPERATOR>?</OPERATOR> Min(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>double</TYPE><OPERATOR>?&gt;</OPERATOR> source) 
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            
            <KEYWORD>return</KEYWORD> MinMaxImpl(<OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(x <OPERATOR>=&gt;</OPERATOR> x <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>)<OPERATOR>,</OPERATOR> <KEYWORD>null</KEYWORD><OPERATOR>,</OPERATOR> (min<OPERATOR>,</OPERATOR> x) <OPERATOR>=&gt;</OPERATOR> min <OPERATOR>&lt;</OPERATOR> x)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Invokes a transform function on each element of a sequence and </DOCCOMMENT>
        <DOCCOMMENT>/// returns the minimum nullable &lt;see cref="System.Double" /&gt; value.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>double</TYPE><OPERATOR>?</OPERATOR> Min<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>double</TYPE><OPERATOR>?&gt;</OPERATOR> selector) 
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Min</OO>()<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the maximum value in a sequence of nullable </DOCCOMMENT>
        <DOCCOMMENT>/// &lt;see cref="System.Double" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>double</TYPE><OPERATOR>?</OPERATOR> Max(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>double</TYPE><OPERATOR>?&gt;</OPERATOR> source) 
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            
            <KEYWORD>return</KEYWORD> MinMaxImpl(<OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(x <OPERATOR>=&gt;</OPERATOR> x <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>)<OPERATOR>,</OPERATOR> 
                <KEYWORD>null</KEYWORD><OPERATOR>,</OPERATOR> (max<OPERATOR>,</OPERATOR> x) <OPERATOR>=&gt;</OPERATOR> x <OPERATOR>==</OPERATOR> <KEYWORD>null</KEYWORD> <OPERATOR>||</OPERATOR> (max <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD> <OPERATOR>&amp;&amp;</OPERATOR> x<OPERATOR>.</OPERATOR><OO>Value</OO> <OPERATOR>&lt;</OPERATOR> <OBJ>max</OBJ><OPERATOR>.</OPERATOR><OO>Value</OO>))<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Invokes a transform function on each element of a sequence and </DOCCOMMENT>
        <DOCCOMMENT>/// returns the maximum nullable &lt;see cref="System.Double" /&gt; value.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>double</TYPE><OPERATOR>?</OPERATOR> Max<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>double</TYPE><OPERATOR>?&gt;</OPERATOR> selector) 
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Max</OO>()<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the sum of a sequence of nullable &lt;see cref="System.Decimal" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>decimal</TYPE> Sum(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>decimal</TYPE><OPERATOR>&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <TYPE>decimal</TYPE> sum <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> num <KEYWORD>in</KEYWORD> source)
                sum <OPERATOR>=</OPERATOR> <KEYWORD>checked</KEYWORD>(sum <OPERATOR>+</OPERATOR> num)<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> sum<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the sum of a sequence of nullable &lt;see cref="System.Decimal" /&gt; </DOCCOMMENT>
        <DOCCOMMENT>/// values that are obtained by invoking a transform function on </DOCCOMMENT>
        <DOCCOMMENT>/// each element of the input sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>decimal</TYPE> Sum<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>decimal</TYPE><OPERATOR>&gt;</OPERATOR> selector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Sum</OO>()<OPERATOR>;</OPERATOR>
        }
        
        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the average of a sequence of nullable &lt;see cref="System.Decimal" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>decimal</TYPE> Average(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>decimal</TYPE><OPERATOR>&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <TYPE>decimal</TYPE> sum <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
            <TYPE>long</TYPE> count <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>

            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> num <KEYWORD>in</KEYWORD> source)
            <KEYWORD>checked</KEYWORD>
            {
                sum <OPERATOR>+=</OPERATOR> (<TYPE>decimal</TYPE>) num<OPERATOR>;</OPERATOR>
                count<OPERATOR>++;</OPERATOR>
            }

            <KEYWORD>if</KEYWORD> (count <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC>)
                <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> <TYPE>InvalidOperationException</TYPE>()<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> (<TYPE>decimal</TYPE>) sum <OPERATOR>/</OPERATOR> count<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the average of a sequence of nullable &lt;see cref="System.Decimal" /&gt; values </DOCCOMMENT>
        <DOCCOMMENT>/// that are obtained by invoking a transform function on each </DOCCOMMENT>
        <DOCCOMMENT>/// element of the input sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>decimal</TYPE> Average<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>decimal</TYPE><OPERATOR>&gt;</OPERATOR> selector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Average</OO>()<OPERATOR>;</OPERATOR>
        }
        

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the sum of a sequence of &lt;see cref="System.Decimal" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>decimal</TYPE><OPERATOR>?</OPERATOR> Sum(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>decimal</TYPE><OPERATOR>?&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <TYPE>decimal</TYPE> sum <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> num <KEYWORD>in</KEYWORD> source)
                sum <OPERATOR>=</OPERATOR> <KEYWORD>checked</KEYWORD>(sum <OPERATOR>+</OPERATOR> (num <OPERATOR>??</OPERATOR> <NUMERIC>0</NUMERIC>))<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> sum<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the sum of a sequence of &lt;see cref="System.Decimal" /&gt; </DOCCOMMENT>
        <DOCCOMMENT>/// values that are obtained by invoking a transform function on </DOCCOMMENT>
        <DOCCOMMENT>/// each element of the input sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>decimal</TYPE><OPERATOR>?</OPERATOR> Sum<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>decimal</TYPE><OPERATOR>?&gt;</OPERATOR> selector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Sum</OO>()<OPERATOR>;</OPERATOR>
        }
        
        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the average of a sequence of &lt;see cref="System.Decimal" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>decimal</TYPE><OPERATOR>?</OPERATOR> Average(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>decimal</TYPE><OPERATOR>?&gt;</OPERATOR> source)
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>

            <TYPE>decimal</TYPE> sum <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>
            <TYPE>long</TYPE> count <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR>

            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> num <KEYWORD>in</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(n <OPERATOR>=&gt;</OPERATOR> n <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>))
            <KEYWORD>checked</KEYWORD>
            {
                sum <OPERATOR>+=</OPERATOR> (<TYPE>decimal</TYPE>) num<OPERATOR>;</OPERATOR>
                count<OPERATOR>++;</OPERATOR>
            }

            <KEYWORD>if</KEYWORD> (count <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC>)
                <KEYWORD>return</KEYWORD> <KEYWORD>null</KEYWORD><OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> (<TYPE>decimal</TYPE><OPERATOR>?</OPERATOR>) sum <OPERATOR>/</OPERATOR> count<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Computes the average of a sequence of &lt;see cref="System.Decimal" /&gt; values </DOCCOMMENT>
        <DOCCOMMENT>/// that are obtained by invoking a transform function on each </DOCCOMMENT>
        <DOCCOMMENT>/// element of the input sequence.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>decimal</TYPE><OPERATOR>?</OPERATOR> Average<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>decimal</TYPE><OPERATOR>?&gt;</OPERATOR> selector)
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Average</OO>()<OPERATOR>;</OPERATOR>
        }
        
        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the minimum value in a sequence of nullable </DOCCOMMENT>
        <DOCCOMMENT>/// &lt;see cref="System.Decimal" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>decimal</TYPE><OPERATOR>?</OPERATOR> Min(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>decimal</TYPE><OPERATOR>?&gt;</OPERATOR> source) 
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            
            <KEYWORD>return</KEYWORD> MinMaxImpl(<OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(x <OPERATOR>=&gt;</OPERATOR> x <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>)<OPERATOR>,</OPERATOR> <KEYWORD>null</KEYWORD><OPERATOR>,</OPERATOR> (min<OPERATOR>,</OPERATOR> x) <OPERATOR>=&gt;</OPERATOR> min <OPERATOR>&lt;</OPERATOR> x)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Invokes a transform function on each element of a sequence and </DOCCOMMENT>
        <DOCCOMMENT>/// returns the minimum nullable &lt;see cref="System.Decimal" /&gt; value.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>decimal</TYPE><OPERATOR>?</OPERATOR> Min<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>decimal</TYPE><OPERATOR>?&gt;</OPERATOR> selector) 
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Min</OO>()<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns the maximum value in a sequence of nullable </DOCCOMMENT>
        <DOCCOMMENT>/// &lt;see cref="System.Decimal" /&gt; values.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>decimal</TYPE><OPERATOR>?</OPERATOR> Max(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR><TYPE>decimal</TYPE><OPERATOR>?&gt;</OPERATOR> source) 
        {
            CheckNotNull(source<OPERATOR>,</OPERATOR> <STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            
            <KEYWORD>return</KEYWORD> MinMaxImpl(<OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Where</OO>(x <OPERATOR>=&gt;</OPERATOR> x <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD>)<OPERATOR>,</OPERATOR> 
                <KEYWORD>null</KEYWORD><OPERATOR>,</OPERATOR> (max<OPERATOR>,</OPERATOR> x) <OPERATOR>=&gt;</OPERATOR> x <OPERATOR>==</OPERATOR> <KEYWORD>null</KEYWORD> <OPERATOR>||</OPERATOR> (max <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD> <OPERATOR>&amp;&amp;</OPERATOR> x<OPERATOR>.</OPERATOR><OO>Value</OO> <OPERATOR>&lt;</OPERATOR> <OBJ>max</OBJ><OPERATOR>.</OPERATOR><OO>Value</OO>))<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Invokes a transform function on each element of a sequence and </DOCCOMMENT>
        <DOCCOMMENT>/// returns the maximum nullable &lt;see cref="System.Decimal" /&gt; value.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <KEYWORD>static</KEYWORD> <TYPE>decimal</TYPE><OPERATOR>?</OPERATOR> Max<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR>(
            <KEYWORD>this</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>TSource<OPERATOR>,</OPERATOR> <TYPE>decimal</TYPE><OPERATOR>?&gt;</OPERATOR> selector) 
        {
            <KEYWORD>return</KEYWORD> <OBJ>source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(selector)<OPERATOR>.</OPERATOR><OO>Max</OO>()<OPERATOR>;</OPERATOR>
        }
    }
}

<COMMENT>// $Id: ExtensionAttribute.cs 223 2008-11-27 18:09:35Z azizatif $</COMMENT>

<KEYWORD>namespace</KEYWORD> <OBJ>System</OBJ><OPERATOR>.</OPERATOR><OO>Runtime</OO><OPERATOR>.</OPERATOR><OO>CompilerServices</OO>
{
    <DOCCOMMENT>/// &lt;remarks&gt;</DOCCOMMENT>
    <DOCCOMMENT>/// This attribute allows us to define extension methods without </DOCCOMMENT>
    <DOCCOMMENT>/// requiring .NET Framework 3.5. For more information, see the section,</DOCCOMMENT>
    <DOCCOMMENT>/// &lt;a href="http://msdn.microsoft.com/en-us/magazine/cc163317.aspx#S7"&gt;Extension Methods in .NET Framework 2.0 Apps&lt;/a&gt;,</DOCCOMMENT>
    <DOCCOMMENT>/// of &lt;a href="http://msdn.microsoft.com/en-us/magazine/cc163317.aspx"&gt;Basic Instincts: Extension Methods&lt;/a&gt;</DOCCOMMENT>
    <DOCCOMMENT>/// column in &lt;a href="http://msdn.microsoft.com/msdnmag/"&gt;MSDN Magazine&lt;/a&gt;, </DOCCOMMENT>
    <DOCCOMMENT>/// issue &lt;a href="http://msdn.microsoft.com/en-us/magazine/cc135410.aspx"&gt;Nov 2007&lt;/a&gt;.</DOCCOMMENT>
    <DOCCOMMENT>/// &lt;/remarks&gt;</DOCCOMMENT>

    [AttributeUsage(<OBJ>AttributeTargets</OBJ><OPERATOR>.</OPERATOR><OO>Method</OO> <OPERATOR>|</OPERATOR> <OBJ>AttributeTargets</OBJ><OPERATOR>.</OPERATOR><OO>Class</OO> <OPERATOR>|</OPERATOR> <OBJ>AttributeTargets</OBJ><OPERATOR>.</OPERATOR><OO>Assembly</OO>)]
    <KEYWORD>internal</KEYWORD> <KEYWORD>sealed</KEYWORD> <KEYWORD>class</KEYWORD> ExtensionAttribute <OPERATOR>:</OPERATOR> <TYPE>Attribute</TYPE> { }
}

<COMMENT>// $Id: Func.cs 223 2008-11-27 18:09:35Z azizatif $</COMMENT>

<KEYWORD>namespace</KEYWORD> System
{
    <PREPROCESSOR>#region Access modifier</PREPROCESSOR>
    <PREPROCESSOR>#if BACKLINQ_LIB</PREPROCESSOR>
        <KEYWORD>public</KEYWORD> 
    <PREPROCESSOR>#else</PREPROCESSOR>
        <KEYWORD>internal</KEYWORD>
    <PREPROCESSOR>#endif</PREPROCESSOR>
    <PREPROCESSOR>#endregion</PREPROCESSOR>
    
    <KEYWORD>delegate</KEYWORD> TResult Func<OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR>()<OPERATOR>;</OPERATOR>

    <PREPROCESSOR>#region Access modifier</PREPROCESSOR>
    <PREPROCESSOR>#if BACKLINQ_LIB</PREPROCESSOR>
        <KEYWORD>public</KEYWORD> 
    <PREPROCESSOR>#else</PREPROCESSOR>
        <KEYWORD>internal</KEYWORD>
    <PREPROCESSOR>#endif</PREPROCESSOR>
    <PREPROCESSOR>#endregion</PREPROCESSOR>
    
    <KEYWORD>delegate</KEYWORD> TResult Func<OPERATOR>&lt;</OPERATOR>T<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR>(T a)<OPERATOR>;</OPERATOR>
    <PREPROCESSOR>#region Access modifier</PREPROCESSOR>
    <PREPROCESSOR>#if BACKLINQ_LIB</PREPROCESSOR>
        <KEYWORD>public</KEYWORD> 
    <PREPROCESSOR>#else</PREPROCESSOR>
        <KEYWORD>internal</KEYWORD>
    <PREPROCESSOR>#endif</PREPROCESSOR>
    <PREPROCESSOR>#endregion</PREPROCESSOR>
    
    <KEYWORD>delegate</KEYWORD> TResult Func<OPERATOR>&lt;</OPERATOR>T1<OPERATOR>,</OPERATOR> T2<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR>(T1 arg1<OPERATOR>,</OPERATOR> T2 arg2)<OPERATOR>;</OPERATOR>
    <PREPROCESSOR>#region Access modifier</PREPROCESSOR>
    <PREPROCESSOR>#if BACKLINQ_LIB</PREPROCESSOR>
        <KEYWORD>public</KEYWORD> 
    <PREPROCESSOR>#else</PREPROCESSOR>
        <KEYWORD>internal</KEYWORD>
    <PREPROCESSOR>#endif</PREPROCESSOR>
    <PREPROCESSOR>#endregion</PREPROCESSOR>
 
    <KEYWORD>delegate</KEYWORD> TResult Func<OPERATOR>&lt;</OPERATOR>T1<OPERATOR>,</OPERATOR> T2<OPERATOR>,</OPERATOR> T3<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR>(T1 arg1<OPERATOR>,</OPERATOR> T2 arg2<OPERATOR>,</OPERATOR> T3 arg3)<OPERATOR>;</OPERATOR>
    <PREPROCESSOR>#region Access modifier</PREPROCESSOR>
    <PREPROCESSOR>#if BACKLINQ_LIB</PREPROCESSOR>
        <KEYWORD>public</KEYWORD> 
    <PREPROCESSOR>#else</PREPROCESSOR>
        <KEYWORD>internal</KEYWORD>
    <PREPROCESSOR>#endif</PREPROCESSOR>
    <PREPROCESSOR>#endregion</PREPROCESSOR>
    
    <KEYWORD>delegate</KEYWORD> TResult Func<OPERATOR>&lt;</OPERATOR>T1<OPERATOR>,</OPERATOR> T2<OPERATOR>,</OPERATOR> T3<OPERATOR>,</OPERATOR> T4<OPERATOR>,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR>(T1 arg1<OPERATOR>,</OPERATOR> T2 arg2<OPERATOR>,</OPERATOR> T3 arg3<OPERATOR>,</OPERATOR> T4 arg4)<OPERATOR>;</OPERATOR>
}

<COMMENT>// $Id: Grouping.cs 223 2008-11-27 18:09:35Z azizatif $</COMMENT>

<KEYWORD>namespace</KEYWORD> <OBJ>System</OBJ><OPERATOR>.</OPERATOR><OO>Linq</OO>
{
    <PREPROCESSOR>#region Imports</PREPROCESSOR>

    <KEYWORD>using</KEYWORD> <OBJ>System</OBJ><OPERATOR>.</OPERATOR><OO>Collections</OO><OPERATOR>.</OPERATOR><OO>Generic</OO><OPERATOR>;</OPERATOR>

    <PREPROCESSOR>#endregion</PREPROCESSOR>

    <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
    <DOCCOMMENT>/// Represents a collection of objects that have a common key.</DOCCOMMENT>
    <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

    <PREPROCESSOR>#region Access modifier</PREPROCESSOR>
    <PREPROCESSOR>#if BACKLINQ_LIB</PREPROCESSOR>
        <KEYWORD>public</KEYWORD> 
    <PREPROCESSOR>#else</PREPROCESSOR>
        <KEYWORD>internal</KEYWORD>
    <PREPROCESSOR>#endif</PREPROCESSOR>
    <PREPROCESSOR>#endregion</PREPROCESSOR>
    
    <KEYWORD>interface</KEYWORD> IGrouping<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR> <OPERATOR>:</OPERATOR> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TElement<OPERATOR>&gt;</OPERATOR>
    {
        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Gets the key of the &lt;see cref="IGrouping{TKey,TElement}" /&gt;.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        TKey Key { get<OPERATOR>;</OPERATOR> }
    }
}

<COMMENT>// $Id: ILookup.cs 225 2008-11-27 18:15:55Z azizatif $</COMMENT>

<KEYWORD>namespace</KEYWORD> <OBJ>System</OBJ><OPERATOR>.</OPERATOR><OO>Linq</OO>
{
    <KEYWORD>using</KEYWORD> <OBJ>System</OBJ><OPERATOR>.</OPERATOR><OO>Collections</OO><OPERATOR>.</OPERATOR><OO>Generic</OO><OPERATOR>;</OPERATOR>

    <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
    <DOCCOMMENT>/// Defines an indexer, size property, and Boolean search method for </DOCCOMMENT>
    <DOCCOMMENT>/// data structures that map keys to &lt;see cref="IEnumerable{T}"/&gt; </DOCCOMMENT>
    <DOCCOMMENT>/// sequences of values.</DOCCOMMENT>
    <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

    <PREPROCESSOR>#region Access modifier</PREPROCESSOR>
    <PREPROCESSOR>#if BACKLINQ_LIB</PREPROCESSOR>
        <KEYWORD>public</KEYWORD> 
    <PREPROCESSOR>#else</PREPROCESSOR>
        <KEYWORD>internal</KEYWORD>
    <PREPROCESSOR>#endif</PREPROCESSOR>
    <PREPROCESSOR>#endregion</PREPROCESSOR>

    <KEYWORD>interface</KEYWORD> ILookup<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR> <OPERATOR>:</OPERATOR> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>IGrouping<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;&gt;</OPERATOR>
    {
        <TYPE>bool</TYPE> Contains(TKey key)<OPERATOR>;</OPERATOR>
        <TYPE>int</TYPE> Count { get<OPERATOR>;</OPERATOR> }
        <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TElement<OPERATOR>&gt;</OPERATOR> <KEYWORD>this</KEYWORD>[TKey key] { get<OPERATOR>;</OPERATOR> }
    }
}

<COMMENT>// $Id: IOrderedEnumerable.cs 223 2008-11-27 18:09:35Z azizatif $</COMMENT>

<KEYWORD>namespace</KEYWORD> <OBJ>System</OBJ><OPERATOR>.</OPERATOR><OO>Linq</OO>
{
    <KEYWORD>using</KEYWORD> <OBJ>System</OBJ><OPERATOR>.</OPERATOR><OO>Collections</OO><OPERATOR>.</OPERATOR><OO>Generic</OO><OPERATOR>;</OPERATOR>

    <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
    <DOCCOMMENT>/// Represents a sorted sequence.</DOCCOMMENT>
    <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

    <PREPROCESSOR>#region Access modifier</PREPROCESSOR>
    <PREPROCESSOR>#if BACKLINQ_LIB</PREPROCESSOR>
        <KEYWORD>public</KEYWORD> 
    <PREPROCESSOR>#else</PREPROCESSOR>
        <KEYWORD>internal</KEYWORD>
    <PREPROCESSOR>#endif</PREPROCESSOR>
    <PREPROCESSOR>#endregion</PREPROCESSOR>

    <KEYWORD>interface</KEYWORD> IOrderedEnumerable<OPERATOR>&lt;</OPERATOR>TElement<OPERATOR>&gt;</OPERATOR> <OPERATOR>:</OPERATOR> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TElement<OPERATOR>&gt;</OPERATOR>
    {
        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Performs a subsequent ordering on the elements of an </DOCCOMMENT>
        <DOCCOMMENT>/// &lt;see cref="IOrderedEnumerable{T}"/&gt; according to a key.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        IOrderedEnumerable<OPERATOR>&lt;</OPERATOR>TElement<OPERATOR>&gt;</OPERATOR> CreateOrderedEnumerable<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>&gt;</OPERATOR>(
            Func<OPERATOR>&lt;</OPERATOR>TElement<OPERATOR>,</OPERATOR> TKey<OPERATOR>&gt;</OPERATOR> keySelector<OPERATOR>,</OPERATOR> <TYPE>IComparer</TYPE><OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>&gt;</OPERATOR> comparer<OPERATOR>,</OPERATOR> <TYPE>bool</TYPE> descending)<OPERATOR>;</OPERATOR>
    }
}

<COMMENT>// $Id: Lookup.cs 223 2008-11-27 18:09:35Z azizatif $</COMMENT>

<KEYWORD>namespace</KEYWORD> <OBJ>System</OBJ><OPERATOR>.</OPERATOR><OO>Linq</OO>
{
    <PREPROCESSOR>#region Imports</PREPROCESSOR>

    <KEYWORD>using</KEYWORD> System<OPERATOR>;</OPERATOR>
    <KEYWORD>using</KEYWORD> <OBJ>System</OBJ><OPERATOR>.</OPERATOR><OO>Collections</OO><OPERATOR>;</OPERATOR>
    <KEYWORD>using</KEYWORD> <OBJ>System</OBJ><OPERATOR>.</OPERATOR><OO>Collections</OO><OPERATOR>.</OPERATOR><OO>Generic</OO><OPERATOR>;</OPERATOR>
    <KEYWORD>using</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>=</OPERATOR><OBJ>System</OBJ><OPERATOR>.</OPERATOR><OO>Collections</OO><OPERATOR>.</OPERATOR><OO>IEnumerable</OO><OPERATOR>;</OPERATOR>

    <PREPROCESSOR>#endregion</PREPROCESSOR>

    <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
    <DOCCOMMENT>/// Represents a collection of keys each mapped to one or more values.</DOCCOMMENT>
    <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

    <PREPROCESSOR>#region Access modifier</PREPROCESSOR>
    <PREPROCESSOR>#if BACKLINQ_LIB</PREPROCESSOR>
        <KEYWORD>public</KEYWORD> 
    <PREPROCESSOR>#else</PREPROCESSOR>
        <KEYWORD>internal</KEYWORD>
    <PREPROCESSOR>#endif</PREPROCESSOR>
    <PREPROCESSOR>#endregion</PREPROCESSOR>

    <KEYWORD>sealed</KEYWORD> <KEYWORD>class</KEYWORD> Lookup<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR> <OPERATOR>:</OPERATOR> ILookup<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR>
    {
        <KEYWORD>private</KEYWORD> <KEYWORD>readonly</KEYWORD> <TYPE>Dictionary</TYPE><OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> IGrouping<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;&gt;</OPERATOR> _map<OPERATOR>;</OPERATOR>

        <KEYWORD>internal</KEYWORD> Lookup(<TYPE>IEqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>&gt;</OPERATOR> comparer)
        {
            _map <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Dictionary</TYPE><OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> IGrouping<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;&gt;</OPERATOR>(comparer)<OPERATOR>;</OPERATOR>
        }

        <KEYWORD>internal</KEYWORD> <TYPE>void</TYPE> Add(IGrouping<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR> item)
        {
            <OBJ>_map</OBJ><OPERATOR>.</OPERATOR><OO>Add</OO>(<OBJ>item</OBJ><OPERATOR>.</OPERATOR><OO>Key</OO><OPERATOR>,</OPERATOR> item)<OPERATOR>;</OPERATOR>
        }

        <KEYWORD>internal</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TElement<OPERATOR>&gt;</OPERATOR> Find(TKey key)
        {
            IGrouping<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR> grouping<OPERATOR>;</OPERATOR>
            <KEYWORD>return</KEYWORD> <OBJ>_map</OBJ><OPERATOR>.</OPERATOR><OO>TryGetValue</OO>(key<OPERATOR>,</OPERATOR> <KEYWORD>out</KEYWORD> grouping) <OPERATOR>?</OPERATOR> grouping <OPERATOR>:</OPERATOR> <KEYWORD>null</KEYWORD><OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Gets the number of key/value collection pairs in the &lt;see cref="Lookup{TKey,TElement}" /&gt;.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <TYPE>int</TYPE> Count
        {
            get { <KEYWORD>return</KEYWORD> <OBJ>_map</OBJ><OPERATOR>.</OPERATOR><OO>Count</OO><OPERATOR>;</OPERATOR> }
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Gets the collection of values indexed by the specified key.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TElement<OPERATOR>&gt;</OPERATOR> <KEYWORD>this</KEYWORD>[TKey key]
        {
            get
            {
                IGrouping<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;</OPERATOR> result<OPERATOR>;</OPERATOR>
                <KEYWORD>return</KEYWORD> <OBJ>_map</OBJ><OPERATOR>.</OPERATOR><OO>TryGetValue</OO>(key<OPERATOR>,</OPERATOR> <KEYWORD>out</KEYWORD> result) <OPERATOR>?</OPERATOR> result <OPERATOR>:</OPERATOR> <OBJ>Enumerable</OBJ><OPERATOR>.</OPERATOR><OO>Empty</OO><OPERATOR>&lt;</OPERATOR>TElement<OPERATOR>&gt;</OPERATOR>()<OPERATOR>;</OPERATOR>
            }
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Determines whether a specified key is in the &lt;see cref="Lookup{TKey,TElement}" /&gt;.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <TYPE>bool</TYPE> Contains(TKey key)
        {
            <KEYWORD>return</KEYWORD> <OBJ>_map</OBJ><OPERATOR>.</OPERATOR><OO>ContainsKey</OO>(key)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Applies a transform function to each key and its associated </DOCCOMMENT>
        <DOCCOMMENT>/// values and returns the results.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR> ApplyResultSelector<OPERATOR>&lt;</OPERATOR>TResult<OPERATOR>&gt;</OPERATOR>(
            Func<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>TElement<OPERATOR>&gt;,</OPERATOR> TResult<OPERATOR>&gt;</OPERATOR> resultSelector)
        {
            <KEYWORD>if</KEYWORD> (resultSelector <OPERATOR>==</OPERATOR> <KEYWORD>null</KEYWORD>) 
                <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> <TYPE>ArgumentNullException</TYPE>(<STRING>"resultSelector"</STRING>)<OPERATOR>;</OPERATOR>
            
            <KEYWORD>foreach</KEYWORD> (<KEYWORD>var</KEYWORD> pair <KEYWORD>in</KEYWORD> _map)
                <KEYWORD>yield</KEYWORD> <KEYWORD>return</KEYWORD> resultSelector(<OBJ>pair</OBJ><OPERATOR>.</OPERATOR><OO>Key</OO><OPERATOR>,</OPERATOR> <OBJ>pair</OBJ><OPERATOR>.</OPERATOR><OO>Value</OO>)<OPERATOR>;</OPERATOR>
        }

        <DOCCOMMENT>/// &lt;summary&gt;</DOCCOMMENT>
        <DOCCOMMENT>/// Returns a generic enumerator that iterates through the &lt;see cref="Lookup{TKey,TElement}" /&gt;.</DOCCOMMENT>
        <DOCCOMMENT>/// &lt;/summary&gt;</DOCCOMMENT>

        <KEYWORD>public</KEYWORD> <TYPE>IEnumerator</TYPE><OPERATOR>&lt;</OPERATOR>IGrouping<OPERATOR>&lt;</OPERATOR>TKey<OPERATOR>,</OPERATOR> TElement<OPERATOR>&gt;&gt;</OPERATOR> GetEnumerator()
        {
            <KEYWORD>return</KEYWORD> <OBJ>_map</OBJ><OPERATOR>.</OPERATOR><OO>Values</OO><OPERATOR>.</OPERATOR><OO>GetEnumerator</OO>()<OPERATOR>;</OPERATOR>
        }

        <TYPE>IEnumerator</TYPE> <OBJ>IEnumerable</OBJ><OPERATOR>.</OPERATOR><OO>GetEnumerator</OO>()
        {
            <KEYWORD>return</KEYWORD> GetEnumerator()<OPERATOR>;</OPERATOR>
        }
    }
}

<COMMENT>// $Id: OrderedEnumerable.cs 225 2008-11-27 18:15:55Z azizatif $</COMMENT>

<KEYWORD>namespace</KEYWORD> BackLinq
{
    <PREPROCESSOR>#region Imports</PREPROCESSOR>

    <KEYWORD>using</KEYWORD> System<OPERATOR>;</OPERATOR>
    <KEYWORD>using</KEYWORD> <OBJ>System</OBJ><OPERATOR>.</OPERATOR><OO>Collections</OO><OPERATOR>;</OPERATOR>
    <KEYWORD>using</KEYWORD> <OBJ>System</OBJ><OPERATOR>.</OPERATOR><OO>Collections</OO><OPERATOR>.</OPERATOR><OO>Generic</OO><OPERATOR>;</OPERATOR>
    <KEYWORD>using</KEYWORD> <OBJ>System</OBJ><OPERATOR>.</OPERATOR><OO>Linq</OO><OPERATOR>;</OPERATOR>

    <PREPROCESSOR>#endregion</PREPROCESSOR>

    <KEYWORD>internal</KEYWORD> <KEYWORD>sealed</KEYWORD> <KEYWORD>class</KEYWORD> OrderedEnumerable<OPERATOR>&lt;</OPERATOR>T<OPERATOR>,</OPERATOR> K<OPERATOR>&gt;</OPERATOR> <OPERATOR>:</OPERATOR> IOrderedEnumerable<OPERATOR>&lt;</OPERATOR>T<OPERATOR>&gt;</OPERATOR>
    {
        <KEYWORD>private</KEYWORD> <KEYWORD>readonly</KEYWORD> <TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>T<OPERATOR>&gt;</OPERATOR> _source<OPERATOR>;</OPERATOR>
        <KEYWORD>private</KEYWORD> <KEYWORD>readonly</KEYWORD> <TYPE>List</TYPE><OPERATOR>&lt;</OPERATOR>Comparison<OPERATOR>&lt;</OPERATOR>T<OPERATOR>&gt;&gt;</OPERATOR> _comparisons<OPERATOR>;</OPERATOR>

        <KEYWORD>public</KEYWORD> OrderedEnumerable(<TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>T<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR> 
            Func<OPERATOR>&lt;</OPERATOR>T<OPERATOR>,</OPERATOR> K<OPERATOR>&gt;</OPERATOR> keySelector<OPERATOR>,</OPERATOR> <TYPE>IComparer</TYPE><OPERATOR>&lt;</OPERATOR>K<OPERATOR>&gt;</OPERATOR> comparer<OPERATOR>,</OPERATOR> <TYPE>bool</TYPE> descending) <OPERATOR>:</OPERATOR>
            <KEYWORD>this</KEYWORD>(source<OPERATOR>,</OPERATOR> <KEYWORD>null</KEYWORD><OPERATOR>,</OPERATOR> keySelector<OPERATOR>,</OPERATOR> comparer<OPERATOR>,</OPERATOR> descending) {}

        <KEYWORD>private</KEYWORD> OrderedEnumerable(<TYPE>IEnumerable</TYPE><OPERATOR>&lt;</OPERATOR>T<OPERATOR>&gt;</OPERATOR> source<OPERATOR>,</OPERATOR> <TYPE>List</TYPE><OPERATOR>&lt;</OPERATOR>Comparison<OPERATOR>&lt;</OPERATOR>T<OPERATOR>&gt;&gt;</OPERATOR> comparisons<OPERATOR>,</OPERATOR>
            Func<OPERATOR>&lt;</OPERATOR>T<OPERATOR>,</OPERATOR> K<OPERATOR>&gt;</OPERATOR> keySelector<OPERATOR>,</OPERATOR> <TYPE>IComparer</TYPE><OPERATOR>&lt;</OPERATOR>K<OPERATOR>&gt;</OPERATOR> comparer<OPERATOR>,</OPERATOR> <TYPE>bool</TYPE> descending)
        {
            <KEYWORD>if</KEYWORD> (source <OPERATOR>==</OPERATOR> <KEYWORD>null</KEYWORD>) <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> <TYPE>ArgumentNullException</TYPE>(<STRING>"source"</STRING>)<OPERATOR>;</OPERATOR>
            <KEYWORD>if</KEYWORD> (keySelector <OPERATOR>==</OPERATOR> <KEYWORD>null</KEYWORD>) <KEYWORD>throw</KEYWORD> <KEYWORD>new</KEYWORD> <TYPE>ArgumentNullException</TYPE>(<STRING>"keySelector"</STRING>)<OPERATOR>;</OPERATOR>

            _source <OPERATOR>=</OPERATOR> source<OPERATOR>;</OPERATOR>
            
            comparer <OPERATOR>=</OPERATOR> comparer <OPERATOR>??</OPERATOR> <TYPE>Comparer</TYPE><OPERATOR>&lt;</OPERATOR>K<OPERATOR>&gt;.</OPERATOR>Default<OPERATOR>;</OPERATOR>

            <KEYWORD>if</KEYWORD> (comparisons <OPERATOR>==</OPERATOR> <KEYWORD>null</KEYWORD>)
                comparisons <OPERATOR>=</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>List</TYPE><OPERATOR>&lt;</OPERATOR>Comparison<OPERATOR>&lt;</OPERATOR>T<OPERATOR>&gt;&gt;</OPERATOR>(<COMMENT>/* capacity */</COMMENT> <NUMERIC>4</NUMERIC>)<OPERATOR>;</OPERATOR>

            <OBJ>comparisons</OBJ><OPERATOR>.</OPERATOR><OO>Add</OO>((x<OPERATOR>,</OPERATOR> y) 
                <OPERATOR>=&gt;</OPERATOR> (descending <OPERATOR>?</OPERATOR> <OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC> <OPERATOR>:</OPERATOR> <NUMERIC>1</NUMERIC>) <OPERATOR>*</OPERATOR> <OBJ>comparer</OBJ><OPERATOR>.</OPERATOR><OO>Compare</OO>(keySelector(x)<OPERATOR>,</OPERATOR> keySelector(y)))<OPERATOR>;</OPERATOR>

            _comparisons <OPERATOR>=</OPERATOR> comparisons<OPERATOR>;</OPERATOR>
        }

        <KEYWORD>public</KEYWORD> IOrderedEnumerable<OPERATOR>&lt;</OPERATOR>T<OPERATOR>&gt;</OPERATOR> CreateOrderedEnumerable<OPERATOR>&lt;</OPERATOR>KK<OPERATOR>&gt;</OPERATOR>(
            Func<OPERATOR>&lt;</OPERATOR>T<OPERATOR>,</OPERATOR> KK<OPERATOR>&gt;</OPERATOR> keySelector<OPERATOR>,</OPERATOR> <TYPE>IComparer</TYPE><OPERATOR>&lt;</OPERATOR>KK<OPERATOR>&gt;</OPERATOR> comparer<OPERATOR>,</OPERATOR> <TYPE>bool</TYPE> descending)
        {
            <KEYWORD>return</KEYWORD> <KEYWORD>new</KEYWORD> OrderedEnumerable<OPERATOR>&lt;</OPERATOR>T<OPERATOR>,</OPERATOR> KK<OPERATOR>&gt;</OPERATOR>(_source<OPERATOR>,</OPERATOR> _comparisons<OPERATOR>,</OPERATOR> keySelector<OPERATOR>,</OPERATOR> comparer<OPERATOR>,</OPERATOR> descending)<OPERATOR>;</OPERATOR>
        }

        <KEYWORD>public</KEYWORD> <TYPE>IEnumerator</TYPE><OPERATOR>&lt;</OPERATOR>T<OPERATOR>&gt;</OPERATOR> GetEnumerator()
        {
            <COMMENT>//</COMMENT>
            <COMMENT>// We sort using List&lt;T&gt;.Sort, but docs say that it performs an </COMMENT>
            <COMMENT>// unstable sort. LINQ, on the other hand, says OrderBy performs </COMMENT>
            <COMMENT>// a stable sort. So convert the source sequence into a sequence </COMMENT>
            <COMMENT>// of tuples where the second element tags the position of the </COMMENT>
            <COMMENT>// element from the source sequence (First). The position is </COMMENT>
            <COMMENT>// then used as a tie breaker when all keys compare equal,</COMMENT>
            <COMMENT>// thus making the sort stable.</COMMENT>
            <COMMENT>//</COMMENT>

            <KEYWORD>var</KEYWORD> list <OPERATOR>=</OPERATOR> <OBJ>_source</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>((e<OPERATOR>,</OPERATOR> i) <OPERATOR>=&gt;</OPERATOR> <KEYWORD>new</KEYWORD> <TYPE>Tuple</TYPE><OPERATOR>&lt;</OPERATOR>T<OPERATOR>,</OPERATOR> <TYPE>int</TYPE><OPERATOR>&gt;</OPERATOR>(e<OPERATOR>,</OPERATOR> i))<OPERATOR>.</OPERATOR><OO>ToList</OO>()<OPERATOR>;</OPERATOR>
            
            <OBJ>list</OBJ><OPERATOR>.</OPERATOR><OO>Sort</OO>((x<OPERATOR>,</OPERATOR> y) <OPERATOR>=&gt;</OPERATOR> 
            {
                <COMMENT>//</COMMENT>
                <COMMENT>// Compare keys from left to right.</COMMENT>
                <COMMENT>//</COMMENT>

                <KEYWORD>var</KEYWORD> comparisons <OPERATOR>=</OPERATOR> _comparisons<OPERATOR>;</OPERATOR>
                <KEYWORD>for</KEYWORD> (<KEYWORD>var</KEYWORD> i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>;</OPERATOR> i <OPERATOR>&lt;</OPERATOR> <OBJ>comparisons</OBJ><OPERATOR>.</OPERATOR><OO>Count</OO><OPERATOR>;</OPERATOR> i<OPERATOR>++</OPERATOR>)
                {
                    <KEYWORD>var</KEYWORD> result <OPERATOR>=</OPERATOR> comparisons[i](x<OPERATOR>.</OPERATOR><OO>First</OO><OPERATOR>,</OPERATOR> y<OPERATOR>.</OPERATOR><OO>First</OO>)<OPERATOR>;</OPERATOR>
                    <KEYWORD>if</KEYWORD> (result <OPERATOR>!=</OPERATOR> <NUMERIC>0</NUMERIC>)
                        <KEYWORD>return</KEYWORD> result<OPERATOR>;</OPERATOR>
                }

                <COMMENT>//</COMMENT>
                <COMMENT>// All keys compared equal so now break the tie by their</COMMENT>
                <COMMENT>// position in the original sequence, making the sort stable.</COMMENT>
                <COMMENT>//</COMMENT>

                <KEYWORD>return</KEYWORD> x<OPERATOR>.</OPERATOR><OO>Second</OO><OPERATOR>.</OPERATOR><OO>CompareTo</OO>(y<OPERATOR>.</OPERATOR><OO>Second</OO>)<OPERATOR>;</OPERATOR>
            })<OPERATOR>;</OPERATOR>

            <KEYWORD>return</KEYWORD> <OBJ>list</OBJ><OPERATOR>.</OPERATOR><OO>Select</OO>(pv <OPERATOR>=&gt;</OPERATOR> <OBJ>pv</OBJ><OPERATOR>.</OPERATOR><OO>First</OO>)<OPERATOR>.</OPERATOR><OO>GetEnumerator</OO>()<OPERATOR>;</OPERATOR>

        }

        <TYPE>IEnumerator</TYPE> <OBJ>IEnumerable</OBJ><OPERATOR>.</OPERATOR><OO>GetEnumerator</OO>()
        {
            <KEYWORD>return</KEYWORD> GetEnumerator()<OPERATOR>;</OPERATOR>
        }
    }
}

<COMMENT>// $Id: Tuple.cs 223 2008-11-27 18:09:35Z azizatif $</COMMENT>

<KEYWORD>namespace</KEYWORD> BackLinq
{
    <PREPROCESSOR>#region Imports</PREPROCESSOR>

    <KEYWORD>using</KEYWORD> System<OPERATOR>;</OPERATOR>
    <KEYWORD>using</KEYWORD> <OBJ>System</OBJ><OPERATOR>.</OPERATOR><OO>Collections</OO><OPERATOR>.</OPERATOR><OO>Generic</OO><OPERATOR>;</OPERATOR>
    <KEYWORD>using</KEYWORD> <OBJ>System</OBJ><OPERATOR>.</OPERATOR><OO>Text</OO><OPERATOR>;</OPERATOR>

    <PREPROCESSOR>#endregion</PREPROCESSOR>

    [ Serializable ]
    <KEYWORD>internal</KEYWORD> <KEYWORD>struct</KEYWORD> <TYPE>Tuple</TYPE><OPERATOR>&lt;</OPERATOR>TFirst<OPERATOR>,</OPERATOR> TSecond<OPERATOR>&gt;</OPERATOR> <OPERATOR>:</OPERATOR> IEquatable<OPERATOR>&lt;</OPERATOR><TYPE>Tuple</TYPE><OPERATOR>&lt;</OPERATOR>TFirst<OPERATOR>,</OPERATOR> TSecond<OPERATOR>&gt;&gt;</OPERATOR>
    {
        <KEYWORD>public</KEYWORD> TFirst First { get<OPERATOR>;</OPERATOR> <KEYWORD>private</KEYWORD> set<OPERATOR>;</OPERATOR> }
        <KEYWORD>public</KEYWORD> TSecond Second { get<OPERATOR>;</OPERATOR> <KEYWORD>private</KEYWORD> set<OPERATOR>;</OPERATOR> }

        <KEYWORD>public</KEYWORD> <TYPE>Tuple</TYPE>(TFirst first<OPERATOR>,</OPERATOR> TSecond second) <OPERATOR>:</OPERATOR> <KEYWORD>this</KEYWORD>()
        {
            First <OPERATOR>=</OPERATOR> first<OPERATOR>;</OPERATOR>
            Second <OPERATOR>=</OPERATOR> second<OPERATOR>;</OPERATOR>
        }

        <KEYWORD>public</KEYWORD> <KEYWORD>override</KEYWORD> <TYPE>bool</TYPE> Equals(<TYPE>object</TYPE> obj)
        {
            <KEYWORD>return</KEYWORD> obj <OPERATOR>!=</OPERATOR> <KEYWORD>null</KEYWORD> 
                   <OPERATOR>&amp;&amp;</OPERATOR> obj <KEYWORD>is</KEYWORD> <TYPE>Tuple</TYPE><OPERATOR>&lt;</OPERATOR>TFirst<OPERATOR>,</OPERATOR> TSecond<OPERATOR>&gt;</OPERATOR> 
                   <OPERATOR>&amp;&amp;</OPERATOR> <OBJ>base</OBJ><OPERATOR>.</OPERATOR><OO>Equals</OO>((<TYPE>Tuple</TYPE><OPERATOR>&lt;</OPERATOR>TFirst<OPERATOR>,</OPERATOR> TSecond<OPERATOR>&gt;</OPERATOR>) obj)<OPERATOR>;</OPERATOR>
        }

        <KEYWORD>public</KEYWORD> <TYPE>bool</TYPE> Equals(<TYPE>Tuple</TYPE><OPERATOR>&lt;</OPERATOR>TFirst<OPERATOR>,</OPERATOR> TSecond<OPERATOR>&gt;</OPERATOR> other)
        {
            <KEYWORD>return</KEYWORD> <TYPE>EqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TFirst<OPERATOR>&gt;.</OPERATOR><OBJ>Default</OBJ><OPERATOR>.</OPERATOR><OO>Equals</OO>(<OBJ>other</OBJ><OPERATOR>.</OPERATOR><OO>First</OO><OPERATOR>,</OPERATOR> First) 
                   <OPERATOR>&amp;&amp;</OPERATOR> <TYPE>EqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TSecond<OPERATOR>&gt;.</OPERATOR><OBJ>Default</OBJ><OPERATOR>.</OPERATOR><OO>Equals</OO>(<OBJ>other</OBJ><OPERATOR>.</OPERATOR><OO>Second</OO><OPERATOR>,</OPERATOR> Second)<OPERATOR>;</OPERATOR>
        }

        <KEYWORD>public</KEYWORD> <KEYWORD>override</KEYWORD> <TYPE>int</TYPE> GetHashCode()
        {
            <KEYWORD>var</KEYWORD> num <OPERATOR>=</OPERATOR> <NUMERIC>0x7a2f0b42</NUMERIC><OPERATOR>;</OPERATOR>
            num <OPERATOR>=</OPERATOR> (<OPERATOR>-</OPERATOR><NUMERIC>1521134295</NUMERIC> <OPERATOR>*</OPERATOR> num) <OPERATOR>+</OPERATOR> <TYPE>EqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TFirst<OPERATOR>&gt;.</OPERATOR><OBJ>Default</OBJ><OPERATOR>.</OPERATOR><OO>GetHashCode</OO>(First)<OPERATOR>;</OPERATOR>
            <KEYWORD>return</KEYWORD> (<OPERATOR>-</OPERATOR><NUMERIC>1521134295</NUMERIC> <OPERATOR>*</OPERATOR> num) <OPERATOR>+</OPERATOR> <TYPE>EqualityComparer</TYPE><OPERATOR>&lt;</OPERATOR>TSecond<OPERATOR>&gt;.</OPERATOR><OBJ>Default</OBJ><OPERATOR>.</OPERATOR><OO>GetHashCode</OO>(Second)<OPERATOR>;</OPERATOR>
        }

        <KEYWORD>public</KEYWORD> <KEYWORD>override</KEYWORD> <TYPE>string</TYPE> ToString()
        {
            <KEYWORD>return</KEYWORD> <OBJ>string</OBJ><OPERATOR>.</OPERATOR><OO>Format</OO>(@<STRING>"{{ First = {0}, Second = {1} }}"</STRING><OPERATOR>,</OPERATOR> First<OPERATOR>,</OPERATOR> Second)<OPERATOR>;</OPERATOR>
        }
    }
}
