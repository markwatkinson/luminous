<KEYWORD>module</KEYWORD> <TYPE>WS</TYPE><FUNCTION>.</FUNCTION><TYPE>Runtime</TYPE><FUNCTION>.</FUNCTION><TYPE>Xmlable</TYPE> <KEYWORD>where</KEYWORD> 

<KEYWORD>import</KEYWORD> <TYPE>System</TYPE><FUNCTION>.</FUNCTION><TYPE>Locale</TYPE>
<KEYWORD>import</KEYWORD> <TYPE>Data</TYPE><FUNCTION>.</FUNCTION><TYPE>List</TYPE>
<KEYWORD>import</KEYWORD> <KEYWORD>qualified</KEYWORD> <TYPE>Data</TYPE><FUNCTION>.</FUNCTION><TYPE>Map</TYPE> <KEYWORD>as</KEYWORD> <TYPE>Map</TYPE>
<KEYWORD>import</KEYWORD> <TYPE>Data</TYPE><FUNCTION>.</FUNCTION><TYPE>Time</TYPE><FUNCTION>.</FUNCTION><TYPE>LocalTime</TYPE>
<KEYWORD>import</KEYWORD> <TYPE>Data</TYPE><FUNCTION>.</FUNCTION><TYPE>Time</TYPE><FUNCTION>.</FUNCTION><TYPE>Format</TYPE>
<KEYWORD>import</KEYWORD> <TYPE>Data</TYPE><FUNCTION>.</FUNCTION><TYPE>Maybe</TYPE>
<KEYWORD>import</KEYWORD> <TYPE>Data</TYPE><FUNCTION>.</FUNCTION><TYPE>Typeable</TYPE>
<KEYWORD>import</KEYWORD> <TYPE>Data</TYPE><FUNCTION>.</FUNCTION><TYPE>Char</TYPE>
<KEYWORD>import</KEYWORD> <TYPE>Data</TYPE><FUNCTION>.</FUNCTION><TYPE>Function</TYPE>
<KEYWORD>import</KEYWORD> <TYPE>Control</TYPE><FUNCTION>.</FUNCTION><TYPE>Arrow</TYPE>
<KEYWORD>import</KEYWORD> <TYPE>Control</TYPE><FUNCTION>.</FUNCTION><TYPE>Monad</TYPE>
<KEYWORD>import</KEYWORD> <TYPE>Text</TYPE><FUNCTION>.</FUNCTION><TYPE>XML</TYPE><FUNCTION>.</FUNCTION><TYPE>Light</TYPE>
<KEYWORD>import</KEYWORD> <TYPE>Data</TYPE><FUNCTION>.</FUNCTION><TYPE>Ord</TYPE>

mkContent <OPERATOR>::</OPERATOR> <TYPE>Attr</TYPE> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <TYPE>Content</TYPE>
mkContent a <OPERATOR>=</OPERATOR> <TYPE>Elem</TYPE> <TYPE>Element</TYPE> { elName <OPERATOR>=</OPERATOR> attrKey a, elAttribs <OPERATOR>=</OPERATOR> <OPERATOR>[]</OPERATOR>, 
        elContent <OPERATOR>=</OPERATOR> <OPERATOR>[</OPERATOR><TYPE>Text</TYPE> <FUNCTION>$</FUNCTION> <TYPE>CData</TYPE> <TYPE>CDataRaw</TYPE> (attrVal a) <TYPE>Nothing</TYPE><OPERATOR>]</OPERATOR>, elLine <OPERATOR>=</OPERATOR> <TYPE>Nothing</TYPE> }
        
concatAttr <OPERATOR>::</OPERATOR> <OPERATOR>[</OPERATOR>(<OPERATOR>[</OPERATOR><TYPE>Attr</TYPE><OPERATOR>]</OPERATOR>, <OPERATOR>[</OPERATOR><TYPE>Content</TYPE><OPERATOR>]</OPERATOR>)<OPERATOR>]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <OPERATOR>[[</OPERATOR><TYPE>Content</TYPE><OPERATOR>]]</OPERATOR>
concatAttr <OPERATOR>=</OPERATOR> <FUNCTION>map</FUNCTION> (<FUNCTION>uncurry</FUNCTION> (<FUNCTION>++</FUNCTION>) <FUNCTION>.</FUNCTION> first (<FUNCTION>map</FUNCTION> mkContent))
        
sortContent <OPERATOR>::</OPERATOR> <OPERATOR>[</OPERATOR><TYPE>String</TYPE><OPERATOR>]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <OPERATOR>[[</OPERATOR><TYPE>Content</TYPE><OPERATOR>]]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <OPERATOR>[[</OPERATOR><TYPE>Content</TYPE><OPERATOR>]]</OPERATOR>
sortContent ss <OPERATOR>=</OPERATOR> <FUNCTION>map</FUNCTION> (sortBy <FUNCTION>$</FUNCTION> comparing nameIndex) <FUNCTION>.</FUNCTION> <FUNCTION>filter</FUNCTION> (<FUNCTION>not</FUNCTION> <FUNCTION>.</FUNCTION> <FUNCTION>null</FUNCTION>)
    <KEYWORD>where</KEYWORD> 
        nameIndex c <OPERATOR>=</OPERATOR> <KEYWORD>case</KEYWORD> c <KEYWORD>of</KEYWORD>
            <TYPE>Elem</TYPE> e  <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> np e <OPERATOR>`elemIndex`</OPERATOR> ss
            _ <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <TYPE>Nothing</TYPE>
        name <OPERATOR>=</OPERATOR> qName <FUNCTION>.</FUNCTION> elName
        pref <OPERATOR>=</OPERATOR> qPrefix <FUNCTION>.</FUNCTION> elName
        np e 
            <FUNCTION>|</FUNCTION> isNothing <FUNCTION>$</FUNCTION> pref e <OPERATOR>=</OPERATOR> name e
            <FUNCTION>|</FUNCTION> <FUNCTION>otherwise</FUNCTION> <OPERATOR>=</OPERATOR> fromJust (pref e) <FUNCTION>++</FUNCTION> <STRING>":"</STRING> <FUNCTION>++</FUNCTION> name e

<KEYWORD>class</KEYWORD> <TYPE>Typeable</TYPE> a <OPERATOR>=&gt;</OPERATOR> <TYPE>Xmlable</TYPE> a <KEYWORD>where</KEYWORD>
    toContent <OPERATOR>::</OPERATOR> a <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <OPERATOR>[[</OPERATOR><TYPE>Content</TYPE><OPERATOR>]]</OPERATOR>
    fromContent <OPERATOR>::</OPERATOR> <OPERATOR>[[</OPERATOR><TYPE>Content</TYPE><OPERATOR>]]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> a
    toAttrContent <OPERATOR>::</OPERATOR> a <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <OPERATOR>[</OPERATOR>(<OPERATOR>[</OPERATOR><TYPE>Attr</TYPE><OPERATOR>]</OPERATOR>, <OPERATOR>[</OPERATOR><TYPE>Content</TYPE><OPERATOR>]</OPERATOR>)<OPERATOR>]</OPERATOR>
    toAttrContent <OPERATOR>=</OPERATOR> <FUNCTION>map</FUNCTION> ((,) <OPERATOR>[]</OPERATOR>) <FUNCTION>.</FUNCTION> toContent
    fromAttrContent <OPERATOR>::</OPERATOR> <OPERATOR>[</OPERATOR>(<OPERATOR>[</OPERATOR><TYPE>Attr</TYPE><OPERATOR>]</OPERATOR>, <OPERATOR>[</OPERATOR><TYPE>Content</TYPE><OPERATOR>]</OPERATOR>)<OPERATOR>]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> a
    fromAttrContent <OPERATOR>=</OPERATOR> fromContent <FUNCTION>.</FUNCTION> concatAttr
    toContent <OPERATOR>=</OPERATOR> concatAttr <FUNCTION>.</FUNCTION> toAttrContent
    fromContent <OPERATOR>=</OPERATOR> fromAttrContent <FUNCTION>.</FUNCTION> <FUNCTION>map</FUNCTION> ((,) <OPERATOR>[]</OPERATOR>)
    
<KEYWORD>instance</KEYWORD> <TYPE>Xmlable</TYPE> <TYPE>Char</TYPE> <KEYWORD>where</KEYWORD>
    toContent _ <OPERATOR>=</OPERATOR> <OPERATOR>[]</OPERATOR>
    fromContent _ <OPERATOR>=</OPERATOR> <CHARACTER>' '</CHARACTER>
    
<KEYWORD>instance</KEYWORD> <TYPE>Xmlable</TYPE> <TYPE>Bool</TYPE> <KEYWORD>where</KEYWORD>
    toContent b <OPERATOR>=</OPERATOR> <OPERATOR>[[</OPERATOR><TYPE>Text</TYPE> <FUNCTION>$</FUNCTION> <TYPE>CData</TYPE> <TYPE>CDataText</TYPE> (<KEYWORD>if</KEYWORD> b <KEYWORD>then</KEYWORD> <STRING>"true"</STRING> <KEYWORD>else</KEYWORD> <STRING>"false"</STRING>) <TYPE>Nothing</TYPE><OPERATOR>]]</OPERATOR>
    fromContent <OPERATOR>[[</OPERATOR><TYPE>Text</TYPE> (<TYPE>CData</TYPE> <TYPE>CDataText</TYPE> s _)<OPERATOR>]]</OPERATOR> <OPERATOR>=</OPERATOR> s <FUNCTION>==</FUNCTION> <STRING>"true"</STRING>
    fromContent _ <OPERATOR>=</OPERATOR> <FUNCTION>error</FUNCTION> <STRING>"Invalid boolean value in fromContent::(Xmlable Bool)"</STRING>
    
<KEYWORD>instance</KEYWORD> <TYPE>Xmlable</TYPE> <TYPE>LocalTime</TYPE> <KEYWORD>where</KEYWORD>
    toContent t <OPERATOR>=</OPERATOR> <OPERATOR>[[</OPERATOR><TYPE>Text</TYPE> <FUNCTION>$</FUNCTION> <TYPE>CData</TYPE> <TYPE>CDataText</TYPE> (formatTime defaultTimeLocale <STRING>"%FT%X"</STRING> t) <TYPE>Nothing</TYPE><OPERATOR>]]</OPERATOR>
    fromContent <OPERATOR>[[</OPERATOR><TYPE>Text</TYPE> (<TYPE>CData</TYPE> <TYPE>CDataText</TYPE> s _)<OPERATOR>]]</OPERATOR> <OPERATOR>=</OPERATOR> readTime defaultTimeLocale <STRING>"%FT%T"</STRING> <FUNCTION>$</FUNCTION> <OBJ>fst</OBJ><FUNCTION>.</FUNCTION><OO>break</OO> (<FUNCTION>==</FUNCTION><CHARACTER>'.'</CHARACTER>) <FUNCTION>$</FUNCTION> s
    fromContent _ <OPERATOR>=</OPERATOR> <FUNCTION>error</FUNCTION> <STRING>"Invalid LocalTime value in fromContent::(Xmlable LocalTime)"</STRING>

<KEYWORD>instance</KEYWORD> <TYPE>Xmlable</TYPE> a <OPERATOR>=&gt;</OPERATOR> <TYPE>Xmlable</TYPE> (<TYPE>Maybe</TYPE> a) <KEYWORD>where</KEYWORD>
    toContent <TYPE>Nothing</TYPE> <OPERATOR>=</OPERATOR> <OPERATOR>[]</OPERATOR>
    toContent (<TYPE>Just</TYPE> x) <OPERATOR>=</OPERATOR> toContent x
    toAttrContent <TYPE>Nothing</TYPE> <OPERATOR>=</OPERATOR> <OPERATOR>[]</OPERATOR>
    toAttrContent (<TYPE>Just</TYPE> x) <OPERATOR>=</OPERATOR> toAttrContent x
    fromContent <OPERATOR>[]</OPERATOR> <OPERATOR>=</OPERATOR> <TYPE>Nothing</TYPE>
    fromContent cs <OPERATOR>=</OPERATOR> <TYPE>Just</TYPE> (fromContent cs)
    fromAttrContent <OPERATOR>[]</OPERATOR> <OPERATOR>=</OPERATOR> <TYPE>Nothing</TYPE>
    fromAttrContent acs <OPERATOR>=</OPERATOR> <TYPE>Just</TYPE> (fromAttrContent acs)

<KEYWORD>instance</KEYWORD> <TYPE>Xmlable</TYPE> a <OPERATOR>=&gt;</OPERATOR> <TYPE>Xmlable</TYPE> <OPERATOR>[</OPERATOR>a<OPERATOR>]</OPERATOR> <KEYWORD>where</KEYWORD>
    toContent <OPERATOR>[]</OPERATOR> <OPERATOR>=</OPERATOR> <OPERATOR>[]</OPERATOR>
    toContent s <OPERATOR>=</OPERATOR> <KEYWORD>if</KEYWORD> <FUNCTION>show</FUNCTION> (typeOf s) <FUNCTION>==</FUNCTION> <STRING>"[Char]"</STRING> <KEYWORD>then</KEYWORD> <OPERATOR>[[</OPERATOR><TYPE>Text</TYPE> <FUNCTION>$</FUNCTION> <TYPE>CData</TYPE> <TYPE>CDataRaw</TYPE> (fromMaybe <STRING>""</STRING> <FUNCTION>$</FUNCTION> cast s) <TYPE>Nothing</TYPE><OPERATOR>]]</OPERATOR> <KEYWORD>else</KEYWORD> <FUNCTION>concatMap</FUNCTION> toContent s
    fromContent <OPERATOR>[]</OPERATOR> <OPERATOR>=</OPERATOR> <OPERATOR>[]</OPERATOR>
    <COMMENT>-- fromContent [[]] = []</COMMENT>
    fromContent cs <OPERATOR>=</OPERATOR> <KEYWORD>case</KEYWORD> cs <KEYWORD>of</KEYWORD> 
        <OPERATOR>[[</OPERATOR><TYPE>Text</TYPE> (<TYPE>CData</TYPE> _ s _)<OPERATOR>]]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> fromMaybe <OPERATOR>[]</OPERATOR> <FUNCTION>$</FUNCTION> cast s
        _ <FUNCTION>|</FUNCTION> <FUNCTION>show</FUNCTION> (typeOf getList) <FUNCTION>==</FUNCTION> <STRING>"[Char]"</STRING> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> fromMaybe <OPERATOR>[]</OPERATOR> <FUNCTION>$</FUNCTION> cast <FUNCTION>$</FUNCTION> <FUNCTION>concatMap</FUNCTION> showContent <FUNCTION>$</FUNCTION> <FUNCTION>head</FUNCTION> cs
          <FUNCTION>|</FUNCTION> <FUNCTION>otherwise</FUNCTION> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> getList
        <KEYWORD>where</KEYWORD> 
            getList <OPERATOR>=</OPERATOR> <FUNCTION>map</FUNCTION> (<FUNCTION>\x-&gt;fromContent</FUNCTION> <OPERATOR>[</OPERATOR>x<OPERATOR>]</OPERATOR>) cs
    toAttrContent <OPERATOR>[]</OPERATOR> <OPERATOR>=</OPERATOR> <OPERATOR>[]</OPERATOR>
    toAttrContent s <OPERATOR>=</OPERATOR> <KEYWORD>if</KEYWORD> <FUNCTION>show</FUNCTION> (typeOf s) <FUNCTION>==</FUNCTION> <STRING>"[Char]"</STRING> <KEYWORD>then</KEYWORD> <OPERATOR>[</OPERATOR>(<OPERATOR>[]</OPERATOR>, <OPERATOR>[</OPERATOR><TYPE>Text</TYPE> <FUNCTION>$</FUNCTION> <TYPE>CData</TYPE> <TYPE>CDataRaw</TYPE> (fromMaybe <STRING>""</STRING> <FUNCTION>$</FUNCTION> cast s) <TYPE>Nothing</TYPE><OPERATOR>]</OPERATOR>)<OPERATOR>]</OPERATOR> <KEYWORD>else</KEYWORD> <FUNCTION>concatMap</FUNCTION> toAttrContent s
    fromAttrContent <OPERATOR>[]</OPERATOR> <OPERATOR>=</OPERATOR> <OPERATOR>[]</OPERATOR>
    fromAttrContent cs <OPERATOR>=</OPERATOR> <KEYWORD>case</KEYWORD> cs <KEYWORD>of</KEYWORD> 
        <OPERATOR>[</OPERATOR>(<OPERATOR>[]</OPERATOR>,<OPERATOR>[</OPERATOR><TYPE>Text</TYPE> (<TYPE>CData</TYPE> _ s _)<OPERATOR>]</OPERATOR>)<OPERATOR>]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> fromMaybe <OPERATOR>[]</OPERATOR> <FUNCTION>$</FUNCTION> cast s
        _ <FUNCTION>|</FUNCTION> <FUNCTION>show</FUNCTION> (typeOf getList) <FUNCTION>==</FUNCTION> <STRING>"[Char]"</STRING> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> fromMaybe <OPERATOR>[]</OPERATOR> <FUNCTION>$</FUNCTION> cast <FUNCTION>$</FUNCTION> (<FUNCTION>concatMap</FUNCTION> showContent <FUNCTION>$</FUNCTION> <FUNCTION>snd</FUNCTION> <FUNCTION>$</FUNCTION> <FUNCTION>head</FUNCTION> cs) <FUNCTION>++</FUNCTION> (<FUNCTION>concatMap</FUNCTION> attrVal <FUNCTION>$</FUNCTION> <FUNCTION>fst</FUNCTION> <FUNCTION>$</FUNCTION> <FUNCTION>head</FUNCTION> cs)
          <FUNCTION>|</FUNCTION> <FUNCTION>otherwise</FUNCTION> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> getList
        <KEYWORD>where</KEYWORD> 
            getList <OPERATOR>=</OPERATOR> <FUNCTION>map</FUNCTION> (<FUNCTION>\x-&gt;fromAttrContent</FUNCTION> <OPERATOR>[</OPERATOR>x<OPERATOR>]</OPERATOR>) cs
    
        
<KEYWORD>instance</KEYWORD> (<TYPE>Xmlable</TYPE> k, <TYPE>Xmlable</TYPE> a) <OPERATOR>=&gt;</OPERATOR> <TYPE>Xmlable</TYPE> (k, a) <KEYWORD>where</KEYWORD>
    toContent s <OPERATOR>=</OPERATOR> <OPERATOR>[</OPERATOR>makeToContent <OPERATOR>[</OPERATOR><STRING>"fst"</STRING>, <STRING>"snd"</STRING><OPERATOR>]</OPERATOR> <OPERATOR>[</OPERATOR>toContent <FUNCTION>.</FUNCTION> <FUNCTION>fst</FUNCTION>, toContent <FUNCTION>.</FUNCTION> <FUNCTION>snd</FUNCTION><OPERATOR>]</OPERATOR> s<OPERATOR>]</OPERATOR>
    fromContent cs <OPERATOR>=</OPERATOR> (fromContent k, fromContent a)
        <KEYWORD>where</KEYWORD> <OPERATOR>[</OPERATOR>k, a<OPERATOR>]</OPERATOR> <OPERATOR>=</OPERATOR> forFromContent <OPERATOR>[]</OPERATOR> <OPERATOR>[</OPERATOR><STRING>"fst"</STRING>, <STRING>"snd"</STRING><OPERATOR>]</OPERATOR> cs
    toAttrContent s <OPERATOR>=</OPERATOR> <OPERATOR>[</OPERATOR>makeToAttrContent <OPERATOR>[]</OPERATOR> <OPERATOR>[]</OPERATOR> <OPERATOR>[</OPERATOR><STRING>"fst"</STRING>, <STRING>"snd"</STRING><OPERATOR>]</OPERATOR> <OPERATOR>[</OPERATOR>toAttrContent <FUNCTION>.</FUNCTION> <FUNCTION>fst</FUNCTION>, toAttrContent <FUNCTION>.</FUNCTION> <FUNCTION>snd</FUNCTION><OPERATOR>]</OPERATOR> s<OPERATOR>]</OPERATOR>
    fromAttrContent acs <OPERATOR>=</OPERATOR> (fromAttrContent k, fromAttrContent a)
        <KEYWORD>where</KEYWORD> <OPERATOR>[</OPERATOR>k, a<OPERATOR>]</OPERATOR> <OPERATOR>=</OPERATOR> forFromAttrContent <OPERATOR>[]</OPERATOR> <OPERATOR>[</OPERATOR><STRING>"fst"</STRING>, <STRING>"snd"</STRING><OPERATOR>]</OPERATOR> acs

<KEYWORD>instance</KEYWORD> (<TYPE>Xmlable</TYPE> k, <TYPE>Ord</TYPE> k, <TYPE>Xmlable</TYPE> a) <OPERATOR>=&gt;</OPERATOR> <TYPE>Xmlable</TYPE> (<TYPE>Map</TYPE><FUNCTION>.</FUNCTION><TYPE>Map</TYPE> k a) <KEYWORD>where</KEYWORD>
    toContent <OPERATOR>=</OPERATOR> toContent <FUNCTION>.</FUNCTION> <TYPE>Map</TYPE><FUNCTION>.</FUNCTION><OO>toList</OO>
    fromContent <OPERATOR>=</OPERATOR> <TYPE>Map</TYPE><FUNCTION>.</FUNCTION><OO>fromList</OO> <FUNCTION>.</FUNCTION> fromContent
    toAttrContent <OPERATOR>=</OPERATOR> toAttrContent <FUNCTION>.</FUNCTION> <TYPE>Map</TYPE><FUNCTION>.</FUNCTION><OO>toList</OO>
    fromAttrContent <OPERATOR>=</OPERATOR> <TYPE>Map</TYPE><FUNCTION>.</FUNCTION><OO>fromList</OO> <FUNCTION>.</FUNCTION> fromAttrContent

toContentSimple <OPERATOR>::</OPERATOR> (<TYPE>Typeable</TYPE> a, <TYPE>Show</TYPE> a) <OPERATOR>=&gt;</OPERATOR> a <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <OPERATOR>[[</OPERATOR><TYPE>Content</TYPE><OPERATOR>]]</OPERATOR>
toContentSimple x <OPERATOR>=</OPERATOR> <OPERATOR>[[</OPERATOR><TYPE>Text</TYPE> <FUNCTION>$</FUNCTION> <TYPE>CData</TYPE> <TYPE>CDataText</TYPE> (<FUNCTION>show</FUNCTION> x) <TYPE>Nothing</TYPE><OPERATOR>]]</OPERATOR>

fromContentSimple <OPERATOR>::</OPERATOR> (<TYPE>Typeable</TYPE> a, <TYPE>Show</TYPE> a, <TYPE>Read</TYPE> a) <OPERATOR>=&gt;</OPERATOR> <OPERATOR>[[</OPERATOR><TYPE>Content</TYPE><OPERATOR>]]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> a
fromContentSimple <OPERATOR>[[</OPERATOR><TYPE>Text</TYPE> (<TYPE>CData</TYPE> _ s _)<OPERATOR>]]</OPERATOR> <OPERATOR>=</OPERATOR> <FUNCTION>read</FUNCTION> s
fromContentSimple x <OPERATOR>=</OPERATOR> <FUNCTION>error</FUNCTION> <FUNCTION>$</FUNCTION> <FUNCTION>unlines</FUNCTION> <OPERATOR>[</OPERATOR><STRING>"Invalid value in fromContentSimple:"</STRING>, <FUNCTION>show</FUNCTION> x<OPERATOR>]</OPERATOR>

<KEYWORD>instance</KEYWORD> <TYPE>Xmlable</TYPE> <TYPE>Float</TYPE> <KEYWORD>where</KEYWORD>
    toContent <OPERATOR>=</OPERATOR> toContentSimple
    fromContent <OPERATOR>=</OPERATOR> fromContentSimple

<KEYWORD>instance</KEYWORD> <TYPE>Xmlable</TYPE> <TYPE>Integer</TYPE> <KEYWORD>where</KEYWORD>
    toContent <OPERATOR>=</OPERATOR> toContentSimple
    fromContent <OPERATOR>=</OPERATOR> fromContentSimple
     
makeToContent <OPERATOR>::</OPERATOR> (<TYPE>Xmlable</TYPE> t) <OPERATOR>=&gt;</OPERATOR> <OPERATOR>[</OPERATOR><TYPE>String</TYPE><OPERATOR>]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <OPERATOR>[</OPERATOR>t <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <OPERATOR>[[</OPERATOR><TYPE>Content</TYPE><OPERATOR>]]]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> t <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <OPERATOR>[</OPERATOR><TYPE>Content</TYPE><OPERATOR>]</OPERATOR>
makeToContent ss gs x <OPERATOR>=</OPERATOR> <FUNCTION>concat</FUNCTION> <FUNCTION>$</FUNCTION> <FUNCTION>zipWith</FUNCTION> makeToContent' ss gs
    <KEYWORD>where</KEYWORD>
        makeToContent' n g <OPERATOR>=</OPERATOR> <FUNCTION>map</FUNCTION> (<TYPE>Elem</TYPE> <FUNCTION>.</FUNCTION> unode n) (g x)

makeToAttrContent <OPERATOR>::</OPERATOR> (<TYPE>Xmlable</TYPE> t) <OPERATOR>=&gt;</OPERATOR> <OPERATOR>[</OPERATOR><TYPE>String</TYPE><OPERATOR>]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <OPERATOR>[</OPERATOR>t <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <OPERATOR>[</OPERATOR>(<OPERATOR>[</OPERATOR><TYPE>Attr</TYPE><OPERATOR>]</OPERATOR>, <OPERATOR>[</OPERATOR><TYPE>Content</TYPE><OPERATOR>]</OPERATOR>)<OPERATOR>]]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <OPERATOR>[</OPERATOR><TYPE>String</TYPE><OPERATOR>]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <OPERATOR>[</OPERATOR>t <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <OPERATOR>[</OPERATOR>(<OPERATOR>[</OPERATOR><TYPE>Attr</TYPE><OPERATOR>]</OPERATOR>, <OPERATOR>[</OPERATOR><TYPE>Content</TYPE><OPERATOR>]</OPERATOR>)<OPERATOR>]]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> t <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> (<OPERATOR>[</OPERATOR><TYPE>Attr</TYPE><OPERATOR>]</OPERATOR>, <OPERATOR>[</OPERATOR><TYPE>Content</TYPE><OPERATOR>]</OPERATOR>)
makeToAttrContent sas gas scs gcs x <OPERATOR>=</OPERATOR> (catMaybes <FUNCTION>$</FUNCTION> <FUNCTION>zipWith</FUNCTION> mkAttr sas gas, <FUNCTION>concat</FUNCTION> <FUNCTION>$</FUNCTION> <FUNCTION>zipWith</FUNCTION> makeToContent' scs gcs)
    <KEYWORD>where</KEYWORD>
        mkAttr s g <OPERATOR>=</OPERATOR> <KEYWORD>case</KEYWORD> g x <KEYWORD>of</KEYWORD> 
            <OPERATOR>[</OPERATOR>(<OPERATOR>[]</OPERATOR>,<OPERATOR>[</OPERATOR><TYPE>Text</TYPE> (<TYPE>CData</TYPE> _ str _)<OPERATOR>]</OPERATOR>)<OPERATOR>]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <TYPE>Just</TYPE> <FUNCTION>$</FUNCTION> <TYPE>Attr</TYPE> {attrKey <OPERATOR>=</OPERATOR> unqual s, attrVal <OPERATOR>=</OPERATOR> str}
            <OPERATOR>[]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <TYPE>Nothing</TYPE>
            y <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <FUNCTION>error</FUNCTION> <FUNCTION>$</FUNCTION> <FUNCTION>unlines</FUNCTION> <OPERATOR>[</OPERATOR><STRING>"Content of attribute is not a Text:"</STRING>, <FUNCTION>show</FUNCTION> y<OPERATOR>]</OPERATOR>
        makeToContent' n g <OPERATOR>=</OPERATOR> <FUNCTION>map</FUNCTION> (<TYPE>Elem</TYPE> <FUNCTION>.</FUNCTION> unode n) (g x)
        
getPrefName <OPERATOR>::</OPERATOR> <TYPE>String</TYPE> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> (<TYPE>String</TYPE>, <TYPE>String</TYPE>)
getPrefName n 
    <FUNCTION>|</FUNCTION> <CHARACTER>':'</CHARACTER> <OPERATOR>`elem`</OPERATOR> n <OPERATOR>=</OPERATOR> <FUNCTION>break</FUNCTION> (<FUNCTION>==</FUNCTION><CHARACTER>':'</CHARACTER>) <FUNCTION>&gt;&gt;</FUNCTION><FUNCTION>&gt;</FUNCTION> second (<FUNCTION>dropWhile</FUNCTION> (<OPERATOR>`elem`</OPERATOR> <STRING>":/"</STRING>)) <FUNCTION>$</FUNCTION> n
    <FUNCTION>|</FUNCTION> <FUNCTION>otherwise</FUNCTION> <OPERATOR>=</OPERATOR> (<STRING>""</STRING>, n)
    
forFromContent <OPERATOR>::</OPERATOR> <OPERATOR>[</OPERATOR>(<TYPE>String</TYPE>, <TYPE>String</TYPE>)<OPERATOR>]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <OPERATOR>[</OPERATOR><TYPE>String</TYPE><OPERATOR>]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <OPERATOR>[[</OPERATOR><TYPE>Content</TYPE><OPERATOR>]]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <OPERATOR>[[[</OPERATOR><TYPE>Content</TYPE><OPERATOR>]]]</OPERATOR>
forFromContent nss ss <OPERATOR>=</OPERATOR> <FUNCTION>map</FUNCTION> (<FUNCTION>map</FUNCTION> <FUNCTION>snd</FUNCTION>) <FUNCTION>.</FUNCTION> forFromContentAC nss ss

forFromContentAC <OPERATOR>::</OPERATOR> <OPERATOR>[</OPERATOR>(<TYPE>String</TYPE>, <TYPE>String</TYPE>)<OPERATOR>]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <OPERATOR>[</OPERATOR><TYPE>String</TYPE><OPERATOR>]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <OPERATOR>[[</OPERATOR><TYPE>Content</TYPE><OPERATOR>]]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <OPERATOR>[[</OPERATOR>(<OPERATOR>[</OPERATOR><TYPE>Attr</TYPE><OPERATOR>]</OPERATOR>, <OPERATOR>[</OPERATOR><TYPE>Content</TYPE><OPERATOR>]</OPERATOR>)<OPERATOR>]]</OPERATOR>
forFromContentAC _ ss <OPERATOR>[]</OPERATOR> <OPERATOR>=</OPERATOR> <FUNCTION>error</FUNCTION> <FUNCTION>$</FUNCTION> <FUNCTION>unlines</FUNCTION> <OPERATOR>[</OPERATOR><STRING>"forFromContentAC: Content is empty. Fields are: "</STRING>, <FUNCTION>show</FUNCTION> ss<OPERATOR>]</OPERATOR>
forFromContentAC nss ss x <OPERATOR>=</OPERATOR> pairs ss <FUNCTION>.</FUNCTION> groupBy ((<FUNCTION>==</FUNCTION>) <OPERATOR>`on`</OPERATOR> nam) <FUNCTION>.</FUNCTION> changePrefixInElems <FUNCTION>.</FUNCTION> onlyElems <FUNCTION>.</FUNCTION> <FUNCTION>head</FUNCTION> <FUNCTION>$</FUNCTION> x
    <KEYWORD>where</KEYWORD>
        pairs names <OPERATOR>[]</OPERATOR> <OPERATOR>=</OPERATOR> <FUNCTION>map</FUNCTION> (<FUNCTION>const</FUNCTION> <OPERATOR>[]</OPERATOR>) names
        pairs (n<OPERATOR>:</OPERATOR>ns) ccs<OPERATOR>@</OPERATOR>(c<OPERATOR>:</OPERATOR>cs)
            <FUNCTION>|</FUNCTION> <FUNCTION>null</FUNCTION> c <OPERATOR>=</OPERATOR> <FUNCTION>error</FUNCTION> <STRING>"forFromContentAC: head of [[Content]] is empty"</STRING>
            <FUNCTION>|</FUNCTION> nam (<FUNCTION>head</FUNCTION> c) <FUNCTION>==</FUNCTION> getPrefName n <OPERATOR>=</OPERATOR> <FUNCTION>map</FUNCTION> (elAttribs <FUNCTION>&amp;&amp;</FUNCTION><OPERATOR>&amp;</OPERATOR> elContent) c <OPERATOR>:</OPERATOR> pairs ns cs
            <FUNCTION>|</FUNCTION> <FUNCTION>otherwise</FUNCTION> <OPERATOR>=</OPERATOR> <OPERATOR>[]</OPERATOR> <OPERATOR>:</OPERATOR> pairs ns ccs
        pairs names ccs <OPERATOR>=</OPERATOR> <FUNCTION>error</FUNCTION> (<STRING>"forFromContentAC: Invalid pairs parameters: <ESC>\n</ESC>"</STRING> <FUNCTION>++</FUNCTION> <FUNCTION>show</FUNCTION> names <FUNCTION>++</FUNCTION> <STRING>"<ESC>\n</ESC>"</STRING> <FUNCTION>++</FUNCTION> <FUNCTION>show</FUNCTION> ccs)
        changePrefixInElems <OPERATOR>=</OPERATOR> <FUNCTION>map</FUNCTION> (<FUNCTION>\e</FUNCTION> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> 
                e { elName <OPERATOR>=</OPERATOR> (elName e) { qPrefix <OPERATOR>=</OPERATOR> liftM <FUNCTION>fst</FUNCTION> <FUNCTION>$</FUNCTION> qURI (elName e) <FUNCTION>&gt;&gt;=</FUNCTION> <FUNCTION>flip</FUNCTION> find nss <FUNCTION>.</FUNCTION> (<FUNCTION>snd</FUNCTION> <FUNCTION>&gt;&gt;</FUNCTION><FUNCTION>&gt;</FUNCTION>) <FUNCTION>.</FUNCTION> (<FUNCTION>==</FUNCTION>) } })
        nam <OPERATOR>=</OPERATOR> elName <FUNCTION>&gt;&gt;</FUNCTION><FUNCTION>&gt;</FUNCTION> (qPrefix <FUNCTION>&gt;&gt;</FUNCTION><FUNCTION>&gt;</FUNCTION> fromMaybe <STRING>""</STRING>) <FUNCTION>&amp;&amp;</FUNCTION><OPERATOR>&amp;</OPERATOR> qName

forFromAttrContent <OPERATOR>::</OPERATOR> <OPERATOR>[</OPERATOR>(<TYPE>String</TYPE>, <TYPE>String</TYPE>)<OPERATOR>]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <OPERATOR>[</OPERATOR><TYPE>String</TYPE><OPERATOR>]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <OPERATOR>[</OPERATOR>(<OPERATOR>[</OPERATOR><TYPE>Attr</TYPE><OPERATOR>]</OPERATOR>, <OPERATOR>[</OPERATOR><TYPE>Content</TYPE><OPERATOR>]</OPERATOR>)<OPERATOR>]</OPERATOR> <FUNCTION>-</FUNCTION><FUNCTION>&gt;</FUNCTION> <OPERATOR>[[</OPERATOR>(<OPERATOR>[</OPERATOR><TYPE>Attr</TYPE><OPERATOR>]</OPERATOR>, <OPERATOR>[</OPERATOR><TYPE>Content</TYPE><OPERATOR>]</OPERATOR>)<OPERATOR>]]</OPERATOR>
forFromAttrContent nss ss <OPERATOR>=</OPERATOR> forFromContentAC nss ss <FUNCTION>.</FUNCTION> sortContent ss <FUNCTION>.</FUNCTION> concatAttr