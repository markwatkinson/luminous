<COMMENT>#!/usr/bin/env python</COMMENT>
<COMMENT># -*- coding: utf-8 -*-</COMMENT>
<COMMENT>"""</COMMENT>
<COMMENT>    huffman.py: Calculates a Huffman coding scheme for a given code</COMMENT>
<COMMENT>    </COMMENT>
<COMMENT>    Copyright (C) 2007 Mark Watkinson</COMMENT>
<COMMENT></COMMENT>
<COMMENT>    This program is free software: you can redistribute it and/or modify</COMMENT>
<COMMENT>    it under the terms of the GNU General Public License as published by</COMMENT>
<COMMENT>    the Free Software Foundation, either version 3 of the License, or</COMMENT>
<COMMENT>    (at your option) any later version.</COMMENT>
<COMMENT></COMMENT>
<COMMENT>    This program is distributed in the hope that it will be useful,</COMMENT>
<COMMENT>    but WITHOUT ANY WARRANTY; without even the implied warranty of</COMMENT>
<COMMENT>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</COMMENT>
<COMMENT>    GNU General Public License for more details.</COMMENT>
<COMMENT></COMMENT>
<COMMENT>    You should have received a copy of the GNU General Public License</COMMENT>
<COMMENT>    along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.</COMMENT>
<COMMENT>"""</COMMENT>    

<COMMENT>""" </COMMENT>
<COMMENT>  Example usage:</COMMENT>
<COMMENT>  ./huffman.py a 15 b 7 c 6 d 6 e 5</COMMENT>
<COMMENT>  a : 0</COMMENT>
<COMMENT>  e : 100</COMMENT>
<COMMENT>  c : 101</COMMENT>
<COMMENT>  d : 110</COMMENT>
<COMMENT>  b : 111</COMMENT>
<COMMENT>  average 2.231 bits per symbol</COMMENT>
<COMMENT>"""</COMMENT>




<KEYWORD>import</KEYWORD> <USER_FUNCTION>sys</USER_FUNCTION>


<COMMENT># builds the binary tree. </COMMENT>
<COMMENT># symbols_to_freqs is a dictionary mapping symbol names to relative frequencies,</COMMENT>
<COMMENT># which should be normalsed such that they all add up to 1.</COMMENT>
<COMMENT># Returns the tree's root node. Each node is:</COMMENT>
<COMMENT># (</COMMENT>
<COMMENT>#  node's symbol ( | None if is a parent), </COMMENT>
<COMMENT>#  total frequency of children,</COMMENT>
<COMMENT>#  childnode1 | None,</COMMENT>
<COMMENT>#  childnode2 | None,</COMMENT>
<COMMENT># )</COMMENT>
<COMMENT># where childnodes are the same structure.</COMMENT>
<KEYWORD>def</KEYWORD> <USER_FUNCTION>build_tree</USER_FUNCTION><OPERATOR>(</OPERATOR>symbols_to_freqs<OPERATOR>)</OPERATOR><OPERATOR>:</OPERATOR>
  
  <COMMENT>#alphabet = list of: (symbol, relative freq)</COMMENT>
  alphabet <OPERATOR>=</OPERATOR> <OPERATOR>[</OPERATOR> <OPERATOR>(</OPERATOR>symbol<OPERATOR>,</OPERATOR> symbols_to_freqs<OPERATOR>[</OPERATOR>symbol<OPERATOR>]</OPERATOR><OPERATOR>)</OPERATOR> <KEYWORD>for</KEYWORD> symbol <KEYWORD>in</KEYWORD> <OBJ>symbols_to_freqs</OBJ><OPERATOR>.</OPERATOR><OO>keys</OO><OPERATOR>(</OPERATOR><OPERATOR>)</OPERATOR> <OPERATOR>]</OPERATOR>
  
  sign <OPERATOR>=</OPERATOR> <KEYWORD>lambda</KEYWORD> x<OPERATOR>:</OPERATOR> <OPERATOR>-</OPERATOR><NUMERIC>1</NUMERIC> <KEYWORD>if</KEYWORD> x<OPERATOR>&lt;</OPERATOR><NUMERIC>0</NUMERIC> <KEYWORD>else</KEYWORD> <OPERATOR>(</OPERATOR><NUMERIC>1</NUMERIC> <KEYWORD>if</KEYWORD> x<OPERATOR>&gt;</OPERATOR><NUMERIC>0</NUMERIC> <KEYWORD>else</KEYWORD> <NUMERIC>0</NUMERIC><OPERATOR>)</OPERATOR>
  <OBJ>alphabet</OBJ><OPERATOR>.</OPERATOR><OO>sort</OO><OPERATOR>(</OPERATOR> <KEYWORD>lambda</KEYWORD> a<OPERATOR>,</OPERATOR> b<OPERATOR>:</OPERATOR> sign<OPERATOR>(</OPERATOR>a<OPERATOR>[</OPERATOR><NUMERIC>1</NUMERIC><OPERATOR>]</OPERATOR> <OPERATOR>-</OPERATOR> b<OPERATOR>[</OPERATOR><NUMERIC>1</NUMERIC><OPERATOR>]</OPERATOR><OPERATOR>)</OPERATOR><OPERATOR>)</OPERATOR>
  <OBJ>alphabet</OBJ><OPERATOR>.</OPERATOR><OO>reverse</OO><OPERATOR>(</OPERATOR><OPERATOR>)</OPERATOR>
  <COMMENT># tree = list of (symbol, relative freq, child1, child2</COMMENT>
  tree <OPERATOR>=</OPERATOR> <OPERATOR>[</OPERATOR> <OPERATOR>(</OPERATOR>symbol<OPERATOR>,</OPERATOR> freq<OPERATOR>,</OPERATOR> <VALUE>None</VALUE><OPERATOR>,</OPERATOR> <VALUE>None</VALUE><OPERATOR>)</OPERATOR> <KEYWORD>for</KEYWORD> symbol<OPERATOR>,</OPERATOR> freq <KEYWORD>in</KEYWORD> alphabet<OPERATOR>]</OPERATOR>

  <KEYWORD>while</KEYWORD> <FUNCTION>len</FUNCTION><OPERATOR>(</OPERATOR>tree<OPERATOR>)</OPERATOR> <OPERATOR>&gt;</OPERATOR> <NUMERIC>1</NUMERIC><OPERATOR>:</OPERATOR>
    <COMMENT># pop the two lowest probability nodes </COMMENT>
    <COMMENT># and amalgamate them to form a parent.</COMMENT>
    node1 <OPERATOR>=</OPERATOR> <OBJ>tree</OBJ><OPERATOR>.</OPERATOR><OO>pop</OO><OPERATOR>(</OPERATOR><OPERATOR>)</OPERATOR>
    node2 <OPERATOR>=</OPERATOR> <OBJ>tree</OBJ><OPERATOR>.</OPERATOR><OO>pop</OO><OPERATOR>(</OPERATOR><OPERATOR>)</OPERATOR>
    
    sym1<OPERATOR>,</OPERATOR> freq1<OPERATOR>,</OPERATOR> dummy<OPERATOR>,</OPERATOR> dummy2 <OPERATOR>=</OPERATOR> node1
    sym2<OPERATOR>,</OPERATOR> freq2<OPERATOR>,</OPERATOR> dummy3<OPERATOR>,</OPERATOR> dummy4 <OPERATOR>=</OPERATOR> node2
    
    <COMMENT>#node 3 is the parent.</COMMENT>
    freq3 <OPERATOR>=</OPERATOR> freq1 <OPERATOR>+</OPERATOR> freq2
    
    node3 <OPERATOR>=</OPERATOR> <OPERATOR>(</OPERATOR><VALUE>None</VALUE><OPERATOR>,</OPERATOR> freq3<OPERATOR>,</OPERATOR> node1<OPERATOR>,</OPERATOR> node2<OPERATOR>)</OPERATOR>
    <COMMENT># now put it back on the tree.</COMMENT>
    <OBJ>tree</OBJ><OPERATOR>.</OPERATOR><OO>append</OO><OPERATOR>(</OPERATOR>node3<OPERATOR>)</OPERATOR>  
    <OBJ>tree</OBJ><OPERATOR>.</OPERATOR><OO>sort</OO><OPERATOR>(</OPERATOR><KEYWORD>lambda</KEYWORD> a<OPERATOR>,</OPERATOR> b<OPERATOR>:</OPERATOR> sign<OPERATOR>(</OPERATOR>a<OPERATOR>[</OPERATOR><NUMERIC>1</NUMERIC><OPERATOR>]</OPERATOR> <OPERATOR>-</OPERATOR> b<OPERATOR>[</OPERATOR><NUMERIC>1</NUMERIC><OPERATOR>]</OPERATOR><OPERATOR>)</OPERATOR><OPERATOR>)</OPERATOR>
    <OBJ>tree</OBJ><OPERATOR>.</OPERATOR><OO>reverse</OO><OPERATOR>(</OPERATOR><OPERATOR>)</OPERATOR>  

  <KEYWORD>return</KEYWORD> tree<OPERATOR>[</OPERATOR><NUMERIC>0</NUMERIC><OPERATOR>]</OPERATOR>


<COMMENT># recurses the tree to build a huffman code</COMMENT>
<COMMENT># returns code as a list of (symbol, binary string)</COMMENT>
<KEYWORD>def</KEYWORD> <USER_FUNCTION>build_symbols</USER_FUNCTION><OPERATOR>(</OPERATOR>node<OPERATOR>,</OPERATOR> sym_string <OPERATOR>=</OPERATOR> <STRING>""</STRING><OPERATOR>)</OPERATOR><OPERATOR>:</OPERATOR>
  c<OPERATOR>,</OPERATOR> f<OPERATOR>,</OPERATOR> n1<OPERATOR>,</OPERATOR> n2 <OPERATOR>=</OPERATOR> node
  <COMMENT># base case</COMMENT>
  code <OPERATOR>=</OPERATOR> <OPERATOR>[</OPERATOR><OPERATOR>]</OPERATOR>
  <KEYWORD>if</KEYWORD> n1 <KEYWORD>is</KEYWORD> <VALUE>None</VALUE> <KEYWORD>and</KEYWORD> n2 <KEYWORD>is</KEYWORD> <VALUE>None</VALUE><OPERATOR>:</OPERATOR>
    code <OPERATOR>+=</OPERATOR>  <OPERATOR>[</OPERATOR><OPERATOR>(</OPERATOR>c<OPERATOR>,</OPERATOR> sym_string<OPERATOR>)</OPERATOR><OPERATOR>]</OPERATOR> 
  
  <KEYWORD>if</KEYWORD> n1 <KEYWORD>is</KEYWORD> <KEYWORD>not</KEYWORD> <VALUE>None</VALUE><OPERATOR>:</OPERATOR>
     code <OPERATOR>+=</OPERATOR> <FUNCTION>build_symbols</FUNCTION><OPERATOR>(</OPERATOR>n1<OPERATOR>,</OPERATOR> sym_string <OPERATOR>+</OPERATOR> <STRING>"0"</STRING><OPERATOR>)</OPERATOR>
  
  <KEYWORD>if</KEYWORD> n2 <KEYWORD>is</KEYWORD> <KEYWORD>not</KEYWORD> <VALUE>None</VALUE><OPERATOR>:</OPERATOR>
    code <OPERATOR>+=</OPERATOR> <FUNCTION>build_symbols</FUNCTION><OPERATOR>(</OPERATOR>n2<OPERATOR>,</OPERATOR> sym_string <OPERATOR>+</OPERATOR> <STRING>"1"</STRING><OPERATOR>)</OPERATOR>
    
  <KEYWORD>return</KEYWORD> code
    
<KEYWORD>def</KEYWORD> <USER_FUNCTION>main</USER_FUNCTION><OPERATOR>(</OPERATOR><OPERATOR>)</OPERATOR><OPERATOR>:</OPERATOR>
  <KEYWORD>if</KEYWORD> <STRING>"--help"</STRING> <KEYWORD>in</KEYWORD> <OBJ>sys</OBJ><OPERATOR>.</OPERATOR><OO>argv</OO> <KEYWORD>or</KEYWORD> <FUNCTION>len</FUNCTION><OPERATOR>(</OPERATOR><OBJ>sys</OBJ><OPERATOR>.</OPERATOR><OO>argv</OO><OPERATOR>)</OPERATOR> <OPERATOR>==</OPERATOR> <NUMERIC>1</NUMERIC><OPERATOR>:</OPERATOR>
    <KEYWORD>print</KEYWORD> <STRING>"Usage:"</STRING><OPERATOR>,</OPERATOR> <OBJ>sys</OBJ><OPERATOR>.</OPERATOR><OO>argv</OO><OPERATOR>[</OPERATOR><NUMERIC>0</NUMERIC><OPERATOR>]</OPERATOR><OPERATOR>,</OPERATOR>  <STRING>"symbol_1 freq_1 symbol_2 freq_1 ... symbol_n freq_n"</STRING>
    <OBJ>sys</OBJ><OPERATOR>.</OPERATOR><OO>exit</OO><OPERATOR>(</OPERATOR><OPERATOR>)</OPERATOR>   
  
  <COMMENT># Parse arguments</COMMENT>
  symbols <OPERATOR>=</OPERATOR> <OBJ>sys</OBJ><OPERATOR>.</OPERATOR><OO>argv</OO><OPERATOR>[</OPERATOR><NUMERIC>1</NUMERIC><OPERATOR>:</OPERATOR><OPERATOR>:</OPERATOR><NUMERIC>2</NUMERIC><OPERATOR>]</OPERATOR>  
  freqs <OPERATOR>=</OPERATOR> <OPERATOR>[</OPERATOR><FUNCTION>float</FUNCTION><OPERATOR>(</OPERATOR>x<OPERATOR>)</OPERATOR> <KEYWORD>for</KEYWORD> x <KEYWORD>in</KEYWORD> <OBJ>sys</OBJ><OPERATOR>.</OPERATOR><OO>argv</OO><OPERATOR>[</OPERATOR><NUMERIC>2</NUMERIC><OPERATOR>:</OPERATOR><OPERATOR>:</OPERATOR><NUMERIC>2</NUMERIC><OPERATOR>]</OPERATOR><OPERATOR>]</OPERATOR>
  <COMMENT># convert freqs to relative freqs</COMMENT>
  total <OPERATOR>=</OPERATOR> <FUNCTION>sum</FUNCTION><OPERATOR>(</OPERATOR>freqs<OPERATOR>)</OPERATOR>
  freqs <OPERATOR>=</OPERATOR> <OPERATOR>[</OPERATOR>x/total <KEYWORD>for</KEYWORD> x <KEYWORD>in</KEYWORD> freqs<OPERATOR>]</OPERATOR>
  
  <COMMENT># set up the symbol =&gt; frequency lookup dictionary</COMMENT>
  symbols_to_freqs <OPERATOR>=</OPERATOR> <OPERATOR>{</OPERATOR><OPERATOR>}</OPERATOR>
  <KEYWORD>for</KEYWORD> sym<OPERATOR>,</OPERATOR> freq <KEYWORD>in</KEYWORD> <FUNCTION>zip</FUNCTION><OPERATOR>(</OPERATOR>symbols<OPERATOR>,</OPERATOR> freqs<OPERATOR>)</OPERATOR><OPERATOR>:</OPERATOR>
    symbols_to_freqs<OPERATOR>[</OPERATOR>sym<OPERATOR>]</OPERATOR> <OPERATOR>=</OPERATOR> freq
    
  <COMMENT># build the tree</COMMENT>
  tree <OPERATOR>=</OPERATOR> <FUNCTION>build_tree</FUNCTION><OPERATOR>(</OPERATOR>symbols_to_freqs<OPERATOR>)</OPERATOR>
  <COMMENT># recurse to build a huffman code</COMMENT>
  code <OPERATOR>=</OPERATOR> <FUNCTION>build_symbols</FUNCTION><OPERATOR>(</OPERATOR>tree<OPERATOR>)</OPERATOR>    
  
  <COMMENT>#sort by bit length</COMMENT>
  <OBJ>code</OBJ><OPERATOR>.</OPERATOR><OO>sort</OO><OPERATOR>(</OPERATOR> <KEYWORD>lambda</KEYWORD> a<OPERATOR>,</OPERATOR>b<OPERATOR>:</OPERATOR> <FUNCTION>len</FUNCTION><OPERATOR>(</OPERATOR>a<OPERATOR>[</OPERATOR><NUMERIC>1</NUMERIC><OPERATOR>]</OPERATOR><OPERATOR>)</OPERATOR> <OPERATOR>-</OPERATOR> <FUNCTION>len</FUNCTION><OPERATOR>(</OPERATOR>b<OPERATOR>[</OPERATOR><NUMERIC>1</NUMERIC><OPERATOR>]</OPERATOR><OPERATOR>)</OPERATOR> <OPERATOR>)</OPERATOR>
  <COMMENT>#calculate average symbol length</COMMENT>
  avg_bits <OPERATOR>=</OPERATOR> <FUNCTION>sum</FUNCTION><OPERATOR>(</OPERATOR> <OPERATOR>[</OPERATOR><FUNCTION>len</FUNCTION><OPERATOR>(</OPERATOR>binary_code<OPERATOR>)</OPERATOR><OPERATOR>*</OPERATOR>symbols_to_freqs<OPERATOR>[</OPERATOR>symbol<OPERATOR>]</OPERATOR> <KEYWORD>for</KEYWORD> symbol<OPERATOR>,</OPERATOR> binary_code <KEYWORD>in</KEYWORD> code<OPERATOR>]</OPERATOR> <OPERATOR>)</OPERATOR>

  <KEYWORD>print</KEYWORD> <STRING>"<ESC>\n</ESC>"</STRING><OPERATOR>.</OPERATOR><OO>join</OO><OPERATOR>(</OPERATOR> <OPERATOR>[</OPERATOR>symbol <OPERATOR>+</OPERATOR> <STRING>" : "</STRING> <OPERATOR>+</OPERATOR> binary_code <KEYWORD>for</KEYWORD> symbol<OPERATOR>,</OPERATOR> binary_code <KEYWORD>in</KEYWORD> code<OPERATOR>]</OPERATOR> <OPERATOR>)</OPERATOR>
  <KEYWORD>print</KEYWORD> <STRING>"average"</STRING><OPERATOR>,</OPERATOR> <FUNCTION>round</FUNCTION><OPERATOR>(</OPERATOR>avg_bits<OPERATOR>,</OPERATOR> <NUMERIC>3</NUMERIC><OPERATOR>)</OPERATOR> <OPERATOR>,</OPERATOR> <STRING>"bits per symbol"</STRING>

  
<KEYWORD>if</KEYWORD> __name__ <OPERATOR>==</OPERATOR> <STRING>"__main__"</STRING><OPERATOR>:</OPERATOR>
  <FUNCTION>main</FUNCTION><OPERATOR>(</OPERATOR><OPERATOR>)</OPERATOR>