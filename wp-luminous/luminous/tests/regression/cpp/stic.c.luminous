<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC.C -- New, complete, hopefully fast STIC implementation.            */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>

<PREPROCESSOR>#include <STRING>"config.h"</STRING></PREPROCESSOR>
<PREPROCESSOR>#include <STRING>"periph/periph.h"</STRING></PREPROCESSOR>
<PREPROCESSOR>#include <STRING>"mem/mem.h"</STRING></PREPROCESSOR>
<PREPROCESSOR>#include <STRING>"cp1600/cp1600.h"</STRING></PREPROCESSOR>
<PREPROCESSOR>#include <STRING>"demo/demo.h"</STRING></PREPROCESSOR>
<PREPROCESSOR>#include <STRING>"gfx/gfx.h"</STRING></PREPROCESSOR>
<PREPROCESSOR>#include <STRING>"stic.h"</STRING></PREPROCESSOR>
<PREPROCESSOR>#include <STRING>"speed/speed.h"</STRING></PREPROCESSOR>
<PREPROCESSOR>#include <STRING>"debug/debug_.h"</STRING></PREPROCESSOR>


<KEYWORD>static</KEYWORD> <KEYWORD>const</KEYWORD> <TYPE>char</TYPE> rcs_id[] <CONSTANT>UNUSED</CONSTANT> <OPERATOR>=</OPERATOR> <STRING>"$Id$"</STRING>;

<CONSTANT>LOCAL</CONSTANT> <TYPE>void</TYPE> stic_draw_fgbg(stic_t <OPERATOR>*</OPERATOR>stic);
<CONSTANT>LOCAL</CONSTANT> <TYPE>void</TYPE> stic_draw_cstk(stic_t <OPERATOR>*</OPERATOR>stic);


<PREPROCESSOR>#ifdef __GNUC__</PREPROCESSOR>
<PREPROCESSOR>#define ALIGN __attribute__((aligned(128)))</PREPROCESSOR>
<PREPROCESSOR>#else</PREPROCESSOR>
<PREPROCESSOR>#define ALIGN </PREPROCESSOR>
<PREPROCESSOR>#endif</PREPROCESSOR>

<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC Register Masks                                                     */</COMMENT>
<COMMENT>/*  Only certain bits in each STIC register are writeable.  The bits that   */</COMMENT>
<COMMENT>/*  are not implemented return a fixed pattern of 0s and 1s.  The table     */</COMMENT>
<COMMENT>/*  below encodes this information in the form of an "AND / OR" mask pair.  */</COMMENT>
<COMMENT>/*  The data is first ANDed with the AND mask.  This mask effectively       */</COMMENT>
<COMMENT>/*  indicates the implemented bits.  The data is then ORed with the OR      */</COMMENT>
<COMMENT>/*  mask.  This second mask effectively indicates which of the bits always  */</COMMENT>
<COMMENT>/*  read as 1.                                                              */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
<TYPE>struct</TYPE> stic_reg_mask_t
{
    uint_32 and_mask;
    uint_32 or_mask;
};

<CONSTANT>LOCAL</CONSTANT> <KEYWORD>const</KEYWORD> <TYPE>struct</TYPE> stic_reg_mask_t stic_reg_mask[<NUMERIC>0x40</NUMERIC>] <CONSTANT>ALIGN</CONSTANT> <OPERATOR>=</OPERATOR>
{
    <COMMENT>/* MOB X Registers                                  0x00 - 0x07 */</COMMENT>
    {<NUMERIC>0x07FF</NUMERIC>,<NUMERIC>0x3800</NUMERIC>}, {<NUMERIC>0x07FF</NUMERIC>,<NUMERIC>0x3800</NUMERIC>}, {<NUMERIC>0x07FF</NUMERIC>,<NUMERIC>0x3800</NUMERIC>}, {<NUMERIC>0x07FF</NUMERIC>,<NUMERIC>0x3800</NUMERIC>},
    {<NUMERIC>0x07FF</NUMERIC>,<NUMERIC>0x3800</NUMERIC>}, {<NUMERIC>0x07FF</NUMERIC>,<NUMERIC>0x3800</NUMERIC>}, {<NUMERIC>0x07FF</NUMERIC>,<NUMERIC>0x3800</NUMERIC>}, {<NUMERIC>0x07FF</NUMERIC>,<NUMERIC>0x3800</NUMERIC>},

    <COMMENT>/* MOB Y Registers                                  0x08 - 0x0F */</COMMENT>
    {<NUMERIC>0x0FFF</NUMERIC>,<NUMERIC>0x3000</NUMERIC>}, {<NUMERIC>0x0FFF</NUMERIC>,<NUMERIC>0x3000</NUMERIC>}, {<NUMERIC>0x0FFF</NUMERIC>,<NUMERIC>0x3000</NUMERIC>}, {<NUMERIC>0x0FFF</NUMERIC>,<NUMERIC>0x3000</NUMERIC>},
    {<NUMERIC>0x0FFF</NUMERIC>,<NUMERIC>0x3000</NUMERIC>}, {<NUMERIC>0x0FFF</NUMERIC>,<NUMERIC>0x3000</NUMERIC>}, {<NUMERIC>0x0FFF</NUMERIC>,<NUMERIC>0x3000</NUMERIC>}, {<NUMERIC>0x0FFF</NUMERIC>,<NUMERIC>0x3000</NUMERIC>},

    <COMMENT>/* MOB A Registers                                  0x10 - 0x17 */</COMMENT>
    {<NUMERIC>0x3FFF</NUMERIC>,<NUMERIC>0x0000</NUMERIC>}, {<NUMERIC>0x3FFF</NUMERIC>,<NUMERIC>0x0000</NUMERIC>}, {<NUMERIC>0x3FFF</NUMERIC>,<NUMERIC>0x0000</NUMERIC>}, {<NUMERIC>0x3FFF</NUMERIC>,<NUMERIC>0x0000</NUMERIC>},
    {<NUMERIC>0x3FFF</NUMERIC>,<NUMERIC>0x0000</NUMERIC>}, {<NUMERIC>0x3FFF</NUMERIC>,<NUMERIC>0x0000</NUMERIC>}, {<NUMERIC>0x3FFF</NUMERIC>,<NUMERIC>0x0000</NUMERIC>}, {<NUMERIC>0x3FFF</NUMERIC>,<NUMERIC>0x0000</NUMERIC>},

    <COMMENT>/* MOB C Registers                                  0x18 - 0x1F */</COMMENT>
    {<NUMERIC>0x03FE</NUMERIC>,<NUMERIC>0x3C00</NUMERIC>}, {<NUMERIC>0x03FD</NUMERIC>,<NUMERIC>0x3C00</NUMERIC>}, {<NUMERIC>0x03FB</NUMERIC>,<NUMERIC>0x3C00</NUMERIC>}, {<NUMERIC>0x03F7</NUMERIC>,<NUMERIC>0x3C00</NUMERIC>},
    {<NUMERIC>0x03EF</NUMERIC>,<NUMERIC>0x3C00</NUMERIC>}, {<NUMERIC>0x03DF</NUMERIC>,<NUMERIC>0x3C00</NUMERIC>}, {<NUMERIC>0x03BF</NUMERIC>,<NUMERIC>0x3C00</NUMERIC>}, {<NUMERIC>0x037F</NUMERIC>,<NUMERIC>0x3C00</NUMERIC>},

    <COMMENT>/* Display enable, Mode select                      0x20 - 0x21 */</COMMENT>
    {<NUMERIC>0x0000</NUMERIC>,<NUMERIC>0x3FFF</NUMERIC>}, {<NUMERIC>0x0000</NUMERIC>,<NUMERIC>0x3FFF</NUMERIC>}, 

    <COMMENT>/* Unimplemented registers                          0x22 - 0x27 */</COMMENT>
    {<NUMERIC>0x0000</NUMERIC>,<NUMERIC>0x3FFF</NUMERIC>}, {<NUMERIC>0x0000</NUMERIC>,<NUMERIC>0x3FFF</NUMERIC>}, {<NUMERIC>0x0000</NUMERIC>,<NUMERIC>0x3FFF</NUMERIC>}, {<NUMERIC>0x0000</NUMERIC>,<NUMERIC>0x3FFF</NUMERIC>},
    {<NUMERIC>0x0000</NUMERIC>,<NUMERIC>0x3FFF</NUMERIC>}, {<NUMERIC>0x0000</NUMERIC>,<NUMERIC>0x3FFF</NUMERIC>},

    <COMMENT>/* Color stack, border color                        0x28 - 0x2C */</COMMENT>
    {<NUMERIC>0x000F</NUMERIC>,<NUMERIC>0x3FF0</NUMERIC>}, {<NUMERIC>0x000F</NUMERIC>,<NUMERIC>0x3FF0</NUMERIC>}, {<NUMERIC>0x000F</NUMERIC>,<NUMERIC>0x3FF0</NUMERIC>}, {<NUMERIC>0x000F</NUMERIC>,<NUMERIC>0x3FF0</NUMERIC>}, 
    {<NUMERIC>0x000F</NUMERIC>,<NUMERIC>0x3FF0</NUMERIC>}, 

    <COMMENT>/* Unimplemented registers                          0x2D - 0x2F */</COMMENT>
    {<NUMERIC>0x0000</NUMERIC>,<NUMERIC>0x3FFF</NUMERIC>}, {<NUMERIC>0x0000</NUMERIC>,<NUMERIC>0x3FFF</NUMERIC>}, {<NUMERIC>0x0000</NUMERIC>,<NUMERIC>0x3FFF</NUMERIC>},

    <COMMENT>/* Horiz delay, vertical delay, border extension    0x30 - 0x32 */</COMMENT>
    {<NUMERIC>0x0007</NUMERIC>,<NUMERIC>0x3FF8</NUMERIC>}, {<NUMERIC>0x0007</NUMERIC>,<NUMERIC>0x3FF8</NUMERIC>}, {<NUMERIC>0x0003</NUMERIC>,<NUMERIC>0x3FFC</NUMERIC>},

    <COMMENT>/* Unimplemented registers                          0x33 - 0x3F */</COMMENT>
    {<NUMERIC>0x0000</NUMERIC>,<NUMERIC>0x3FFF</NUMERIC>},
    {<NUMERIC>0x0000</NUMERIC>,<NUMERIC>0x3FFF</NUMERIC>}, {<NUMERIC>0x0000</NUMERIC>,<NUMERIC>0x3FFF</NUMERIC>}, {<NUMERIC>0x0000</NUMERIC>,<NUMERIC>0x3FFF</NUMERIC>}, {<NUMERIC>0x0000</NUMERIC>,<NUMERIC>0x3FFF</NUMERIC>},
    {<NUMERIC>0x0000</NUMERIC>,<NUMERIC>0x3FFF</NUMERIC>}, {<NUMERIC>0x0000</NUMERIC>,<NUMERIC>0x3FFF</NUMERIC>}, {<NUMERIC>0x0000</NUMERIC>,<NUMERIC>0x3FFF</NUMERIC>}, {<NUMERIC>0x0000</NUMERIC>,<NUMERIC>0x3FFF</NUMERIC>},
    {<NUMERIC>0x0000</NUMERIC>,<NUMERIC>0x3FFF</NUMERIC>}, {<NUMERIC>0x0000</NUMERIC>,<NUMERIC>0x3FFF</NUMERIC>}, {<NUMERIC>0x0000</NUMERIC>,<NUMERIC>0x3FFF</NUMERIC>}, {<NUMERIC>0x0000</NUMERIC>,<NUMERIC>0x3FFF</NUMERIC>}
};

<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  MOB height secret decoder ring.                                         */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
<CONSTANT>LOCAL</CONSTANT> <KEYWORD>const</KEYWORD> <TYPE>int</TYPE> stic_mob_hgt[<NUMERIC>8</NUMERIC>] <OPERATOR>=</OPERATOR> { <NUMERIC>8</NUMERIC>, <NUMERIC>16</NUMERIC>, <NUMERIC>16</NUMERIC>, <NUMERIC>32</NUMERIC>, <NUMERIC>32</NUMERIC>, <NUMERIC>64</NUMERIC>, <NUMERIC>64</NUMERIC>, <NUMERIC>128</NUMERIC> };

<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC Color Nibble Masks -- For generating packed-nibble pixels.         */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
<CONSTANT>LOCAL</CONSTANT> <KEYWORD>const</KEYWORD> uint_32 stic_color_mask[<NUMERIC>16</NUMERIC>] <CONSTANT>ALIGN</CONSTANT> <OPERATOR>=</OPERATOR>
{
    <NUMERIC>0x00000000</NUMERIC>, <NUMERIC>0x11111111</NUMERIC>, <NUMERIC>0x22222222</NUMERIC>, <NUMERIC>0x33333333</NUMERIC>,
    <NUMERIC>0x44444444</NUMERIC>, <NUMERIC>0x55555555</NUMERIC>, <NUMERIC>0x66666666</NUMERIC>, <NUMERIC>0x77777777</NUMERIC>,
    <NUMERIC>0x88888888</NUMERIC>, <NUMERIC>0x99999999</NUMERIC>, <NUMERIC>0xAAAAAAAA</NUMERIC>, <NUMERIC>0xBBBBBBBB</NUMERIC>,
    <NUMERIC>0xCCCCCCCC</NUMERIC>, <NUMERIC>0xDDDDDDDD</NUMERIC>, <NUMERIC>0xEEEEEEEE</NUMERIC>, <NUMERIC>0xFFFFFFFF</NUMERIC>
};

<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC Color Mask and Bit Manipulation Lookup Tables                      */</COMMENT>
<COMMENT>/*   -- b2n expands 8 bits to 8 nibbles.                                    */</COMMENT>
<COMMENT>/*   -- b2n_d expands 8 bits to 4 nibbles, pixel-doubling as it goes.       */</COMMENT>
<COMMENT>/*   -- b2n_r expands 8 bits to 4 nibbles, reversing bit order as it goes.  */</COMMENT>
<COMMENT>/*   -- b2n_rd expands 8 bits to 4 nibbles, reversing and pixel-doubleling. */</COMMENT>
<COMMENT>/*   -- n2b expands 2 nibbles to 2 bytes.                                   */</COMMENT>
<COMMENT>/*   -- bit_r reverses the bit order in an 8-bit byte.                      */</COMMENT>
<COMMENT>/*   -- bit_d doubles the bits in an 8-bit byte to a 16-bit int.            */</COMMENT>
<COMMENT>/*   -- bit_rd doubles the bits and reverses them.                          */</COMMENT>
<COMMENT>/*  These are computed at runtime for now.                                  */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
<CONSTANT>LOCAL</CONSTANT> uint_16 stic_n2b  [<NUMERIC>256</NUMERIC>] <CONSTANT>ALIGN</CONSTANT>;
<CONSTANT>LOCAL</CONSTANT> uint_32 stic_b2n  [<NUMERIC>256</NUMERIC>] <CONSTANT>ALIGN</CONSTANT>, stic_b2n_r [<NUMERIC>256</NUMERIC>] <CONSTANT>ALIGN</CONSTANT>; 
<CONSTANT>LOCAL</CONSTANT> uint_32 stic_b2n_d[<NUMERIC>16</NUMERIC>]  <CONSTANT>ALIGN</CONSTANT>, stic_b2n_rd[<NUMERIC>16</NUMERIC>]  <CONSTANT>ALIGN</CONSTANT>; 
<CONSTANT>LOCAL</CONSTANT> uint_16 stic_bit  [<NUMERIC>256</NUMERIC>] <CONSTANT>ALIGN</CONSTANT>, stic_bit_r [<NUMERIC>256</NUMERIC>] <CONSTANT>ALIGN</CONSTANT>;
<CONSTANT>LOCAL</CONSTANT> uint_16 stic_bit_d[<NUMERIC>256</NUMERIC>] <CONSTANT>ALIGN</CONSTANT>, stic_bit_rd[<NUMERIC>256</NUMERIC>] <CONSTANT>ALIGN</CONSTANT>;


<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC_CTRL_RD -- Read from a STIC control register (addr &lt;= 0x3F)        */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
uint_32 stic_ctrl_rd(periph_t <OPERATOR>*</OPERATOR>per, periph_t <OPERATOR>*</OPERATOR>req, uint_32 addr, uint_32 data)
{
    stic_t <OPERATOR>*</OPERATOR>stic <OPERATOR>=</OPERATOR> (stic_t <OPERATOR>*</OPERATOR>)<OBJ>per</OBJ><OPERATOR>-&gt;</OPERATOR><OO>parent</OO>;
    uint_64 access_time <OPERATOR>=</OPERATOR> req <OPERATOR>&amp;&amp;</OPERATOR> <OBJ>req</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req</OO> <OPERATOR>?</OPERATOR> <OBJ>req</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req</OO><OPERATOR>-&gt;</OPERATOR><OO>now</OO> <OPERATOR>+</OPERATOR> <NUMERIC>4</NUMERIC> <OPERATOR>:</OPERATOR> <NUMERIC>0</NUMERIC>;

    (<TYPE>void</TYPE>)data;

<PREPROCESSOR>#if 1</PREPROCESSOR>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Is this access after the Bus-Copy -&gt; Bus-Isolation transition       */</COMMENT>
    <COMMENT>/*  or before the Bus-Isolation -&gt; Bus-Copy transition?                 */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>if</KEYWORD> (access_time <OPERATOR>&gt;</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>stic_accessible</OO> <OPERATOR>||</OPERATOR>
        access_time <OPERATOR>&lt;</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>intak</OO>)
    {
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  Yes:  Return garbage.                                           */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <KEYWORD>return</KEYWORD> addr <OPERATOR>&lt;</OPERATOR> <NUMERIC>0x80</NUMERIC> <OPERATOR>?</OPERATOR> <NUMERIC>0x000E</NUMERIC> <OPERATOR>&amp;</OPERATOR> addr <OPERATOR>:</OPERATOR> <NUMERIC>0xFFFF</NUMERIC>;
    }
<PREPROCESSOR>#endif</PREPROCESSOR>

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  If reading location 0x21, put the display into Color-Stack mode.    */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>if</KEYWORD> ((addr <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x7F</NUMERIC>) <OPERATOR>==</OPERATOR> <NUMERIC>0x0021</NUMERIC>)
    {
        <KEYWORD>if</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mode</OO> <OPERATOR>!=</OPERATOR> <NUMERIC>0</NUMERIC>) <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>bt_dirty</OO> <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC>;
        <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mode</OO> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
<COMMENT>//jzp_printf("COLORSTACK\n");</COMMENT>
        <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>upd</OO>  <OPERATOR>=</OPERATOR> stic_draw_cstk;
    }

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  If we're accessing a STIC CR alias, just return 0xFFFF.             */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>if</KEYWORD> (addr <OPERATOR>&gt;=</OPERATOR> <NUMERIC>0x4000</NUMERIC>)
        <KEYWORD>return</KEYWORD> <NUMERIC>0xFFFF</NUMERIC>;

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  If we're reading 0x40-0x7F, just sample GRAM and return.            */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>if</KEYWORD> (addr <OPERATOR>&gt;=</OPERATOR> <NUMERIC>0x0040</NUMERIC>)
        <KEYWORD>return</KEYWORD> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gmem</OO>[addr <OPERATOR>+</OPERATOR> <NUMERIC>0x800</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xFF</NUMERIC>;

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Now just return the raw value from our internal register file,      */</COMMENT>
    <COMMENT>/*  appropriately conditioned by the read/write masks.                  */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>return</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[addr] <OPERATOR>&amp;</OPERATOR> stic_reg_mask[addr]<OPERATOR>.</OPERATOR><OO>and_mask</OO>) <OPERATOR>|</OPERATOR>
            stic_reg_mask[addr]<OPERATOR>.</OPERATOR><OO>or_mask</OO>;
}

<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC_CTRL_PEEK -- Like read, except w/out side effects or restrictions  */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
uint_32 stic_ctrl_peek(periph_t <OPERATOR>*</OPERATOR>per, periph_t <OPERATOR>*</OPERATOR>req, uint_32 addr, uint_32 data)
{
    stic_t <OPERATOR>*</OPERATOR>stic <OPERATOR>=</OPERATOR> (stic_t <OPERATOR>*</OPERATOR>)<OBJ>per</OBJ><OPERATOR>-&gt;</OPERATOR><OO>parent</OO>;

    (<TYPE>void</TYPE>)req;
    (<TYPE>void</TYPE>)data;

    <KEYWORD>if</KEYWORD> (addr <OPERATOR>&gt;</OPERATOR> <NUMERIC>0x40</NUMERIC>)
        <KEYWORD>return</KEYWORD> <NUMERIC>0xFFFF</NUMERIC>;

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Just return the raw value from our internal register file,          */</COMMENT>
    <COMMENT>/*  appropriately conditioned by the read/write masks.                  */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>return</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[addr] <OPERATOR>&amp;</OPERATOR> stic_reg_mask[addr]<OPERATOR>.</OPERATOR><OO>and_mask</OO>) <OPERATOR>|</OPERATOR>
            stic_reg_mask[addr]<OPERATOR>.</OPERATOR><OO>or_mask</OO>;
}

<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC_CTRL_WR -- Write to a STIC control register (addr &lt;= 0x3F)         */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
<TYPE>void</TYPE> stic_ctrl_wr(periph_t <OPERATOR>*</OPERATOR>per, periph_t <OPERATOR>*</OPERATOR>req, uint_32 addr, uint_32 data)
{
    stic_t <OPERATOR>*</OPERATOR>stic <OPERATOR>=</OPERATOR> (stic_t <OPERATOR>*</OPERATOR>)<OBJ>per</OBJ><OPERATOR>-&gt;</OPERATOR><OO>parent</OO>;
    uint_64 access_time <OPERATOR>=</OPERATOR> req <OPERATOR>&amp;&amp;</OPERATOR> <OBJ>req</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req</OO> <OPERATOR>?</OPERATOR> <OBJ>req</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req</OO><OPERATOR>-&gt;</OPERATOR><OO>now</OO> <OPERATOR>+</OPERATOR> <NUMERIC>4</NUMERIC> <OPERATOR>:</OPERATOR> <NUMERIC>0</NUMERIC>;
    uint_32 old <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;

    addr <OPERATOR>&amp;=</OPERATOR> <NUMERIC>0x7F</NUMERIC>;

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Ignore writes to the strange GROM visibility window at $40 and up.  */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>if</KEYWORD> (addr <OPERATOR>&gt;=</OPERATOR> <NUMERIC>0x40</NUMERIC>)
        <KEYWORD>return</KEYWORD>;

<PREPROCESSOR>#if 1</PREPROCESSOR>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Is this access after the Bus-Copy -&gt; Bus-Isolation transition       */</COMMENT>
    <COMMENT>/*  or before the Bus-Isolation -&gt; Bus-Copy transition?                 */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>if</KEYWORD> (access_time <OPERATOR>&gt;</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>stic_accessible</OO> <OPERATOR>||</OPERATOR> 
        access_time <OPERATOR>&lt;</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>intak</OO>)
    {
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  Yes:  Drop the write.                                           */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
<COMMENT>//jzp_printf("access_time = %llu  accessible = %llu  intak = %llu\n", access_time, stic-&gt;stic_accessible, stic-&gt;req_bus-&gt;intak);</COMMENT>
        <KEYWORD>return</KEYWORD>;
    }
<PREPROCESSOR>#endif</PREPROCESSOR>

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  If writing location 0x20, enable the display.                       */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>if</KEYWORD> (addr <OPERATOR>==</OPERATOR> <NUMERIC>0x0020</NUMERIC>)
    {
<COMMENT>//jzp_printf("got ve post, stic-&gt;phase = %d\n", stic-&gt;phase);</COMMENT>
        <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>ve_post</OO> <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC>;
    }

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  If writing location 0x21, put the display into FGBG mode.           */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>if</KEYWORD> (addr <OPERATOR>==</OPERATOR> <NUMERIC>0x0021</NUMERIC>)
    {
        <KEYWORD>if</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mode</OO> <OPERATOR>!=</OPERATOR> <NUMERIC>1</NUMERIC>) <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>bt_dirty</OO> <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC>;
        <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mode</OO> <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC>;
<COMMENT>//jzp_printf("FOREGROUND/BACKGROUND\n");</COMMENT>
        <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>upd</OO>  <OPERATOR>=</OPERATOR> stic_draw_fgbg;
    }

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Now capture the write and store it in its raw, encoded form (after  */</COMMENT>
    <COMMENT>/*  adjusting for the and/or masks).  If the old != new, mark the frame */</COMMENT>
    <COMMENT>/*  as 'dirty'.                                                         */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    old  <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[addr];
    data <OPERATOR>&amp;=</OPERATOR> stic_reg_mask[addr]<OPERATOR>.</OPERATOR><OO>and_mask</OO>;
    data <OPERATOR>|=</OPERATOR> stic_reg_mask[addr]<OPERATOR>.</OPERATOR><OO>or_mask</OO>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[addr] <OPERATOR>=</OPERATOR> data;

    <KEYWORD>if</KEYWORD> (old <OPERATOR>!=</OPERATOR> data)
    {
        <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>bt_dirty</OO> <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC>;
        <KEYWORD>if</KEYWORD> (addr <OPERATOR>==</OPERATOR> <NUMERIC>0x2C</NUMERIC>)
        {
            gfx_set_bord(<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gfx</OO>, data <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xF</NUMERIC>);
        }
    }
}

<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC_RESET   -- Reset state internal to the STIC                        */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
<TYPE>void</TYPE> stic_reset(periph_t <OPERATOR>*</OPERATOR>per)
{
    stic_t <OPERATOR>*</OPERATOR>stic <OPERATOR>=</OPERATOR> (stic_t<OPERATOR>*</OPERATOR>)<OBJ>per</OBJ><OPERATOR>-&gt;</OPERATOR><OO>parent</OO>;
    <TYPE>int</TYPE> a;

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Fill all the STIC registers with 1.                                 */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <FUNCTION>memset</FUNCTION>(<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>, <NUMERIC>0</NUMERIC>, <KEYWORD>sizeof</KEYWORD>(<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>));  <COMMENT>/* first, zero it */</COMMENT>
    <COMMENT>/* then fill it with 1s via ctrl writes */</COMMENT>
    <KEYWORD>for</KEYWORD> (a <OPERATOR>=</OPERATOR> <NUMERIC>0x00</NUMERIC>; a <OPERATOR>&lt;</OPERATOR> <NUMERIC>0x40</NUMERIC>; a<OPERATOR>++</OPERATOR>)
    {
        <KEYWORD>if</KEYWORD> (a <OPERATOR>!=</OPERATOR> <NUMERIC>0x20</NUMERIC>)
            stic_ctrl_wr(per, <OBJ>per</OBJ><OPERATOR>-&gt;</OPERATOR><OO>parent</OO>, a, <NUMERIC>0xFFFF</NUMERIC>);
    }

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Resync the internal state machine.                                  */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>fifo_ptr</OO>        <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>stic_accessible</OO> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gmem_accessible</OO> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>intak</OO>  <OPERATOR>=</OPERATOR> <OPERATOR>~</OPERATOR><NUMERIC>0ULL</NUMERIC>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>next_busrq</OO> <OPERATOR>=</OPERATOR> <OPERATOR>~</OPERATOR><NUMERIC>0ULL</NUMERIC>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>next_intrq</OO> <OPERATOR>=</OPERATOR> <OPERATOR>~</OPERATOR><NUMERIC>0ULL</NUMERIC>;
    <COMMENT>/*</COMMENT>
<COMMENT>    stic-&gt;stic_cr.min_tick = 1;</COMMENT>
<COMMENT>    stic-&gt;stic_cr.max_tick = phase_len;</COMMENT>
<COMMENT>    stic-&gt;next_phase      += phase_len;</COMMENT>
<COMMENT>    stic-&gt;phase            = new_phase;</COMMENT>
<COMMENT>    */</COMMENT>
}


<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC_BTAB_WR -- Capture writes to the background cards.                 */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
<TYPE>void</TYPE> stic_btab_wr(periph_t <OPERATOR>*</OPERATOR>per, periph_t <OPERATOR>*</OPERATOR>req, uint_32 addr, uint_32 data)
{
    stic_t <OPERATOR>*</OPERATOR>stic <OPERATOR>=</OPERATOR> (stic_t<OPERATOR>*</OPERATOR>)<OBJ>per</OBJ><OPERATOR>-&gt;</OPERATOR><OO>parent</OO>;

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Note -- this architecture has problems if I want to accurately      */</COMMENT>
    <COMMENT>/*  model the incremental sampling of BACKTAB that the STIC performs    */</COMMENT>
    <COMMENT>/*  throughout display time.  To do it correctly w/ this setup, I need  */</COMMENT>
    <COMMENT>/*  to double-buffer here, which shouldn't be too bad.  What's 240      */</COMMENT>
    <COMMENT>/*  words, really?                                                      */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    (<TYPE>void</TYPE>)req;  <COMMENT>/* this will become un-ignored later. */</COMMENT>

    data <OPERATOR>&amp;=</OPERATOR> <NUMERIC>0x3FFF</NUMERIC>;  <COMMENT>/* only lower 14 bits seen by STIC. */</COMMENT>
    
    <KEYWORD>if</KEYWORD> (addr <OPERATOR>&lt;</OPERATOR> <NUMERIC>0xF0</NUMERIC>)
    {
        <KEYWORD>if</KEYWORD> (data <OPERATOR>!=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>btab_sr</OO>[addr])
            <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>bt_dirty</OO> <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC>;

        <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>btab_sr</OO>[addr] <OPERATOR>=</OPERATOR> data;
    }
}


<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC_GMEM_WR -- Capture writes to the Graphics RAM.                     */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
<TYPE>void</TYPE> stic_gmem_wr(periph_t <OPERATOR>*</OPERATOR>per, periph_t <OPERATOR>*</OPERATOR>req, uint_32 addr, uint_32 data)
{
    stic_t <OPERATOR>*</OPERATOR>stic <OPERATOR>=</OPERATOR> (stic_t<OPERATOR>*</OPERATOR>)<OBJ>per</OBJ><OPERATOR>-&gt;</OPERATOR><OO>parent</OO>;
    uint_64 access_time <OPERATOR>=</OPERATOR> req <OPERATOR>&amp;&amp;</OPERATOR> <OBJ>req</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req</OO> <OPERATOR>?</OPERATOR> <OBJ>req</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req</OO><OPERATOR>-&gt;</OPERATOR><OO>now</OO> <OPERATOR>+</OPERATOR> <NUMERIC>4</NUMERIC> <OPERATOR>:</OPERATOR> <NUMERIC>0</NUMERIC>;

<PREPROCESSOR>#if 1</PREPROCESSOR>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Drop the write if in Bus Isolation mode.                            */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>if</KEYWORD> (access_time <OPERATOR>&gt;</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gmem_accessible</OO> <OPERATOR>||</OPERATOR> 
        access_time <OPERATOR>&lt;</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>intak</OO>)
    {
        <KEYWORD>return</KEYWORD>;
    }
<PREPROCESSOR>#endif</PREPROCESSOR>

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  We're mapped into the entire 4K address space for GRAM/GROM.  Drop  */</COMMENT>
    <COMMENT>/*  all writes for GROM addresses.                                      */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>if</KEYWORD> ((addr <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x0FFF</NUMERIC>) <OPERATOR>&lt;</OPERATOR> <NUMERIC>0x0800</NUMERIC>)
        <KEYWORD>return</KEYWORD>;

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Mask according to what the GRAM will actually see address and data  */</COMMENT>
    <COMMENT>/*  wise.  As a result, this should even correctly work for the many    */</COMMENT>
    <COMMENT>/*  GRAM write-aliases.                                                 */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    addr  <OPERATOR>=</OPERATOR> (addr <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x01FF</NUMERIC>) <OPERATOR>+</OPERATOR> <NUMERIC>0x0800</NUMERIC>;
    data <OPERATOR>&amp;=</OPERATOR> <NUMERIC>0x00FF</NUMERIC>;  <COMMENT>/* Only the lower 8 bits of a GRAM write matter. */</COMMENT>

    <KEYWORD>if</KEYWORD> (data <OPERATOR>!=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gmem</OO>[addr]) 
        <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gr_dirty</OO> <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC>;

    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gmem</OO>[addr] <OPERATOR>=</OPERATOR> data;
}


<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC_GMEM_POKE -- Same as GMEM_WR, except ignores bus isolation.        */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
<TYPE>void</TYPE> stic_gmem_poke(periph_t <OPERATOR>*</OPERATOR>per, periph_t <OPERATOR>*</OPERATOR>req, uint_32 addr, uint_32 data)
{
    stic_t <OPERATOR>*</OPERATOR>stic <OPERATOR>=</OPERATOR> (stic_t<OPERATOR>*</OPERATOR>)<OBJ>per</OBJ><OPERATOR>-&gt;</OPERATOR><OO>parent</OO>;

    (<TYPE>void</TYPE>)req;

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Don't allow pokes to GROM.                                          */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>if</KEYWORD> ((addr <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x0FFF</NUMERIC>) <OPERATOR>&lt;</OPERATOR> <NUMERIC>0x0800</NUMERIC>)
        <KEYWORD>return</KEYWORD>;

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Mask according to what the GRAM will actually see address and data  */</COMMENT>
    <COMMENT>/*  wise.  As a result, this should even correctly work for the many    */</COMMENT>
    <COMMENT>/*  GRAM write-aliases.                                                 */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    addr  <OPERATOR>=</OPERATOR> (addr <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x01FF</NUMERIC>) <OPERATOR>+</OPERATOR> <NUMERIC>0x0800</NUMERIC>;
    data <OPERATOR>&amp;=</OPERATOR> <NUMERIC>0x00FF</NUMERIC>;  <COMMENT>/* Only the lower 8 bits of a GRAM write matter. */</COMMENT>

    <KEYWORD>if</KEYWORD> (data <OPERATOR>!=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gmem</OO>[addr]) 
        <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gr_dirty</OO> <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC>;

    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gmem</OO>[addr] <OPERATOR>=</OPERATOR> data;
}


<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC_GMEM_RD -- Read values out of GRAM, GROM, taking into account      */</COMMENT>
<COMMENT>/*                  when GRAM/GROM are visible.                             */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
uint_32 stic_gmem_rd(periph_t <OPERATOR>*</OPERATOR>per, periph_t <OPERATOR>*</OPERATOR>req, uint_32 addr, uint_32 data)
{
    stic_t <OPERATOR>*</OPERATOR>stic <OPERATOR>=</OPERATOR> (stic_t<OPERATOR>*</OPERATOR>)<OBJ>per</OBJ><OPERATOR>-&gt;</OPERATOR><OO>parent</OO>;
    uint_64 access_time <OPERATOR>=</OPERATOR> req <OPERATOR>&amp;&amp;</OPERATOR> <OBJ>req</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req</OO> <OPERATOR>?</OPERATOR> <OBJ>req</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req</OO><OPERATOR>-&gt;</OPERATOR><OO>now</OO> <OPERATOR>+</OPERATOR> <NUMERIC>4</NUMERIC> <OPERATOR>:</OPERATOR> <NUMERIC>0</NUMERIC>;

    (<TYPE>void</TYPE>)data;
    
<PREPROCESSOR>#if 1</PREPROCESSOR>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Disallow access to graphics memory if in Bus Isolation.  System     */</COMMENT>
    <COMMENT>/*  Memory will return $FFFF for these reads.                           */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>if</KEYWORD> (access_time <OPERATOR>&gt;</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gmem_accessible</OO> <OPERATOR>||</OPERATOR>
        access_time <OPERATOR>&lt;</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>intak</OO>)
    {
<COMMENT>//jzp_printf("access_time = %llu  gmem_accessible = %llu  intak = %llu\n", access_time, stic-&gt;gmem_accessible, stic-&gt;req_bus-&gt;intak);</COMMENT>
        <KEYWORD>return</KEYWORD> <NUMERIC>0x3FFF</NUMERIC> <OPERATOR>&amp;</OPERATOR> addr;
    }
<PREPROCESSOR>#endif</PREPROCESSOR>

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  If this is a GRAM address, adjust it for aliases.                   */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>if</KEYWORD> (addr <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x0800</NUMERIC>)
        addr <OPERATOR>=</OPERATOR> (addr <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x09FF</NUMERIC>);


    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Return the data.                                                    */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>return</KEYWORD> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gmem</OO>[addr] <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xFF</NUMERIC>;
}

<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC_GMEM_PEEK -- Like gmem_rd, except always works.                    */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
uint_32 stic_gmem_peek(periph_t <OPERATOR>*</OPERATOR>per, periph_t <OPERATOR>*</OPERATOR>req, uint_32 addr, uint_32 data)
{
    stic_t <OPERATOR>*</OPERATOR>stic <OPERATOR>=</OPERATOR> (stic_t<OPERATOR>*</OPERATOR>)<OBJ>per</OBJ><OPERATOR>-&gt;</OPERATOR><OO>parent</OO>;
    (<TYPE>void</TYPE>)req;
    (<TYPE>void</TYPE>)data;

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  If this is a GRAM address, adjust it for aliases.                   */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>if</KEYWORD> (addr <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x0800</NUMERIC>)
        addr <OPERATOR>=</OPERATOR> (addr <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x09FF</NUMERIC>);

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Return the data.                                                    */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>return</KEYWORD> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gmem</OO>[addr] <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xFF</NUMERIC>;
}



<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC_INIT    -- Initialize this ugly ass peripheral.  Booyah!           */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
<TYPE>int</TYPE> stic_init
(
    stic_t      <OPERATOR>*</OPERATOR><CONSTANT>RESTRICT</CONSTANT> stic,
    uint_16     <OPERATOR>*</OPERATOR><CONSTANT>RESTRICT</CONSTANT> grom_img,
    req_bus_t   <OPERATOR>*</OPERATOR><CONSTANT>RESTRICT</CONSTANT> req_bus,   
    gfx_t       <OPERATOR>*</OPERATOR><CONSTANT>RESTRICT</CONSTANT> gfx,
    demo_t      <OPERATOR>*</OPERATOR><CONSTANT>RESTRICT</CONSTANT> demo
)
{
    <TYPE>int</TYPE> i, j;

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  First, zero out the STIC structure to get rid of anything that      */</COMMENT>
    <COMMENT>/*  might be dangling.                                                  */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <FUNCTION>memset</FUNCTION>((<TYPE>void</TYPE><OPERATOR>*</OPERATOR>)stic, <NUMERIC>0</NUMERIC>, <KEYWORD>sizeof</KEYWORD>(stic_t));

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Set our graphics subsystem pointers.                                */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gfx</OO>  <OPERATOR>=</OPERATOR> gfx;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>disp</OO> <OPERATOR>=</OPERATOR> <OBJ>gfx</OBJ><OPERATOR>-&gt;</OPERATOR><OO>vid</OO>;

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Register the demo recorder, if there is one.                        */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>demo</OO> <OPERATOR>=</OPERATOR> demo;

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Initialize the bit/nibble expansion tables.                         */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>

    <COMMENT>/*  Calculate bit-to-nibble masks b2n, b2n_r */</COMMENT>
    <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> <NUMERIC>256</NUMERIC>; i<OPERATOR>++</OPERATOR>)
    {
        uint_32 b2n, b2n_r;
        b2n <OPERATOR>=</OPERATOR> b2n_r <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;

        <KEYWORD>for</KEYWORD> (j <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; j <OPERATOR>&lt;</OPERATOR> <NUMERIC>8</NUMERIC>; j<OPERATOR>++</OPERATOR>)
            <KEYWORD>if</KEYWORD> ((i <OPERATOR>&gt;&gt;</OPERATOR> j) <OPERATOR>&amp;</OPERATOR> <NUMERIC>1</NUMERIC>)
            {
                b2n   <OPERATOR>|=</OPERATOR> <NUMERIC>0xF</NUMERIC> <OPERATOR>&lt;&lt;</OPERATOR> (j <OPERATOR>*</OPERATOR> <NUMERIC>4</NUMERIC>);
                b2n_r <OPERATOR>|=</OPERATOR> <NUMERIC>0xF</NUMERIC> <OPERATOR>&lt;&lt;</OPERATOR> (<NUMERIC>28</NUMERIC> <OPERATOR>-</OPERATOR> j<OPERATOR>*</OPERATOR><NUMERIC>4</NUMERIC>);
            }

        stic_b2n  [i] <OPERATOR>=</OPERATOR> b2n;
        stic_b2n_r[i] <OPERATOR>=</OPERATOR> b2n_r;
    }

    <COMMENT>/* Calculate bit-to-byte masks b2n_d, b2n_rd */</COMMENT>
    <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> <NUMERIC>16</NUMERIC>; i<OPERATOR>++</OPERATOR>)
    {
        uint_32 b2n_d, b2n_rd;
        b2n_d <OPERATOR>=</OPERATOR> b2n_rd <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;

        <KEYWORD>for</KEYWORD> (j <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; j <OPERATOR>&lt;</OPERATOR> <NUMERIC>4</NUMERIC>; j<OPERATOR>++</OPERATOR>)
            <KEYWORD>if</KEYWORD> ((i <OPERATOR>&gt;&gt;</OPERATOR> j) <OPERATOR>&amp;</OPERATOR> <NUMERIC>1</NUMERIC>)
            {
                b2n_d  <OPERATOR>|=</OPERATOR> <NUMERIC>0xFF</NUMERIC> <OPERATOR>&lt;&lt;</OPERATOR> (j <OPERATOR>*</OPERATOR> <NUMERIC>8</NUMERIC>);
                b2n_rd <OPERATOR>|=</OPERATOR> <NUMERIC>0xFF</NUMERIC> <OPERATOR>&lt;&lt;</OPERATOR> (<NUMERIC>24</NUMERIC> <OPERATOR>-</OPERATOR> j<OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC>);
            }

        stic_b2n_d [i] <OPERATOR>=</OPERATOR> b2n_d;
        stic_b2n_rd[i] <OPERATOR>=</OPERATOR> b2n_rd;
    }

    <COMMENT>/* Calculate n2b */</COMMENT>
<PREPROCESSOR>#ifdef BYTE_LE</PREPROCESSOR>
    <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> <NUMERIC>16</NUMERIC>; i<OPERATOR>++</OPERATOR>)
        <KEYWORD>for</KEYWORD> (j <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; j <OPERATOR>&lt;</OPERATOR> <NUMERIC>16</NUMERIC>; j<OPERATOR>++</OPERATOR>)
            stic_n2b[<NUMERIC>16</NUMERIC><OPERATOR>*</OPERATOR>j <OPERATOR>+</OPERATOR> i] <OPERATOR>=</OPERATOR> <NUMERIC>256</NUMERIC><OPERATOR>*</OPERATOR>i <OPERATOR>+</OPERATOR> j;
<PREPROCESSOR>#else</PREPROCESSOR>
    <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> <NUMERIC>16</NUMERIC>; i<OPERATOR>++</OPERATOR>)
        <KEYWORD>for</KEYWORD> (j <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; j <OPERATOR>&lt;</OPERATOR> <NUMERIC>16</NUMERIC>; j<OPERATOR>++</OPERATOR>)
            stic_n2b[<NUMERIC>16</NUMERIC><OPERATOR>*</OPERATOR>j <OPERATOR>+</OPERATOR> i] <OPERATOR>=</OPERATOR> i <OPERATOR>+</OPERATOR> <NUMERIC>256</NUMERIC><OPERATOR>*</OPERATOR>j;
<PREPROCESSOR>#endif</PREPROCESSOR>

    <COMMENT>/* Calculate bit_r 8-bit bit-reverse table */</COMMENT>
    <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> <NUMERIC>256</NUMERIC>; i<OPERATOR>++</OPERATOR>)
    {
        uint_32 bit_r <OPERATOR>=</OPERATOR> i;

        bit_r <OPERATOR>=</OPERATOR> ((bit_r <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xAA</NUMERIC>) <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>1</NUMERIC>) <OPERATOR>|</OPERATOR> ((bit_r <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x55</NUMERIC>) <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>1</NUMERIC>);
        bit_r <OPERATOR>=</OPERATOR> ((bit_r <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xCC</NUMERIC>) <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>2</NUMERIC>) <OPERATOR>|</OPERATOR> ((bit_r <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x33</NUMERIC>) <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>2</NUMERIC>);
        bit_r <OPERATOR>=</OPERATOR> ((bit_r <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xF0</NUMERIC>) <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>4</NUMERIC>) <OPERATOR>|</OPERATOR> ((bit_r <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x0F</NUMERIC>) <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>4</NUMERIC>);

        stic_bit  [i] <OPERATOR>=</OPERATOR> i     <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>8</NUMERIC>;
        stic_bit_r[i] <OPERATOR>=</OPERATOR> bit_r <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>8</NUMERIC>;
    }

    <COMMENT>/* Calculate bit-doubling tables bit_d, bit_rd */</COMMENT>
    <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> <NUMERIC>256</NUMERIC>; i<OPERATOR>++</OPERATOR>)
    {
        uint_32 bit_d <OPERATOR>=</OPERATOR> i, bit_rd <OPERATOR>=</OPERATOR> stic_bit_r[i] <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>8</NUMERIC>;

        <KEYWORD>for</KEYWORD> (j <OPERATOR>=</OPERATOR> <NUMERIC>7</NUMERIC>; j <OPERATOR>&gt;</OPERATOR> <NUMERIC>0</NUMERIC>; j<OPERATOR>--</OPERATOR>)
        {
            bit_d  <OPERATOR>+=</OPERATOR> bit_d  <OPERATOR>&amp;</OPERATOR> (<OPERATOR>~</OPERATOR><NUMERIC>0U</NUMERIC> <OPERATOR>&lt;&lt;</OPERATOR> j);
            bit_rd <OPERATOR>+=</OPERATOR> bit_rd <OPERATOR>&amp;</OPERATOR> (<OPERATOR>~</OPERATOR><NUMERIC>0U</NUMERIC> <OPERATOR>&lt;&lt;</OPERATOR> j);
        }

        stic_bit_d [i] <OPERATOR>=</OPERATOR> <NUMERIC>3</NUMERIC> <OPERATOR>*</OPERATOR> bit_d;
        stic_bit_rd[i] <OPERATOR>=</OPERATOR> <NUMERIC>3</NUMERIC> <OPERATOR>*</OPERATOR> bit_rd;
    }

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Initialize graphics memory.                                         */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> <NUMERIC>2048</NUMERIC>; i<OPERATOR>++</OPERATOR>)
        <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gmem</OO>[i] <OPERATOR>=</OPERATOR> grom_img[i];

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Set up our internal flags.                                          */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>phase</OO> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mode</OO>  <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>upd</OO>   <OPERATOR>=</OPERATOR> stic_draw_cstk;
    
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Record our INTRQ/BUSRQ request bus pointer.  Usually points us to   */</COMMENT>
    <COMMENT>/*  cp1600-&gt;req_bus.                                                    */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO> <OPERATOR>=</OPERATOR> req_bus;

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Now, set up our peripheral functions for the main STIC peripheral.  */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>stic_cr</OO><OPERATOR>.</OPERATOR><OO>read</OO>      <OPERATOR>=</OPERATOR> stic_ctrl_rd;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>stic_cr</OO><OPERATOR>.</OPERATOR><OO>write</OO>     <OPERATOR>=</OPERATOR> stic_ctrl_wr;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>stic_cr</OO><OPERATOR>.</OPERATOR><OO>peek</OO>      <OPERATOR>=</OPERATOR> stic_ctrl_peek;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>stic_cr</OO><OPERATOR>.</OPERATOR><OO>poke</OO>      <OPERATOR>=</OPERATOR> stic_ctrl_wr;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>stic_cr</OO><OPERATOR>.</OPERATOR><OO>tick</OO>      <OPERATOR>=</OPERATOR> stic_tick;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>stic_cr</OO><OPERATOR>.</OPERATOR><OO>reset</OO>     <OPERATOR>=</OPERATOR> stic_reset;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>stic_cr</OO><OPERATOR>.</OPERATOR><OO>min_tick</OO>  <OPERATOR>=</OPERATOR> <NUMERIC>57</NUMERIC>; <COMMENT>/* to get started.  stic_tick will reset. */</COMMENT>
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>stic_cr</OO><OPERATOR>.</OPERATOR><OO>max_tick</OO>  <OPERATOR>=</OPERATOR> <NUMERIC>57</NUMERIC>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>stic_cr</OO><OPERATOR>.</OPERATOR><OO>addr_base</OO> <OPERATOR>=</OPERATOR> <NUMERIC>0x00000000</NUMERIC>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>stic_cr</OO><OPERATOR>.</OPERATOR><OO>addr_mask</OO> <OPERATOR>=</OPERATOR> <NUMERIC>0x0000FFFF</NUMERIC>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>stic_cr</OO><OPERATOR>.</OPERATOR><OO>parent</OO>    <OPERATOR>=</OPERATOR> (<TYPE>void</TYPE><OPERATOR>*</OPERATOR>) stic;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>phase</OO>             <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>next_phase</OO>        <OPERATOR>=</OPERATOR> <NUMERIC>57</NUMERIC>;
    
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Lastly, set up the 'snooping' STIC peripherals.                     */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>snoop_btab</OO><OPERATOR>.</OPERATOR><OO>read</OO>       <OPERATOR>=</OPERATOR> <KEYWORD>NULL</KEYWORD>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>snoop_btab</OO><OPERATOR>.</OPERATOR><OO>write</OO>      <OPERATOR>=</OPERATOR> stic_btab_wr;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>snoop_btab</OO><OPERATOR>.</OPERATOR><OO>peek</OO>       <OPERATOR>=</OPERATOR> <KEYWORD>NULL</KEYWORD>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>snoop_btab</OO><OPERATOR>.</OPERATOR><OO>poke</OO>       <OPERATOR>=</OPERATOR> stic_btab_wr;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>snoop_btab</OO><OPERATOR>.</OPERATOR><OO>tick</OO>       <OPERATOR>=</OPERATOR> <KEYWORD>NULL</KEYWORD>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>snoop_btab</OO><OPERATOR>.</OPERATOR><OO>min_tick</OO>   <OPERATOR>=</OPERATOR> <OPERATOR>~</OPERATOR><NUMERIC>0U</NUMERIC>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>snoop_btab</OO><OPERATOR>.</OPERATOR><OO>max_tick</OO>   <OPERATOR>=</OPERATOR> <OPERATOR>~</OPERATOR><NUMERIC>0U</NUMERIC>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>snoop_btab</OO><OPERATOR>.</OPERATOR><OO>addr_base</OO>  <OPERATOR>=</OPERATOR> <NUMERIC>0x00000200</NUMERIC>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>snoop_btab</OO><OPERATOR>.</OPERATOR><OO>addr_mask</OO>  <OPERATOR>=</OPERATOR> <NUMERIC>0x000000FF</NUMERIC>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>snoop_btab</OO><OPERATOR>.</OPERATOR><OO>parent</OO>     <OPERATOR>=</OPERATOR> (<TYPE>void</TYPE><OPERATOR>*</OPERATOR>) stic;

    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>snoop_gram</OO><OPERATOR>.</OPERATOR><OO>read</OO>       <OPERATOR>=</OPERATOR> stic_gmem_rd;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>snoop_gram</OO><OPERATOR>.</OPERATOR><OO>write</OO>      <OPERATOR>=</OPERATOR> stic_gmem_wr;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>snoop_gram</OO><OPERATOR>.</OPERATOR><OO>peek</OO>       <OPERATOR>=</OPERATOR> stic_gmem_peek;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>snoop_gram</OO><OPERATOR>.</OPERATOR><OO>poke</OO>       <OPERATOR>=</OPERATOR> stic_gmem_poke;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>snoop_gram</OO><OPERATOR>.</OPERATOR><OO>tick</OO>       <OPERATOR>=</OPERATOR> <KEYWORD>NULL</KEYWORD>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>snoop_gram</OO><OPERATOR>.</OPERATOR><OO>min_tick</OO>   <OPERATOR>=</OPERATOR> <OPERATOR>~</OPERATOR><NUMERIC>0U</NUMERIC>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>snoop_gram</OO><OPERATOR>.</OPERATOR><OO>max_tick</OO>   <OPERATOR>=</OPERATOR> <OPERATOR>~</OPERATOR><NUMERIC>0U</NUMERIC>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>snoop_gram</OO><OPERATOR>.</OPERATOR><OO>addr_base</OO>  <OPERATOR>=</OPERATOR> <NUMERIC>0x00003000</NUMERIC>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>snoop_gram</OO><OPERATOR>.</OPERATOR><OO>addr_mask</OO>  <OPERATOR>=</OPERATOR> <NUMERIC>0x0000FFFF</NUMERIC>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>snoop_gram</OO><OPERATOR>.</OPERATOR><OO>parent</OO>     <OPERATOR>=</OPERATOR> (<TYPE>void</TYPE><OPERATOR>*</OPERATOR>) stic;

    <KEYWORD>return</KEYWORD> <NUMERIC>0</NUMERIC>;
}


<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC BACKTAB display list architecture:                                 */</COMMENT>
<COMMENT>/*                                                                          */</COMMENT>
<COMMENT>/*  There are two main BACKTAB renderers for the STIC:  DRAW_CSTK and       */</COMMENT>
<COMMENT>/*  DRAW_FGBG.  These correspond to the two primary STIC modes.  Each of    */</COMMENT>
<COMMENT>/*  these renderers produce a pair of display lists that feed into the      */</COMMENT>
<COMMENT>/*  rest of the STIC display computation.                                   */</COMMENT>
<COMMENT>/*                                                                          */</COMMENT>
<COMMENT>/*  The two lists correspond to the colors of the displayed pixels for      */</COMMENT>
<COMMENT>/*  each card, and the bitmap of "foreground vs. background" pixels for     */</COMMENT>
<COMMENT>/*  each card.  What's important to note about these lists is that they     */</COMMENT>
<COMMENT>/*  are in card order, and are not rasterized onto the 160x96 background    */</COMMENT>
<COMMENT>/*  yet.                                                                    */</COMMENT>
<COMMENT>/*                                                                          */</COMMENT>
<COMMENT>/*  The display color list stores a list of 32-bit ints, each containing    */</COMMENT>
<COMMENT>/*  8 4-bit pixels packed as nibbles within each word.  By packing pixels   */</COMMENT>
<COMMENT>/*  in this manner, pixel color computation becomes exceedingly efficient.  */</COMMENT>
<COMMENT>/*  Indeed, it's just a couple ANDs and an OR to merge foreground and       */</COMMENT>
<COMMENT>/*  background colors for an entire 8-pixel row of a card.                  */</COMMENT>
<COMMENT>/*                                                                          */</COMMENT>
<COMMENT>/*  The foreground bitmap list stores a list of bytes, each containing      */</COMMENT>
<COMMENT>/*  bits indicating which pixels are foreground and which pixels are        */</COMMENT>
<COMMENT>/*  background.  A '1' bit in this bitmap indicates a foreground pixel.     */</COMMENT>
<COMMENT>/*  This secondary bitmap will be used to compute MOB collisions later,     */</COMMENT>
<COMMENT>/*  using nice simple bitwise ANDs to detect coincidence.                   */</COMMENT>
<COMMENT>/*                                                                          */</COMMENT>
<COMMENT>/*  The two lists are stored as lists of cards to limit the amount of       */</COMMENT>
<COMMENT>/*  addressing work that the display computation loops must do.  By         */</COMMENT>
<COMMENT>/*  tightly limiting the focus of these loops and by constructing a nice    */</COMMENT>
<COMMENT>/*  linear output pattern, this code should be fairly efficient.            */</COMMENT>
<COMMENT>/*                                                                          */</COMMENT>
<COMMENT>/*  In addition to the two display lists, the BACKTAB renderers produce     */</COMMENT>
<COMMENT>/*  a third, short list containing the "last background color" associated   */</COMMENT>
<COMMENT>/*  with each row of cards.  This information will be used to render the    */</COMMENT>
<COMMENT>/*  pixels to the left and above the BACKTAB image later in the engine.     */</COMMENT>
<COMMENT>/*                                                                          */</COMMENT>
<COMMENT>/*  These lists will feed into a unified render engine which will merge     */</COMMENT>
<COMMENT>/*  the MOB images and the BACKTAB image into the final frame buffer.       */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>


<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC_DO_MOB -- Render a given MOB.                                      */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
<CONSTANT>LOCAL</CONSTANT> <TYPE>void</TYPE> stic_do_mob(stic_t <OPERATOR>*</OPERATOR>stic, <TYPE>int</TYPE> mob)
{
    <TYPE>int</TYPE> y, yy, y_flip, gr_idx, y_res <OPERATOR>=</OPERATOR> <NUMERIC>8</NUMERIC>;
    uint_32 x_reg, y_reg, a_reg;
    uint_32 fg_clr, fg_msk;
    uint_16 <OPERATOR>*</OPERATOR>      <CONSTANT>RESTRICT</CONSTANT> bit_remap;
    uint_32 <OPERATOR>*</OPERATOR><KEYWORD>const</KEYWORD> <CONSTANT>RESTRICT</CONSTANT> mob_img <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mob_img</OO>;
    uint_16 <OPERATOR>*</OPERATOR><KEYWORD>const</KEYWORD> <CONSTANT>RESTRICT</CONSTANT> mob_bmp <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mob_bmp</OO>[mob];

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Grab the MOB's information.                                         */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    x_reg <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[mob <OPERATOR>+</OPERATOR> <NUMERIC>0x00</NUMERIC>];
    y_reg <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[mob <OPERATOR>+</OPERATOR> <NUMERIC>0x08</NUMERIC>];
    a_reg <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[mob <OPERATOR>+</OPERATOR> <NUMERIC>0x10</NUMERIC>];


    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Decode the various control bits from the MOB's registers.           */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    fg_clr <OPERATOR>=</OPERATOR> ((a_reg <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>9</NUMERIC>) <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x08</NUMERIC>) <OPERATOR>|</OPERATOR> (a_reg <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x07</NUMERIC>);
    fg_msk <OPERATOR>=</OPERATOR> stic_color_mask[fg_clr];

    <KEYWORD>if</KEYWORD> (x_reg <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x0400</NUMERIC>)                <COMMENT>/* --- double width --- */</COMMENT>
    {                                  <COMMENT>/* x-flip */</COMMENT>  <COMMENT>/* normal */</COMMENT>
        bit_remap <OPERATOR>=</OPERATOR> (y_reg <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x0400</NUMERIC>) <OPERATOR>?</OPERATOR> stic_bit_rd <OPERATOR>:</OPERATOR> stic_bit_d;
    } <KEYWORD>else</KEYWORD>                             <COMMENT>/* --- single width --- */</COMMENT>
    {                                  <COMMENT>/* x-flip */</COMMENT>  <COMMENT>/* normal */</COMMENT>
        bit_remap <OPERATOR>=</OPERATOR> (y_reg <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x0400</NUMERIC>) <OPERATOR>?</OPERATOR> stic_bit_r  <OPERATOR>:</OPERATOR> stic_bit;
    }

    <KEYWORD>if</KEYWORD> (y_reg <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x80</NUMERIC>)
        y_res <OPERATOR>=</OPERATOR> <NUMERIC>16</NUMERIC>;

    y_flip <OPERATOR>=</OPERATOR> y_reg <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x0800</NUMERIC> <OPERATOR>?</OPERATOR> y_res <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC> <OPERATOR>:</OPERATOR> <NUMERIC>0</NUMERIC>;   <COMMENT>/* y-flip vs. normal */</COMMENT>

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Decode the GROM/GRAM index.  Bits 9 and 10 are ignored if the card  */</COMMENT>
    <COMMENT>/*  is from GRAM, or if the display is in Foreground/Background mode.   */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    gr_idx <OPERATOR>=</OPERATOR> a_reg <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xFF8</NUMERIC>;
    <KEYWORD>if</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mode</OO> <OPERATOR>==</OPERATOR> <NUMERIC>1</NUMERIC> <OPERATOR>||</OPERATOR> (gr_idx <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x800</NUMERIC>))
        gr_idx <OPERATOR>&amp;=</OPERATOR> <NUMERIC>0x9F8</NUMERIC>;

    <KEYWORD>if</KEYWORD> (y_res <OPERATOR>==</OPERATOR> <NUMERIC>16</NUMERIC>)
        gr_idx <OPERATOR>&amp;=</OPERATOR> <NUMERIC>0xFF0</NUMERIC>;

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Generate the MOB's bitmap from its color and GRAM/GROM image.       */</COMMENT>
    <COMMENT>/*  Each MOB is generated to a 16x16 bitmap, regardless of its actual   */</COMMENT>
    <COMMENT>/*  size.  We handle x-flip, y-flip and x-size here.  We handle y-size  */</COMMENT>
    <COMMENT>/*  later when compositing the MOBs into a single bitmap.               */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>for</KEYWORD> (y <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; y <OPERATOR>&lt;</OPERATOR> y_res; y<OPERATOR>++</OPERATOR>)
    {
        uint_32 row <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gmem</OO>[gr_idx <OPERATOR>+</OPERATOR> y];
        uint_16 bit <OPERATOR>=</OPERATOR> bit_remap[row];
        uint_32 lpix <OPERATOR>=</OPERATOR> stic_b2n[bit <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>8</NUMERIC>  ] <OPERATOR>&amp;</OPERATOR> fg_msk;
        uint_32 rpix <OPERATOR>=</OPERATOR> stic_b2n[bit <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xFF</NUMERIC>] <OPERATOR>&amp;</OPERATOR> fg_msk;

        yy <OPERATOR>=</OPERATOR> y <OPERATOR>^</OPERATOR> y_flip;

        mob_img[<NUMERIC>2</NUMERIC><OPERATOR>*</OPERATOR>yy <OPERATOR>+</OPERATOR> <NUMERIC>0</NUMERIC>] <OPERATOR>=</OPERATOR> lpix;
        mob_img[<NUMERIC>2</NUMERIC><OPERATOR>*</OPERATOR>yy <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>] <OPERATOR>=</OPERATOR> rpix;
        mob_bmp[yy]       <OPERATOR>=</OPERATOR> bit;
    }

    <KEYWORD>for</KEYWORD> (y <OPERATOR>=</OPERATOR> y_res; y <OPERATOR>&lt;</OPERATOR> <NUMERIC>16</NUMERIC>; y<OPERATOR>++</OPERATOR>)
    {
        mob_img[<NUMERIC>2</NUMERIC><OPERATOR>*</OPERATOR>y <OPERATOR>+</OPERATOR> <NUMERIC>0</NUMERIC>] <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
        mob_img[<NUMERIC>2</NUMERIC><OPERATOR>*</OPERATOR>y <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>] <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
        mob_bmp[y]       <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
    }
}

<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC_DRAW_MOBS -- Draw all 8 MOBs onto the 256x96 bitplane.             */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
<CONSTANT>LOCAL</CONSTANT> <TYPE>void</TYPE> stic_draw_mobs(stic_t <OPERATOR>*</OPERATOR>stic)
{
    <TYPE>int</TYPE> i, j;
    uint_32 <OPERATOR>*</OPERATOR><KEYWORD>const</KEYWORD> <CONSTANT>RESTRICT</CONSTANT> mpl_img <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mpl_img</OO>;
    uint_32 <OPERATOR>*</OPERATOR><KEYWORD>const</KEYWORD> <CONSTANT>RESTRICT</CONSTANT> mpl_pri <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mpl_pri</OO>;
    uint_32 <OPERATOR>*</OPERATOR><KEYWORD>const</KEYWORD> <CONSTANT>RESTRICT</CONSTANT> mpl_vsb <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mpl_vsb</OO>;
    uint_32 <OPERATOR>*</OPERATOR><KEYWORD>const</KEYWORD> <CONSTANT>RESTRICT</CONSTANT> mob_img <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mob_img</OO>;

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  First, clear the MOB plane.  We only need to clear the visibility   */</COMMENT>
    <COMMENT>/*  and priority bits, not the color plane.  This is because we ignore  */</COMMENT>
    <COMMENT>/*  the contents of the color plane wherever the visibility bit is 0.   */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <FUNCTION>memset</FUNCTION>(mpl_pri, <NUMERIC>0</NUMERIC>, <NUMERIC>192</NUMERIC> <OPERATOR>*</OPERATOR> <NUMERIC>224</NUMERIC> <OPERATOR>/</OPERATOR> <NUMERIC>8</NUMERIC>);
    <FUNCTION>memset</FUNCTION>(mpl_vsb, <NUMERIC>0</NUMERIC>, <NUMERIC>192</NUMERIC> <OPERATOR>*</OPERATOR> <NUMERIC>224</NUMERIC> <OPERATOR>/</OPERATOR> <NUMERIC>8</NUMERIC>);

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Generate the bitmaps for the 8 MOBs if they're active, and put      */</COMMENT>
    <COMMENT>/*  together the MOB plane.                                             */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>7</NUMERIC>; i <OPERATOR>&gt;=</OPERATOR> <NUMERIC>0</NUMERIC>; i<OPERATOR>--</OPERATOR>)
    {
        uint_32 x_reg <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[i <OPERATOR>+</OPERATOR> <NUMERIC>0x00</NUMERIC>];
        uint_32 y_reg <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[i <OPERATOR>+</OPERATOR> <NUMERIC>0x08</NUMERIC>];
        uint_32 x_pos <OPERATOR>=</OPERATOR>  x_reg <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xFF</NUMERIC>;
        uint_32 y_pos <OPERATOR>=</OPERATOR> (y_reg <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x7F</NUMERIC>) <OPERATOR>*</OPERATOR> <NUMERIC>2</NUMERIC>;
        uint_32 prio  <OPERATOR>=</OPERATOR> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[i <OPERATOR>+</OPERATOR> <NUMERIC>0x10</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x2000</NUMERIC>) <OPERATOR>?</OPERATOR> <OPERATOR>~</OPERATOR><NUMERIC>0U</NUMERIC> <OPERATOR>:</OPERATOR> <NUMERIC>0</NUMERIC>;
        uint_32 visb  <OPERATOR>=</OPERATOR> x_reg <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x200</NUMERIC>;
        uint_32 y_shf <OPERATOR>=</OPERATOR> (y_reg <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>8</NUMERIC>) <OPERATOR>&amp;</OPERATOR> <NUMERIC>3</NUMERIC>;
        <TYPE>int</TYPE>     y_stp <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC> <OPERATOR>&lt;&lt;</OPERATOR> y_shf;
        <TYPE>int</TYPE>     y_hgt <OPERATOR>=</OPERATOR> stic_mob_hgt[(y_reg <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>7</NUMERIC>) <OPERATOR>&amp;</OPERATOR> <NUMERIC>7</NUMERIC>];
        uint_32 x_rad <OPERATOR>=</OPERATOR> (x_pos <OPERATOR>&amp;</OPERATOR> <NUMERIC>7</NUMERIC>) <OPERATOR>*</OPERATOR> <NUMERIC>4</NUMERIC>;
        uint_32 x_lad <OPERATOR>=</OPERATOR> <NUMERIC>32</NUMERIC> <OPERATOR>-</OPERATOR> x_rad;
        uint_32 x_ofs <OPERATOR>=</OPERATOR> (x_pos <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>3</NUMERIC>);
        uint_32 x_ofb <OPERATOR>=</OPERATOR> (x_pos <OPERATOR>&amp;</OPERATOR> <NUMERIC>31</NUMERIC>);
        uint_16 <OPERATOR>*</OPERATOR><KEYWORD>const</KEYWORD> <CONSTANT>RESTRICT</CONSTANT> mob_bmp <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mob_bmp</OO>[i];
        <TYPE>int</TYPE>     y, y_res;

        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  Compute bounding box for MOB and tell gfx about it.  We can     */</COMMENT>
        <COMMENT>/*  use this information to draw debug boxes around MOBs and other  */</COMMENT>
        <COMMENT>/*  nice things.  Bounding box is inclusive on all four edges.      */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gfx</OO><OPERATOR>-&gt;</OPERATOR><OO>bbox</OO>[i][<NUMERIC>0</NUMERIC>] <OPERATOR>=</OPERATOR> x_pos;
        <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gfx</OO><OPERATOR>-&gt;</OPERATOR><OO>bbox</OO>[i][<NUMERIC>1</NUMERIC>] <OPERATOR>=</OPERATOR> y_pos;
        <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gfx</OO><OPERATOR>-&gt;</OPERATOR><OO>bbox</OO>[i][<NUMERIC>2</NUMERIC>] <OPERATOR>=</OPERATOR> x_pos <OPERATOR>+</OPERATOR> (x_reg <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x400</NUMERIC> <OPERATOR>?</OPERATOR> <NUMERIC>15</NUMERIC> <OPERATOR>:</OPERATOR> <NUMERIC>7</NUMERIC>);
        <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gfx</OO><OPERATOR>-&gt;</OPERATOR><OO>bbox</OO>[i][<NUMERIC>3</NUMERIC>] <OPERATOR>=</OPERATOR> y_pos <OPERATOR>+</OPERATOR> y_hgt <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>;

        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  Skip this MOB if it is off-screen or is both not-visible and    */</COMMENT>
        <COMMENT>/*  non-interacting.                                                */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <KEYWORD>if</KEYWORD> (x_pos <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC> <OPERATOR>||</OPERATOR> x_pos <OPERATOR>&gt;=</OPERATOR> <NUMERIC>167</NUMERIC> <OPERATOR>||</OPERATOR> (x_reg <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x300</NUMERIC>) <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC> <OPERATOR>||</OPERATOR>
            y_pos <OPERATOR>&gt;=</OPERATOR> <NUMERIC>208</NUMERIC>)
            <KEYWORD>continue</KEYWORD>;

        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  Generate the bitmap information for this MOB.                   */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        stic_do_mob(stic, i);

        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  If this MOB is visible, put it into the color display image.    */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <KEYWORD>if</KEYWORD> (<OPERATOR>!</OPERATOR>visb <OPERATOR>||</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>drop_frame</OO> <OPERATOR>&gt;</OPERATOR> <NUMERIC>0</NUMERIC>)
            <KEYWORD>continue</KEYWORD>;

        y_res <OPERATOR>=</OPERATOR> y_reg <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x80</NUMERIC> <OPERATOR>?</OPERATOR> <NUMERIC>16</NUMERIC> <OPERATOR>:</OPERATOR> <NUMERIC>8</NUMERIC>;

        <KEYWORD>if</KEYWORD> (y_pos <OPERATOR>+</OPERATOR> (y_res <OPERATOR>&lt;&lt;</OPERATOR> y_shf) <OPERATOR>&gt;</OPERATOR> <NUMERIC>208</NUMERIC>)
            y_res <OPERATOR>=</OPERATOR> (<NUMERIC>207</NUMERIC> <OPERATOR>-</OPERATOR> y_pos <OPERATOR>+</OPERATOR> (<NUMERIC>1</NUMERIC> <OPERATOR>&lt;&lt;</OPERATOR> y_shf)) <OPERATOR>&gt;&gt;</OPERATOR> y_shf;

        <KEYWORD>for</KEYWORD> (y <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; y <OPERATOR>&lt;</OPERATOR> y_res; y<OPERATOR>++</OPERATOR>)
        {
            uint_32 l_pix, m_pix, r_pix;    <COMMENT>/* colors for 16-pixel MOB      */</COMMENT>
            uint_32 l_msk, m_msk, r_msk;    <COMMENT>/* visibility masks             */</COMMENT>
            uint_32 l_old, m_old, r_old;    <COMMENT>/* previous colors in disp      */</COMMENT>
            uint_32 l_new, m_new, r_new;    <COMMENT>/* merged old and MOB           */</COMMENT>
            uint_32 l_pri, r_pri;           <COMMENT>/* priority bit masks.          */</COMMENT>
            <TYPE>int</TYPE>     b_idx, v_idx;           <COMMENT>/* index into BMP and VISB      */</COMMENT>
            uint_32 l_bmp, r_bmp;           <COMMENT>/* 1-bpp bitmaps of MOB         */</COMMENT>
                                                                          
            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            <COMMENT>/*  Get the 4-bpp images of the MOB into l_pix, m_pix.          */</COMMENT>
            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            l_pix <OPERATOR>=</OPERATOR> mob_img[<NUMERIC>2</NUMERIC><OPERATOR>*</OPERATOR>y <OPERATOR>+</OPERATOR> <NUMERIC>0</NUMERIC>];                                    
            m_pix <OPERATOR>=</OPERATOR> mob_img[<NUMERIC>2</NUMERIC><OPERATOR>*</OPERATOR>y <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>];                                    
            l_msk <OPERATOR>=</OPERATOR> stic_b2n[mob_bmp[y] <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>8</NUMERIC>  ];                         
            m_msk <OPERATOR>=</OPERATOR> stic_b2n[mob_bmp[y] <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xFF</NUMERIC>];                         
                                                                          
            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            <COMMENT>/*  Shift these right according to the X position of MOB.       */</COMMENT>
            <COMMENT>/*  A 16-pixel wide MOB will straddle up to 3 32-bit words      */</COMMENT>
            <COMMENT>/*  at 4-bpp.  (x_rad == "x position right adjust")             */</COMMENT>
            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            <KEYWORD>if</KEYWORD> (x_rad)
            {
                r_pix <OPERATOR>=</OPERATOR> (m_pix <OPERATOR>&lt;&lt;</OPERATOR> x_lad);
                m_pix <OPERATOR>=</OPERATOR> (l_pix <OPERATOR>&lt;&lt;</OPERATOR> x_lad) <OPERATOR>|</OPERATOR> (m_pix <OPERATOR>&gt;&gt;</OPERATOR> x_rad);
                l_pix <OPERATOR>=</OPERATOR>                    (l_pix <OPERATOR>&gt;&gt;</OPERATOR> x_rad);
                r_msk <OPERATOR>=</OPERATOR> (m_msk <OPERATOR>&lt;&lt;</OPERATOR> x_lad);
                m_msk <OPERATOR>=</OPERATOR> (l_msk <OPERATOR>&lt;&lt;</OPERATOR> x_lad) <OPERATOR>|</OPERATOR> (m_msk <OPERATOR>&gt;&gt;</OPERATOR> x_rad);
                l_msk <OPERATOR>=</OPERATOR>                    (l_msk <OPERATOR>&gt;&gt;</OPERATOR> x_rad);
            } <KEYWORD>else</KEYWORD>
            {
                r_pix <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
                r_msk <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
            }

            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            <COMMENT>/*  Similarly, shift the 1-bpp masks right according to the X   */</COMMENT>
            <COMMENT>/*  position of the MOB.                                        */</COMMENT>
            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            <KEYWORD>if</KEYWORD> (x_ofb <OPERATOR>&lt;=</OPERATOR> <NUMERIC>16</NUMERIC>)
            {
                l_bmp <OPERATOR>=</OPERATOR> mob_bmp[y] <OPERATOR>&lt;&lt;</OPERATOR> (<NUMERIC>16</NUMERIC> <OPERATOR>-</OPERATOR> x_ofb);
                r_bmp <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
            } <KEYWORD>else</KEYWORD> <KEYWORD>if</KEYWORD> (x_ofb <OPERATOR>&lt;=</OPERATOR> <NUMERIC>32</NUMERIC>)
            {
                l_bmp <OPERATOR>=</OPERATOR> mob_bmp[y] <OPERATOR>&gt;&gt;</OPERATOR> (x_ofb <OPERATOR>-</OPERATOR> <NUMERIC>16</NUMERIC>);
                r_bmp <OPERATOR>=</OPERATOR> mob_bmp[y] <OPERATOR>&lt;&lt;</OPERATOR> (<NUMERIC>48</NUMERIC> <OPERATOR>-</OPERATOR> x_ofb);
            } <KEYWORD>else</KEYWORD>
            {
                l_bmp <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
                r_bmp <OPERATOR>=</OPERATOR> mob_bmp[y] <OPERATOR>&lt;&lt;</OPERATOR> (<NUMERIC>48</NUMERIC> <OPERATOR>-</OPERATOR> x_ofb);
            }
                                                                          
            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            <COMMENT>/*  Take the computed values and merge them into the image.     */</COMMENT>
            <COMMENT>/*  This is where we replicate pixels to account for y-size.    */</COMMENT>
            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            b_idx <OPERATOR>=</OPERATOR> (y_pos <OPERATOR>+</OPERATOR> (y <OPERATOR>&lt;&lt;</OPERATOR> y_shf)) <OPERATOR>*</OPERATOR> <NUMERIC>24</NUMERIC> <OPERATOR>+</OPERATOR> x_ofs;
            v_idx <OPERATOR>=</OPERATOR> b_idx <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>2</NUMERIC>;
            <KEYWORD>for</KEYWORD> (j <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; j <OPERATOR>&lt;</OPERATOR> y_stp; j<OPERATOR>++</OPERATOR>, b_idx <OPERATOR>+=</OPERATOR> <NUMERIC>24</NUMERIC>, v_idx <OPERATOR>+=</OPERATOR> <NUMERIC>6</NUMERIC>)
            {
                <COMMENT>/* -------------------------------------------------------- */</COMMENT>
                <COMMENT>/*  Now, merge the colors into the MOB color plane.         */</COMMENT>
                <COMMENT>/* -------------------------------------------------------- */</COMMENT>
                l_old <OPERATOR>=</OPERATOR> mpl_img[b_idx <OPERATOR>+</OPERATOR> <NUMERIC>0</NUMERIC>];                                
                m_old <OPERATOR>=</OPERATOR> mpl_img[b_idx <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>];                                
                r_old <OPERATOR>=</OPERATOR> mpl_img[b_idx <OPERATOR>+</OPERATOR> <NUMERIC>2</NUMERIC>];                                
                                                                           
                l_new <OPERATOR>=</OPERATOR> (l_old <OPERATOR>&amp;</OPERATOR> <OPERATOR>~</OPERATOR>l_msk) <OPERATOR>|</OPERATOR> (l_pix <OPERATOR>&amp;</OPERATOR> l_msk);                
                m_new <OPERATOR>=</OPERATOR> (m_old <OPERATOR>&amp;</OPERATOR> <OPERATOR>~</OPERATOR>m_msk) <OPERATOR>|</OPERATOR> (m_pix <OPERATOR>&amp;</OPERATOR> m_msk);                
                r_new <OPERATOR>=</OPERATOR> (r_old <OPERATOR>&amp;</OPERATOR> <OPERATOR>~</OPERATOR>r_msk) <OPERATOR>|</OPERATOR> (r_pix <OPERATOR>&amp;</OPERATOR> r_msk);                
                                                                           
                mpl_img[b_idx <OPERATOR>+</OPERATOR> <NUMERIC>0</NUMERIC>] <OPERATOR>=</OPERATOR> l_new;                                
                mpl_img[b_idx <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>] <OPERATOR>=</OPERATOR> m_new;                                
                mpl_img[b_idx <OPERATOR>+</OPERATOR> <NUMERIC>2</NUMERIC>] <OPERATOR>=</OPERATOR> r_new;                                
                                                                           
                <COMMENT>/* -------------------------------------------------------- */</COMMENT>
                <COMMENT>/*  Next, set the MOB visibility bits and priority bits in  */</COMMENT>
                <COMMENT>/*  the corresponding 1-bpp bitmaps.                        */</COMMENT>
                <COMMENT>/* -------------------------------------------------------- */</COMMENT>
                mpl_vsb[v_idx <OPERATOR>+</OPERATOR> <NUMERIC>0</NUMERIC>] <OPERATOR>|=</OPERATOR> l_bmp;
                mpl_vsb[v_idx <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>] <OPERATOR>|=</OPERATOR> r_bmp;

                l_pri <OPERATOR>=</OPERATOR> (mpl_pri[v_idx <OPERATOR>+</OPERATOR> <NUMERIC>0</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <OPERATOR>~</OPERATOR>l_bmp) <OPERATOR>|</OPERATOR> (prio <OPERATOR>&amp;</OPERATOR> l_bmp);
                r_pri <OPERATOR>=</OPERATOR> (mpl_pri[v_idx <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <OPERATOR>~</OPERATOR>r_bmp) <OPERATOR>|</OPERATOR> (prio <OPERATOR>&amp;</OPERATOR> r_bmp);
                mpl_pri[v_idx <OPERATOR>+</OPERATOR> <NUMERIC>0</NUMERIC>] <OPERATOR>=</OPERATOR> l_pri;
                mpl_pri[v_idx <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>] <OPERATOR>=</OPERATOR> r_pri;
            }
        }
    }
}

<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC_DRAW_CSTK -- Draw the 160x96 backtab image into a display list.    */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
<CONSTANT>LOCAL</CONSTANT> <TYPE>void</TYPE> stic_draw_cstk(stic_t <OPERATOR>*</OPERATOR>stic)
{
    <TYPE>int</TYPE> yy;
    <TYPE>int</TYPE> r, c;               <COMMENT>/* current row, column into backtab.            */</COMMENT>
    <TYPE>int</TYPE> bt, bti, btl;       <COMMENT>/* Index into the BACKTAB.                      */</COMMENT>
    <TYPE>int</TYPE> cs_idx;             <COMMENT>/* Current color-stack position                 */</COMMENT>
    <TYPE>int</TYPE> gr_idx;             <COMMENT>/* Character index into GRAM/GROM.              */</COMMENT>
    uint_32 card;           <COMMENT>/* 14-bit card info from backtab.               */</COMMENT>
    uint_32 px_bmp;         <COMMENT>/* row of pixels from GRAM/GROM.                */</COMMENT>
    <TYPE>int</TYPE> fg_clr;             <COMMENT>/* foreground color for the card.               */</COMMENT>
    <TYPE>int</TYPE> cstk[<NUMERIC>4</NUMERIC>];
    uint_32 fg_msk;         <COMMENT>/* foreground color mask.                       */</COMMENT>
    uint_32 bg_msk;         <COMMENT>/* background color mask.                       */</COMMENT>
    uint_32 px_msk;         <COMMENT>/* expanded pixel mask.                         */</COMMENT>
    uint_16 <OPERATOR>*</OPERATOR><KEYWORD>const</KEYWORD> <CONSTANT>RESTRICT</CONSTANT> btab   <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>btab</OO>;
    uint_32 <OPERATOR>*</OPERATOR><KEYWORD>const</KEYWORD> <CONSTANT>RESTRICT</CONSTANT> bt_img <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>xbt_img</OO>;
    uint_8  <OPERATOR>*</OPERATOR><KEYWORD>const</KEYWORD> <CONSTANT>RESTRICT</CONSTANT> bt_bmp <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>bt_bmp</OO>;

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Read out the color-stack color values.                              */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    cstk[<NUMERIC>0</NUMERIC>] <OPERATOR>=</OPERATOR> stic_color_mask[<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[<NUMERIC>0x28</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xF</NUMERIC>];
    cstk[<NUMERIC>1</NUMERIC>] <OPERATOR>=</OPERATOR> stic_color_mask[<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[<NUMERIC>0x29</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xF</NUMERIC>];
    cstk[<NUMERIC>2</NUMERIC>] <OPERATOR>=</OPERATOR> stic_color_mask[<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[<NUMERIC>0x2A</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xF</NUMERIC>];
    cstk[<NUMERIC>3</NUMERIC>] <OPERATOR>=</OPERATOR> stic_color_mask[<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[<NUMERIC>0x2B</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xF</NUMERIC>];

    cs_idx <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
    bg_msk <OPERATOR>=</OPERATOR> cstk[<NUMERIC>0</NUMERIC>];
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Step by rows and columns filling tiles.                             */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>for</KEYWORD> (bti <OPERATOR>=</OPERATOR> <NUMERIC>8</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>24</NUMERIC> <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>, bt <OPERATOR>=</OPERATOR> btl <OPERATOR>=</OPERATOR> r <OPERATOR>=</OPERATOR> c <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; bt <OPERATOR>&lt;</OPERATOR> <NUMERIC>240</NUMERIC>; bt<OPERATOR>++</OPERATOR>, bti<OPERATOR>++</OPERATOR>, btl <OPERATOR>+=</OPERATOR> <NUMERIC>8</NUMERIC>)
    {

        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  For each tile, do the following:                                */</COMMENT>
        <COMMENT>/*   -- If it's colored-squares, render as colored squares,         */</COMMENT>
        <COMMENT>/*      and move to the next tile.                                  */</COMMENT>
        <COMMENT>/*   -- If it's a color-stack advance, advance the color stack.     */</COMMENT>
        <COMMENT>/*   -- If we haven't rendered the tile yet, render it.             */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        card <OPERATOR>=</OPERATOR> btab[bt];                                         
                                                                          
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  Handle colored-squares cards.                                   */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <KEYWORD>if</KEYWORD> ((card <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x1800</NUMERIC>) <OPERATOR>==</OPERATOR> <NUMERIC>0x1000</NUMERIC>)
        {
            uint_32 csq0, csq1, csq2, csq3;
            uint_32 csq_top, csq_bot;
            uint_32 bmp_top, bmp_bot;

            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            <COMMENT>/*                                                              */</COMMENT>
            <COMMENT>/*    13  12  11  10   9   8   7   6   5   4   3   2   1   0    */</COMMENT>
            <COMMENT>/*  +----+---+---+---+---+---+---+---+---+---+---+---+---+---+  */</COMMENT>
            <COMMENT>/*  |Pix3| 1   0 |Pix. 3 |Pix 2 color|Pix 1 color|Pix 0 color|  */</COMMENT>
            <COMMENT>/*  |Bit2|       |bit 0-1|   (0-7)   |   (0-7)   |   (0-7)   |  */</COMMENT>
            <COMMENT>/*  +----+---+---+---+---+---+---+---+---+---+---+---+---+---+  */</COMMENT>
            <COMMENT>/*                                                              */</COMMENT>
            <COMMENT>/*  The four pixels are displayed within an 8x8 card like so:   */</COMMENT>
            <COMMENT>/*                                                              */</COMMENT>
            <COMMENT>/*                       +-----+-----+                          */</COMMENT>
            <COMMENT>/*                       |Pixel|Pixel|                          */</COMMENT>
            <COMMENT>/*                       |  0  |  1  |                          */</COMMENT>
            <COMMENT>/*                       +-----+-----+                          */</COMMENT>
            <COMMENT>/*                       |Pixel|Pixel|                          */</COMMENT>
            <COMMENT>/*                       |  2  |  3  |                          */</COMMENT>
            <COMMENT>/*                       +-----+-----+                          */</COMMENT>
            <COMMENT>/*                                                              */</COMMENT>
            <COMMENT>/*  Notes:                                                      */</COMMENT>
            <COMMENT>/*                                                              */</COMMENT>
            <COMMENT>/*   -- Colors 0 through 6 display directly from the Primary    */</COMMENT>
            <COMMENT>/*      Color Set.                                              */</COMMENT>
            <COMMENT>/*                                                              */</COMMENT>
            <COMMENT>/*   -- Color 7 actually displays the current color on the top  */</COMMENT>
            <COMMENT>/*      of the color-stack.                                     */</COMMENT>
            <COMMENT>/*                                                              */</COMMENT>
            <COMMENT>/*   -- Colors 0 through 6 behave as "on" pixels that will      */</COMMENT>
            <COMMENT>/*      interact with MOBs.  Color 7 behaves as "off" pixels    */</COMMENT>
            <COMMENT>/*      and does not interact with MOBs.                        */</COMMENT>
            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            csq0 <OPERATOR>=</OPERATOR>  (card <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>0</NUMERIC>) <OPERATOR>&amp;</OPERATOR> <NUMERIC>7</NUMERIC>;
            csq1 <OPERATOR>=</OPERATOR>  (card <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>3</NUMERIC>) <OPERATOR>&amp;</OPERATOR> <NUMERIC>7</NUMERIC>;
            csq2 <OPERATOR>=</OPERATOR>  (card <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>6</NUMERIC>) <OPERATOR>&amp;</OPERATOR> <NUMERIC>7</NUMERIC>;
            csq3 <OPERATOR>=</OPERATOR> ((card <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>9</NUMERIC>) <OPERATOR>&amp;</OPERATOR> <NUMERIC>3</NUMERIC>) <OPERATOR>|</OPERATOR> ((card <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>11</NUMERIC>) <OPERATOR>&amp;</OPERATOR> <NUMERIC>4</NUMERIC>);

            bmp_top <OPERATOR>=</OPERATOR> bmp_bot <OPERATOR>=</OPERATOR> <NUMERIC>0xFF</NUMERIC>;

            <KEYWORD>if</KEYWORD> (csq0 <OPERATOR>==</OPERATOR> <NUMERIC>7</NUMERIC>) { csq0 <OPERATOR>=</OPERATOR> bg_msk <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xF</NUMERIC>; bmp_top <OPERATOR>&amp;=</OPERATOR> <NUMERIC>0x0F</NUMERIC>; }
            <KEYWORD>if</KEYWORD> (csq1 <OPERATOR>==</OPERATOR> <NUMERIC>7</NUMERIC>) { csq1 <OPERATOR>=</OPERATOR> bg_msk <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xF</NUMERIC>; bmp_top <OPERATOR>&amp;=</OPERATOR> <NUMERIC>0xF0</NUMERIC>; }
            <KEYWORD>if</KEYWORD> (csq2 <OPERATOR>==</OPERATOR> <NUMERIC>7</NUMERIC>) { csq2 <OPERATOR>=</OPERATOR> bg_msk <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xF</NUMERIC>; bmp_bot <OPERATOR>&amp;=</OPERATOR> <NUMERIC>0x0F</NUMERIC>; }
            <KEYWORD>if</KEYWORD> (csq3 <OPERATOR>==</OPERATOR> <NUMERIC>7</NUMERIC>) { csq3 <OPERATOR>=</OPERATOR> bg_msk <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xF</NUMERIC>; bmp_bot <OPERATOR>&amp;=</OPERATOR> <NUMERIC>0xF0</NUMERIC>; }

            csq0 <OPERATOR>=</OPERATOR> stic_color_mask[csq0];
            csq1 <OPERATOR>=</OPERATOR> stic_color_mask[csq1];
            csq2 <OPERATOR>=</OPERATOR> stic_color_mask[csq2];
            csq3 <OPERATOR>=</OPERATOR> stic_color_mask[csq3];

            csq_top <OPERATOR>=</OPERATOR> (<NUMERIC>0xFFFF0000</NUMERIC> <OPERATOR>&amp;</OPERATOR> csq0) <OPERATOR>|</OPERATOR> (<NUMERIC>0x0000FFFF</NUMERIC> <OPERATOR>&amp;</OPERATOR> csq1);
            csq_bot <OPERATOR>=</OPERATOR> (<NUMERIC>0xFFFF0000</NUMERIC> <OPERATOR>&amp;</OPERATOR> csq2) <OPERATOR>|</OPERATOR> (<NUMERIC>0x0000FFFF</NUMERIC> <OPERATOR>&amp;</OPERATOR> csq3);

            bt_img[bti <OPERATOR>+</OPERATOR> <NUMERIC>0</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>24</NUMERIC>] <OPERATOR>=</OPERATOR> csq_top;
            bt_img[bti <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>24</NUMERIC>] <OPERATOR>=</OPERATOR> csq_top;
            bt_img[bti <OPERATOR>+</OPERATOR> <NUMERIC>2</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>24</NUMERIC>] <OPERATOR>=</OPERATOR> csq_top;
            bt_img[bti <OPERATOR>+</OPERATOR> <NUMERIC>3</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>24</NUMERIC>] <OPERATOR>=</OPERATOR> csq_top;
            bt_img[bti <OPERATOR>+</OPERATOR> <NUMERIC>4</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>24</NUMERIC>] <OPERATOR>=</OPERATOR> csq_bot;
            bt_img[bti <OPERATOR>+</OPERATOR> <NUMERIC>5</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>24</NUMERIC>] <OPERATOR>=</OPERATOR> csq_bot;
            bt_img[bti <OPERATOR>+</OPERATOR> <NUMERIC>6</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>24</NUMERIC>] <OPERATOR>=</OPERATOR> csq_bot;
            bt_img[bti <OPERATOR>+</OPERATOR> <NUMERIC>7</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>24</NUMERIC>] <OPERATOR>=</OPERATOR> csq_bot;

            bt_bmp[btl <OPERATOR>+</OPERATOR> <NUMERIC>0</NUMERIC>] <OPERATOR>=</OPERATOR> bmp_top;
            bt_bmp[btl <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>] <OPERATOR>=</OPERATOR> bmp_top;
            bt_bmp[btl <OPERATOR>+</OPERATOR> <NUMERIC>2</NUMERIC>] <OPERATOR>=</OPERATOR> bmp_top;
            bt_bmp[btl <OPERATOR>+</OPERATOR> <NUMERIC>3</NUMERIC>] <OPERATOR>=</OPERATOR> bmp_top;
            bt_bmp[btl <OPERATOR>+</OPERATOR> <NUMERIC>4</NUMERIC>] <OPERATOR>=</OPERATOR> bmp_bot;
            bt_bmp[btl <OPERATOR>+</OPERATOR> <NUMERIC>5</NUMERIC>] <OPERATOR>=</OPERATOR> bmp_bot;
            bt_bmp[btl <OPERATOR>+</OPERATOR> <NUMERIC>6</NUMERIC>] <OPERATOR>=</OPERATOR> bmp_bot;
            bt_bmp[btl <OPERATOR>+</OPERATOR> <NUMERIC>7</NUMERIC>] <OPERATOR>=</OPERATOR> bmp_bot;

            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            <COMMENT>/*  Skip remainder of processing for this block since the       */</COMMENT>
            <COMMENT>/*  colored square mode is a special case.                      */</COMMENT>
            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            <KEYWORD>if</KEYWORD> (c<OPERATOR>++</OPERATOR> <OPERATOR>==</OPERATOR> <NUMERIC>19</NUMERIC>) { c<OPERATOR>=</OPERATOR><NUMERIC>0</NUMERIC>; <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>last_bg</OO>[r<OPERATOR>++</OPERATOR>] <OPERATOR>=</OPERATOR> bg_msk; bti <OPERATOR>+=</OPERATOR> <NUMERIC>8</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>24</NUMERIC><OPERATOR>-</OPERATOR><NUMERIC>20</NUMERIC>; }
            <KEYWORD>continue</KEYWORD>;
        }                                                                 
                                                                          
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  The color stack advances when bit 13 is one.                    */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <KEYWORD>if</KEYWORD> (card <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x2000</NUMERIC>)                                                
        {                                                                 
            cs_idx <OPERATOR>=</OPERATOR> (cs_idx <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>) <OPERATOR>&amp;</OPERATOR> <NUMERIC>3</NUMERIC>;                                    
            bg_msk <OPERATOR>=</OPERATOR> cstk[cs_idx];
        }                                                                 
                                                                          
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  Extract the GROM/GRAM index from bits 11..3.  If the card is    */</COMMENT>
        <COMMENT>/*  from GRAM, ignore bits 10..9.                                   */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        gr_idx <OPERATOR>=</OPERATOR> card <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xFF8</NUMERIC>;                                            
        <KEYWORD>if</KEYWORD> (gr_idx <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x800</NUMERIC>)  <COMMENT>/* is card from GRAM? */</COMMENT>
            gr_idx <OPERATOR>&amp;=</OPERATOR> <NUMERIC>0x9F8</NUMERIC>;                                              
                                                                          
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  The foreground color comes from bits 12 and 2..0.               */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        fg_clr <OPERATOR>=</OPERATOR> ((card <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>9</NUMERIC>) <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x8</NUMERIC>) <OPERATOR>|</OPERATOR> (card <OPERATOR>&amp;</OPERATOR> <NUMERIC>7</NUMERIC>);                        
        fg_msk <OPERATOR>=</OPERATOR> stic_color_mask[fg_clr];                                 
                                                                          
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  Now blit the bits into the packed-nibble display list.          */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <KEYWORD>for</KEYWORD> (yy <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; yy <OPERATOR>&lt;</OPERATOR> <NUMERIC>8</NUMERIC>; yy<OPERATOR>++</OPERATOR>)
        {
            px_bmp <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gmem</OO>[gr_idx <OPERATOR>+</OPERATOR> yy];
            px_msk <OPERATOR>=</OPERATOR> stic_b2n[px_bmp];

            bt_bmp[btl <OPERATOR>+</OPERATOR> yy   ] <OPERATOR>=</OPERATOR> px_bmp;
            bt_img[bti <OPERATOR>+</OPERATOR> yy<OPERATOR>*</OPERATOR><NUMERIC>24</NUMERIC>] <OPERATOR>=</OPERATOR> (fg_msk <OPERATOR>&amp;</OPERATOR> px_msk) <OPERATOR>|</OPERATOR> (bg_msk <OPERATOR>&amp;</OPERATOR> <OPERATOR>~</OPERATOR>px_msk);
        }

        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  Advance row, column counters.                                   */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <KEYWORD>if</KEYWORD> (c<OPERATOR>++</OPERATOR> <OPERATOR>==</OPERATOR> <NUMERIC>19</NUMERIC>) { c <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>last_bg</OO>[r<OPERATOR>++</OPERATOR>] <OPERATOR>=</OPERATOR> bg_msk; bti <OPERATOR>+=</OPERATOR> <NUMERIC>8</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>24</NUMERIC><OPERATOR>-</OPERATOR><NUMERIC>20</NUMERIC>; }
    }
}

<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC_DRAW_FGBG -- Draw the 160x96 backtab image into a display list.    */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
<CONSTANT>LOCAL</CONSTANT> <TYPE>void</TYPE> stic_draw_fgbg(stic_t <OPERATOR>*</OPERATOR>stic)
{
    <TYPE>int</TYPE> yy;
    <TYPE>int</TYPE> r, c;               <COMMENT>/* current row, column into backtab.            */</COMMENT>
    <TYPE>int</TYPE> bt, btl, bti;       <COMMENT>/* Index into the BACKTAB.                      */</COMMENT>
    <TYPE>int</TYPE> gr_idx;             <COMMENT>/* Character index into GRAM/GROM.              */</COMMENT>
    uint_32 card;           <COMMENT>/* 14-bit card info from backtab.               */</COMMENT>
    uint_32 px_bmp;         <COMMENT>/* row of pixels from GRAM/GROM.                */</COMMENT>
    <TYPE>int</TYPE> fg_clr;             <COMMENT>/* foreground color for the card.               */</COMMENT>
    <TYPE>int</TYPE> bg_clr;             <COMMENT>/* background color for the card.               */</COMMENT>
    uint_32 fg_msk;         <COMMENT>/* foreground color mask.                       */</COMMENT>
    uint_32 bg_msk;         <COMMENT>/* background color mask.                       */</COMMENT>
    uint_32 px_msk;         <COMMENT>/* expanded pixel mask.                         */</COMMENT>
    uint_16 <OPERATOR>*</OPERATOR><KEYWORD>const</KEYWORD> <CONSTANT>RESTRICT</CONSTANT> btab   <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>btab</OO>;
    uint_32 <OPERATOR>*</OPERATOR><KEYWORD>const</KEYWORD> <CONSTANT>RESTRICT</CONSTANT> bt_img <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>xbt_img</OO>;
    uint_8  <OPERATOR>*</OPERATOR><KEYWORD>const</KEYWORD> <CONSTANT>RESTRICT</CONSTANT> bt_bmp <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>bt_bmp</OO>;

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Step by rows and columns filling tiles.                             */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>for</KEYWORD> (bti <OPERATOR>=</OPERATOR> <NUMERIC>8</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>24</NUMERIC> <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>, bt <OPERATOR>=</OPERATOR> btl <OPERATOR>=</OPERATOR> r <OPERATOR>=</OPERATOR> c <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; bt <OPERATOR>&lt;</OPERATOR> <NUMERIC>240</NUMERIC>; bt<OPERATOR>++</OPERATOR>, bti<OPERATOR>++</OPERATOR>, btl <OPERATOR>+=</OPERATOR> <NUMERIC>8</NUMERIC>)
    {
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  For each tile, do the following:                                */</COMMENT>
        <COMMENT>/*   -- Extract foreground, background and card number.             */</COMMENT>
        <COMMENT>/*   -- Draw it.                                                    */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        card <OPERATOR>=</OPERATOR> btab[bt];

        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  The GRAM/GROM index comes from bit 11 and bits 8..3.            */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        gr_idx <OPERATOR>=</OPERATOR> card <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x9F8</NUMERIC>;                                            
                                                                          
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  The foreground color comes from bits 2..0.                      */</COMMENT>
        <COMMENT>/*  The background color comes from bit 12, 13, 10 and 9, in that   */</COMMENT>
        <COMMENT>/*  annoying order.  At least bits 3, 1, and 0 are right.           */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        fg_clr <OPERATOR>=</OPERATOR> (card <OPERATOR>&amp;</OPERATOR> <NUMERIC>7</NUMERIC>);                                              
        bg_clr <OPERATOR>=</OPERATOR> ((card <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>9</NUMERIC>) <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xB</NUMERIC>) <OPERATOR>|</OPERATOR> ((card <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>11</NUMERIC>) <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x4</NUMERIC>);
                                                                          
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  Convert colors to color masks.                                  */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        fg_msk <OPERATOR>=</OPERATOR> stic_color_mask[fg_clr];
        bg_msk <OPERATOR>=</OPERATOR> stic_color_mask[bg_clr];
                                                                          
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  Now blit the bits into the packed-nibble display list.          */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <KEYWORD>for</KEYWORD> (yy <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; yy <OPERATOR>&lt;</OPERATOR> <NUMERIC>8</NUMERIC>; yy<OPERATOR>++</OPERATOR>)
        {
            px_bmp <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gmem</OO>[gr_idx <OPERATOR>+</OPERATOR> yy];
            px_msk <OPERATOR>=</OPERATOR> stic_b2n[px_bmp];

            bt_bmp[btl <OPERATOR>+</OPERATOR> yy   ] <OPERATOR>=</OPERATOR> px_bmp;
            bt_img[bti <OPERATOR>+</OPERATOR> yy<OPERATOR>*</OPERATOR><NUMERIC>24</NUMERIC>] <OPERATOR>=</OPERATOR> (fg_msk <OPERATOR>&amp;</OPERATOR> px_msk) <OPERATOR>|</OPERATOR> (bg_msk <OPERATOR>&amp;</OPERATOR> <OPERATOR>~</OPERATOR>px_msk);
        }

        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  Advance row, column counters.                                   */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <KEYWORD>if</KEYWORD> (c<OPERATOR>++</OPERATOR> <OPERATOR>==</OPERATOR> <NUMERIC>19</NUMERIC>) { c <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>last_bg</OO>[r<OPERATOR>++</OPERATOR>] <OPERATOR>=</OPERATOR> bg_msk; bti <OPERATOR>+=</OPERATOR> <NUMERIC>8</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>24</NUMERIC><OPERATOR>-</OPERATOR><NUMERIC>20</NUMERIC>; }
    }
}

<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC_FIX_BORD -- Trim the display list and MOB image to 159 columns.    */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
<CONSTANT>LOCAL</CONSTANT> <TYPE>void</TYPE> stic_fix_bord(stic_t <OPERATOR>*</OPERATOR>stic)
{
    <TYPE>int</TYPE> i, j;
    uint_8  <OPERATOR>*</OPERATOR><KEYWORD>const</KEYWORD> <CONSTANT>RESTRICT</CONSTANT> bt_bmp <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>bt_bmp</OO>;
    uint_32 <OPERATOR>*</OPERATOR><KEYWORD>const</KEYWORD> <CONSTANT>RESTRICT</CONSTANT> mpl_vsb <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mpl_vsb</OO>;
    uint_32 bord <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[<NUMERIC>0x2C</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xF</NUMERIC>;
    uint_32 n_msk, b_msk;
    <TYPE>int</TYPE> h_dly <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[<NUMERIC>0x30</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>7</NUMERIC>;
 
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Make sure column 159 holds nothing interesting, and has no bg bits  */</COMMENT>
    <COMMENT>/*  beyond column 160 to cause false collisions.                        */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    n_msk <OPERATOR>=</OPERATOR> <NUMERIC>0xFFFFFFF0</NUMERIC> <OPERATOR>&lt;&lt;</OPERATOR> (h_dly <OPERATOR>*</OPERATOR> <NUMERIC>4</NUMERIC>);
    b_msk <OPERATOR>=</OPERATOR> <NUMERIC>0xFFFFFFFF</NUMERIC> <OPERATOR>&lt;&lt;</OPERATOR> (h_dly);
    bord  <OPERATOR>=</OPERATOR> stic_color_mask[bord] <OPERATOR>&amp;</OPERATOR> <OPERATOR>~</OPERATOR>n_msk;

    <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> <NUMERIC>12</NUMERIC>; i<OPERATOR>++</OPERATOR>)
    {
        <KEYWORD>for</KEYWORD> (j <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; j <OPERATOR>&lt;</OPERATOR> <NUMERIC>8</NUMERIC>; j<OPERATOR>++</OPERATOR>)
        {
            uint_8  new_bmp <OPERATOR>=</OPERATOR>  bt_bmp[<NUMERIC>19</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> <NUMERIC>20</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC><OPERATOR>*</OPERATOR>i <OPERATOR>+</OPERATOR> j] <OPERATOR>&amp;</OPERATOR> b_msk;
            bt_bmp[<NUMERIC>19</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> <NUMERIC>20</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC><OPERATOR>*</OPERATOR>i <OPERATOR>+</OPERATOR> j] <OPERATOR>=</OPERATOR> new_bmp;
        }
    }

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  We do the same for the MOBs, but we do this to column 167, because  */</COMMENT>
    <COMMENT>/*  the MOB bitmap starts 8 pixels to the left of the backtab bitmap.   */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    b_msk <OPERATOR>=</OPERATOR> <NUMERIC>0xFE000000</NUMERIC> <OPERATOR>&lt;&lt;</OPERATOR> (h_dly);
    <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> <NUMERIC>224</NUMERIC>; i<OPERATOR>++</OPERATOR>)
    {
        uint_32 new_vsb <OPERATOR>=</OPERATOR>  mpl_vsb[i<OPERATOR>*</OPERATOR><NUMERIC>6</NUMERIC>  <OPERATOR>+</OPERATOR>  <NUMERIC>5</NUMERIC>] <OPERATOR>&amp;</OPERATOR> b_msk;
        mpl_vsb[i<OPERATOR>*</OPERATOR><NUMERIC>6</NUMERIC>  <OPERATOR>+</OPERATOR>  <NUMERIC>5</NUMERIC>] <OPERATOR>=</OPERATOR> new_vsb;
    }

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Trim the MOB collision bitmaps for left, right edges.               */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>for</KEYWORD> (i <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; i <OPERATOR>&lt;</OPERATOR> <NUMERIC>8</NUMERIC>; i<OPERATOR>++</OPERATOR>)
    {
        uint_32 le_msk, re_msk, msk;
        uint_32 x <OPERATOR>=</OPERATOR> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[i <OPERATOR>+</OPERATOR> <NUMERIC>0x00</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xFF</NUMERIC>) <OPERATOR>+</OPERATOR> h_dly;

        le_msk <OPERATOR>=</OPERATOR> x <OPERATOR>&lt;</OPERATOR> <NUMERIC>8</NUMERIC>   <OPERATOR>?</OPERATOR> <NUMERIC>0xFFFFFE00</NUMERIC> <OPERATOR>&lt;&lt;</OPERATOR>  x        <OPERATOR>:</OPERATOR> <NUMERIC>0</NUMERIC>;
        re_msk <OPERATOR>=</OPERATOR> x <OPERATOR>&gt;</OPERATOR> <NUMERIC>150</NUMERIC> <OPERATOR>?</OPERATOR> <NUMERIC>0x00007FFF</NUMERIC> <OPERATOR>&gt;&gt;</OPERATOR> (<NUMERIC>167</NUMERIC> <OPERATOR>-</OPERATOR> x) <OPERATOR>:</OPERATOR> <NUMERIC>0</NUMERIC>;
        msk    <OPERATOR>=</OPERATOR> <OPERATOR>~</OPERATOR>(le_msk <OPERATOR>|</OPERATOR> re_msk);

        <KEYWORD>for</KEYWORD> (j <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; j <OPERATOR>&lt;</OPERATOR> <NUMERIC>16</NUMERIC>; j<OPERATOR>++</OPERATOR>)
            <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mob_bmp</OO>[i][j] <OPERATOR>&amp;=</OPERATOR> msk;
    }
}

<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC_MERGE_PLANES -- Merge MOB and BACKTAB planes.                      */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
<CONSTANT>LOCAL</CONSTANT> <TYPE>void</TYPE> stic_merge_planes(stic_t <OPERATOR>*</OPERATOR>stic)
{
    uint_32 <OPERATOR>*</OPERATOR><KEYWORD>const</KEYWORD> <CONSTANT>RESTRICT</CONSTANT> image   <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>image</OO>;
    <COMMENT>//uint_32 *const RESTRICT bt_img  = stic-&gt;bt_img;</COMMENT>
    uint_8  <OPERATOR>*</OPERATOR><KEYWORD>const</KEYWORD> <CONSTANT>RESTRICT</CONSTANT> bt_bmp  <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>bt_bmp</OO>;
    uint_32 <OPERATOR>*</OPERATOR><KEYWORD>const</KEYWORD> <CONSTANT>RESTRICT</CONSTANT> xbt_img <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>xbt_img</OO>;
    uint_32 <OPERATOR>*</OPERATOR><KEYWORD>const</KEYWORD> <CONSTANT>RESTRICT</CONSTANT> xbt_bmp <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>xbt_bmp</OO>;
    uint_32 <OPERATOR>*</OPERATOR><KEYWORD>const</KEYWORD> <CONSTANT>RESTRICT</CONSTANT> mpl_img <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mpl_img</OO>;
    uint_32 <OPERATOR>*</OPERATOR><KEYWORD>const</KEYWORD> <CONSTANT>RESTRICT</CONSTANT> mpl_vsb <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mpl_vsb</OO>;
    uint_32 <OPERATOR>*</OPERATOR><KEYWORD>const</KEYWORD> <CONSTANT>RESTRICT</CONSTANT> mpl_pri <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mpl_pri</OO>;
    <TYPE>int</TYPE> bt, ri, bti_idx, btb_idx, img_idx, bmp_idx, r, c, y, cc;
    <TYPE>int</TYPE> img_ofs;
    <TYPE>int</TYPE> v_dly, h_dly, top, lft;
    uint_32 bord <OPERATOR>=</OPERATOR> stic_color_mask[<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[<NUMERIC>0x2C</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xF</NUMERIC>];

<COMMENT>#if 0</COMMENT>
<COMMENT>    /* -------------------------------------------------------------------- */</COMMENT>
<COMMENT>    /*  First, re-tile the backtab display list.  That should be quick.     */</COMMENT>
<COMMENT>    /* -------------------------------------------------------------------- */</COMMENT>
<COMMENT>    for (bt = r = 0, ri = 1 + 8*24; r &lt; 12; r++, ri += 8*24)</COMMENT>
<COMMENT>    {</COMMENT>
<COMMENT>        for (c = 0; c &lt; 20; c++, bt++)</COMMENT>
<COMMENT>        {</COMMENT>
<COMMENT>            uint_32 img0 = bt_img[bt*8 + 0];</COMMENT>
<COMMENT>            uint_32 img1 = bt_img[bt*8 + 1];</COMMENT>
<COMMENT>            uint_32 img2 = bt_img[bt*8 + 2];</COMMENT>
<COMMENT>            uint_32 img3 = bt_img[bt*8 + 3];</COMMENT>
<COMMENT>            uint_32 img4 = bt_img[bt*8 + 4];</COMMENT>
<COMMENT>            uint_32 img5 = bt_img[bt*8 + 5];</COMMENT>
<COMMENT>            uint_32 img6 = bt_img[bt*8 + 6];</COMMENT>
<COMMENT>            uint_32 img7 = bt_img[bt*8 + 7];</COMMENT>
<COMMENT></COMMENT>
<COMMENT>            xbt_img[ri + c + 0*24] = img0;</COMMENT>
<COMMENT>            xbt_img[ri + c + 1*24] = img1;</COMMENT>
<COMMENT>            xbt_img[ri + c + 2*24] = img2;</COMMENT>
<COMMENT>            xbt_img[ri + c + 3*24] = img3;</COMMENT>
<COMMENT>            xbt_img[ri + c + 4*24] = img4;</COMMENT>
<COMMENT>            xbt_img[ri + c + 5*24] = img5;</COMMENT>
<COMMENT>            xbt_img[ri + c + 6*24] = img6;</COMMENT>
<COMMENT>            xbt_img[ri + c + 7*24] = img7;</COMMENT>
<COMMENT>        }</COMMENT>
<COMMENT>    }</COMMENT>
<COMMENT>#endif</COMMENT>

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Retile the fg/bg bitmap too.                                        */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>for</KEYWORD> (bt <OPERATOR>=</OPERATOR> r <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>, ri <OPERATOR>=</OPERATOR> <NUMERIC>8</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>6</NUMERIC>; r <OPERATOR>&lt;</OPERATOR> <NUMERIC>12</NUMERIC>; r<OPERATOR>++</OPERATOR>, ri <OPERATOR>+=</OPERATOR> <NUMERIC>8</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>6</NUMERIC>, bt <OPERATOR>+=</OPERATOR> <NUMERIC>20</NUMERIC>)
    {
        <KEYWORD>for</KEYWORD> (y <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; y <OPERATOR>&lt;</OPERATOR> <NUMERIC>8</NUMERIC>; y<OPERATOR>++</OPERATOR>)
        {
            uint_32 bmp0 <OPERATOR>=</OPERATOR> (bt_bmp[bt<OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR>  <NUMERIC>0</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> y] <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>16</NUMERIC>) <OPERATOR>|</OPERATOR>
                           (bt_bmp[bt<OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR>  <NUMERIC>1</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> y] <OPERATOR>&lt;&lt;</OPERATOR>  <NUMERIC>8</NUMERIC>) <OPERATOR>|</OPERATOR>
                           (bt_bmp[bt<OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR>  <NUMERIC>2</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> y]      );
            uint_32 bmp1 <OPERATOR>=</OPERATOR> (bt_bmp[bt<OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR>  <NUMERIC>3</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> y] <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>24</NUMERIC>) <OPERATOR>|</OPERATOR>
                           (bt_bmp[bt<OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR>  <NUMERIC>4</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> y] <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>16</NUMERIC>) <OPERATOR>|</OPERATOR>
                           (bt_bmp[bt<OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR>  <NUMERIC>5</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> y] <OPERATOR>&lt;&lt;</OPERATOR>  <NUMERIC>8</NUMERIC>) <OPERATOR>|</OPERATOR>
                           (bt_bmp[bt<OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR>  <NUMERIC>6</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> y]      );
            uint_32 bmp2 <OPERATOR>=</OPERATOR> (bt_bmp[bt<OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR>  <NUMERIC>7</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> y] <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>24</NUMERIC>) <OPERATOR>|</OPERATOR>
                           (bt_bmp[bt<OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR>  <NUMERIC>8</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> y] <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>16</NUMERIC>) <OPERATOR>|</OPERATOR>
                           (bt_bmp[bt<OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR>  <NUMERIC>9</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> y] <OPERATOR>&lt;&lt;</OPERATOR>  <NUMERIC>8</NUMERIC>) <OPERATOR>|</OPERATOR>
                           (bt_bmp[bt<OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> <NUMERIC>10</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> y]      );
            uint_32 bmp3 <OPERATOR>=</OPERATOR> (bt_bmp[bt<OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> <NUMERIC>11</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> y] <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>24</NUMERIC>) <OPERATOR>|</OPERATOR>
                           (bt_bmp[bt<OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> <NUMERIC>12</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> y] <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>16</NUMERIC>) <OPERATOR>|</OPERATOR>
                           (bt_bmp[bt<OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> <NUMERIC>13</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> y] <OPERATOR>&lt;&lt;</OPERATOR>  <NUMERIC>8</NUMERIC>) <OPERATOR>|</OPERATOR>
                           (bt_bmp[bt<OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> <NUMERIC>14</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> y]      );
            uint_32 bmp4 <OPERATOR>=</OPERATOR> (bt_bmp[bt<OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> <NUMERIC>15</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> y] <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>24</NUMERIC>) <OPERATOR>|</OPERATOR>
                           (bt_bmp[bt<OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> <NUMERIC>16</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> y] <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>16</NUMERIC>) <OPERATOR>|</OPERATOR>
                           (bt_bmp[bt<OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> <NUMERIC>17</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> y] <OPERATOR>&lt;&lt;</OPERATOR>  <NUMERIC>8</NUMERIC>) <OPERATOR>|</OPERATOR>
                           (bt_bmp[bt<OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> <NUMERIC>18</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> y]      );
            uint_32 bmp5 <OPERATOR>=</OPERATOR> (bt_bmp[bt<OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> <NUMERIC>19</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>8</NUMERIC> <OPERATOR>+</OPERATOR> y] <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>24</NUMERIC>);

            xbt_bmp[ri <OPERATOR>+</OPERATOR> <NUMERIC>0</NUMERIC> <OPERATOR>+</OPERATOR> y<OPERATOR>*</OPERATOR><NUMERIC>6</NUMERIC>] <OPERATOR>=</OPERATOR> bmp0;
            xbt_bmp[ri <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC> <OPERATOR>+</OPERATOR> y<OPERATOR>*</OPERATOR><NUMERIC>6</NUMERIC>] <OPERATOR>=</OPERATOR> bmp1;
            xbt_bmp[ri <OPERATOR>+</OPERATOR> <NUMERIC>2</NUMERIC> <OPERATOR>+</OPERATOR> y<OPERATOR>*</OPERATOR><NUMERIC>6</NUMERIC>] <OPERATOR>=</OPERATOR> bmp2;
            xbt_bmp[ri <OPERATOR>+</OPERATOR> <NUMERIC>3</NUMERIC> <OPERATOR>+</OPERATOR> y<OPERATOR>*</OPERATOR><NUMERIC>6</NUMERIC>] <OPERATOR>=</OPERATOR> bmp3;
            xbt_bmp[ri <OPERATOR>+</OPERATOR> <NUMERIC>4</NUMERIC> <OPERATOR>+</OPERATOR> y<OPERATOR>*</OPERATOR><NUMERIC>6</NUMERIC>] <OPERATOR>=</OPERATOR> bmp4;
            xbt_bmp[ri <OPERATOR>+</OPERATOR> <NUMERIC>5</NUMERIC> <OPERATOR>+</OPERATOR> y<OPERATOR>*</OPERATOR><NUMERIC>6</NUMERIC>] <OPERATOR>=</OPERATOR> bmp5;
        }
    }

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Stop here if we're dropping the frame.                              */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <KEYWORD>if</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>drop_frame</OO>)
        <KEYWORD>return</KEYWORD>;

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  fill in colors based on "last_bg" along the top and left.           */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    h_dly   <OPERATOR>=</OPERATOR> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[<NUMERIC>0x30</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>7</NUMERIC>);
    v_dly   <OPERATOR>=</OPERATOR> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[<NUMERIC>0x31</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>7</NUMERIC>);
    img_ofs <OPERATOR>=</OPERATOR> v_dly<OPERATOR>*</OPERATOR><NUMERIC>2</NUMERIC> <OPERATOR>*</OPERATOR> <NUMERIC>24</NUMERIC>;

    <FUNCTION>memset</FUNCTION>(xbt_img, <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>last_bg</OO>[<NUMERIC>11</NUMERIC>], (<NUMERIC>8</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>192</NUMERIC> <OPERATOR>+</OPERATOR> <NUMERIC>8</NUMERIC>)<OPERATOR>/</OPERATOR><NUMERIC>2</NUMERIC>);
    {
        uint_32 h_msk <OPERATOR>=</OPERATOR> <NUMERIC>0xfffffff0</NUMERIC> <OPERATOR>&lt;&lt;</OPERATOR> (h_dly <OPERATOR>*</OPERATOR> <NUMERIC>4</NUMERIC>);
        uint_32 h_fix <OPERATOR>=</OPERATOR> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>last_bg</OO>[<NUMERIC>11</NUMERIC>] <OPERATOR>&amp;</OPERATOR> h_msk) <OPERATOR>|</OPERATOR> (bord <OPERATOR>&amp;</OPERATOR> <OPERATOR>~</OPERATOR>h_msk);

        <KEYWORD>for</KEYWORD> (y <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>, ri <OPERATOR>=</OPERATOR> <NUMERIC>20</NUMERIC>; y <OPERATOR>&lt;</OPERATOR> <NUMERIC>8</NUMERIC>; y<OPERATOR>++</OPERATOR>, ri <OPERATOR>+=</OPERATOR> <NUMERIC>24</NUMERIC>)
            xbt_img[ri] <OPERATOR>=</OPERATOR> h_fix;
    }

    <KEYWORD>for</KEYWORD> (r <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>, ri <OPERATOR>=</OPERATOR> <NUMERIC>9</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>24</NUMERIC>; r <OPERATOR>&lt;</OPERATOR> <NUMERIC>12</NUMERIC>; r<OPERATOR>++</OPERATOR>)
    {
        uint_32 bg_clr <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>last_bg</OO>[r];

        <KEYWORD>for</KEYWORD> (y <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; y <OPERATOR>&lt;</OPERATOR> <NUMERIC>8</NUMERIC>; y<OPERATOR>++</OPERATOR>, ri <OPERATOR>+=</OPERATOR> <NUMERIC>24</NUMERIC>)
            xbt_img[ri] <OPERATOR>=</OPERATOR> bg_clr;
    }

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  now channel between the mob and backtab images into the final       */</COMMENT>
    <COMMENT>/*  display image.  we also account for h_dly/v_dly here.  the vert     */</COMMENT>
    <COMMENT>/*  delay is really cheap -- we just draw further down the screen.      */</COMMENT>
    <COMMENT>/*  the horz delay isn't quite so cheap but is still not terribly       */</COMMENT>
    <COMMENT>/*  expensive.  we shift the pixels right as a huge extended-precision  */</COMMENT>
    <COMMENT>/*  right shift.                                                        */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>

    <KEYWORD>if</KEYWORD> (h_dly <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC>)
    {
        <TYPE>int</TYPE> len <OPERATOR>=</OPERATOR> <NUMERIC>208</NUMERIC> <OPERATOR>-</OPERATOR> v_dly<OPERATOR>*</OPERATOR><NUMERIC>2</NUMERIC>;

        <KEYWORD>for</KEYWORD> (r <OPERATOR>=</OPERATOR> img_idx <OPERATOR>=</OPERATOR> bmp_idx <OPERATOR>=</OPERATOR> bti_idx <OPERATOR>=</OPERATOR> btb_idx <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; 
             r <OPERATOR>&lt;</OPERATOR> len; r<OPERATOR>++</OPERATOR>, img_idx <OPERATOR>+=</OPERATOR> <NUMERIC>24</NUMERIC>, bmp_idx <OPERATOR>+=</OPERATOR> <NUMERIC>6</NUMERIC>)
        {
            <KEYWORD>for</KEYWORD> (c <OPERATOR>=</OPERATOR> cc <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; c <OPERATOR>&lt;</OPERATOR> <NUMERIC>24</NUMERIC>; c <OPERATOR>+=</OPERATOR> <NUMERIC>4</NUMERIC>, cc<OPERATOR>++</OPERATOR>)
            {
                uint_32 btab_0 <OPERATOR>=</OPERATOR> xbt_img[bti_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>0</NUMERIC>];
                uint_32 btab_1 <OPERATOR>=</OPERATOR> xbt_img[bti_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>];
                uint_32 btab_2 <OPERATOR>=</OPERATOR> xbt_img[bti_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>2</NUMERIC>];
                uint_32 btab_3 <OPERATOR>=</OPERATOR> xbt_img[bti_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>3</NUMERIC>];

                uint_32 mobs_0 <OPERATOR>=</OPERATOR> mpl_img[img_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>0</NUMERIC>];
                uint_32 mobs_1 <OPERATOR>=</OPERATOR> mpl_img[img_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>];
                uint_32 mobs_2 <OPERATOR>=</OPERATOR> mpl_img[img_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>2</NUMERIC>];
                uint_32 mobs_3 <OPERATOR>=</OPERATOR> mpl_img[img_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>3</NUMERIC>];

                uint_32 bt_msk <OPERATOR>=</OPERATOR> xbt_bmp[btb_idx <OPERATOR>+</OPERATOR> cc];
                uint_32 vs_msk <OPERATOR>=</OPERATOR> mpl_vsb[bmp_idx <OPERATOR>+</OPERATOR> cc];
                uint_32 pr_msk <OPERATOR>=</OPERATOR> mpl_pri[bmp_idx <OPERATOR>+</OPERATOR> cc];
                uint_32 mb_msk <OPERATOR>=</OPERATOR> vs_msk <OPERATOR>&amp;</OPERATOR> <OPERATOR>~</OPERATOR>(pr_msk <OPERATOR>&amp;</OPERATOR> bt_msk);

                uint_32 mask_0 <OPERATOR>=</OPERATOR> stic_b2n[(mb_msk <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>24</NUMERIC>)       ];
                uint_32 mask_1 <OPERATOR>=</OPERATOR> stic_b2n[(mb_msk <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>16</NUMERIC>) <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xFF</NUMERIC>];
                uint_32 mask_2 <OPERATOR>=</OPERATOR> stic_b2n[(mb_msk <OPERATOR>&gt;&gt;</OPERATOR>  <NUMERIC>8</NUMERIC>) <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xFF</NUMERIC>];
                uint_32 mask_3 <OPERATOR>=</OPERATOR> stic_b2n[(mb_msk      ) <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xFF</NUMERIC>];

                uint_32 img_0  <OPERATOR>=</OPERATOR> (mobs_0 <OPERATOR>&amp;</OPERATOR> mask_0) <OPERATOR>|</OPERATOR> (btab_0 <OPERATOR>&amp;</OPERATOR> <OPERATOR>~</OPERATOR>mask_0);
                uint_32 img_1  <OPERATOR>=</OPERATOR> (mobs_1 <OPERATOR>&amp;</OPERATOR> mask_1) <OPERATOR>|</OPERATOR> (btab_1 <OPERATOR>&amp;</OPERATOR> <OPERATOR>~</OPERATOR>mask_1);
                uint_32 img_2  <OPERATOR>=</OPERATOR> (mobs_2 <OPERATOR>&amp;</OPERATOR> mask_2) <OPERATOR>|</OPERATOR> (btab_2 <OPERATOR>&amp;</OPERATOR> <OPERATOR>~</OPERATOR>mask_2);
                uint_32 img_3  <OPERATOR>=</OPERATOR> (mobs_3 <OPERATOR>&amp;</OPERATOR> mask_3) <OPERATOR>|</OPERATOR> (btab_3 <OPERATOR>&amp;</OPERATOR> <OPERATOR>~</OPERATOR>mask_3);

                image[img_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>0</NUMERIC> <OPERATOR>+</OPERATOR> img_ofs] <OPERATOR>=</OPERATOR> img_0;
                image[img_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC> <OPERATOR>+</OPERATOR> img_ofs] <OPERATOR>=</OPERATOR> img_1;
                image[img_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>2</NUMERIC> <OPERATOR>+</OPERATOR> img_ofs] <OPERATOR>=</OPERATOR> img_2;
                image[img_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>3</NUMERIC> <OPERATOR>+</OPERATOR> img_ofs] <OPERATOR>=</OPERATOR> img_3;
            }

            <KEYWORD>if</KEYWORD> (r <OPERATOR>&amp;</OPERATOR> <NUMERIC>1</NUMERIC>) { bti_idx <OPERATOR>+=</OPERATOR> <NUMERIC>24</NUMERIC>; btb_idx <OPERATOR>+=</OPERATOR> <NUMERIC>6</NUMERIC>; }
            <KEYWORD>else</KEYWORD>       { xbt_img[bti_idx] <OPERATOR>=</OPERATOR> xbt_img[bti_idx <OPERATOR>+</OPERATOR> <NUMERIC>24</NUMERIC>]; }
        }
    } <KEYWORD>else</KEYWORD>
    {
        <TYPE>int</TYPE> r_shf <OPERATOR>=</OPERATOR> h_dly <OPERATOR>*</OPERATOR> <NUMERIC>4</NUMERIC>;
        <TYPE>int</TYPE> l_shf <OPERATOR>=</OPERATOR> <NUMERIC>32</NUMERIC> <OPERATOR>-</OPERATOR> r_shf;
        <TYPE>int</TYPE> len   <OPERATOR>=</OPERATOR> <NUMERIC>208</NUMERIC> <OPERATOR>-</OPERATOR> v_dly<OPERATOR>*</OPERATOR><NUMERIC>2</NUMERIC>;

        <KEYWORD>for</KEYWORD> (r <OPERATOR>=</OPERATOR> img_idx <OPERATOR>=</OPERATOR> bmp_idx <OPERATOR>=</OPERATOR> bti_idx <OPERATOR>=</OPERATOR> btb_idx <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; 
             r <OPERATOR>&lt;</OPERATOR> len; r<OPERATOR>++</OPERATOR>, img_idx <OPERATOR>+=</OPERATOR> <NUMERIC>24</NUMERIC>, bmp_idx <OPERATOR>+=</OPERATOR> <NUMERIC>6</NUMERIC>)
        {
            uint_32 pimg_3 <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;  <COMMENT>/* extending on left w/ 0 is ok */</COMMENT>

<PREPROCESSOR>#if 1</PREPROCESSOR>
            <KEYWORD>for</KEYWORD> (c <OPERATOR>=</OPERATOR> cc <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; c <OPERATOR>&lt;</OPERATOR> <NUMERIC>24</NUMERIC>; c <OPERATOR>+=</OPERATOR> <NUMERIC>4</NUMERIC>, cc<OPERATOR>++</OPERATOR>)
            {
                uint_32 btab_0 <OPERATOR>=</OPERATOR> xbt_img[bti_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>0</NUMERIC>];
                uint_32 btab_1 <OPERATOR>=</OPERATOR> xbt_img[bti_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>];
                uint_32 btab_2 <OPERATOR>=</OPERATOR> xbt_img[bti_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>2</NUMERIC>];
                uint_32 btab_3 <OPERATOR>=</OPERATOR> xbt_img[bti_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>3</NUMERIC>];

                uint_32 mobs_0 <OPERATOR>=</OPERATOR> mpl_img[img_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>0</NUMERIC>];
                uint_32 mobs_1 <OPERATOR>=</OPERATOR> mpl_img[img_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>];
                uint_32 mobs_2 <OPERATOR>=</OPERATOR> mpl_img[img_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>2</NUMERIC>];
                uint_32 mobs_3 <OPERATOR>=</OPERATOR> mpl_img[img_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>3</NUMERIC>];

                uint_32 bt_msk <OPERATOR>=</OPERATOR> xbt_bmp[btb_idx <OPERATOR>+</OPERATOR> cc];
                uint_32 vs_msk <OPERATOR>=</OPERATOR> mpl_vsb[bmp_idx <OPERATOR>+</OPERATOR> cc];
                uint_32 pr_msk <OPERATOR>=</OPERATOR> mpl_pri[bmp_idx <OPERATOR>+</OPERATOR> cc];
                uint_32 mb_msk <OPERATOR>=</OPERATOR> vs_msk <OPERATOR>&amp;</OPERATOR> <OPERATOR>~</OPERATOR>(pr_msk <OPERATOR>&amp;</OPERATOR> bt_msk);

                uint_32 mask_0 <OPERATOR>=</OPERATOR> stic_b2n[(mb_msk <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>24</NUMERIC>)       ];
                uint_32 mask_1 <OPERATOR>=</OPERATOR> stic_b2n[(mb_msk <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>16</NUMERIC>) <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xFF</NUMERIC>];
                uint_32 mask_2 <OPERATOR>=</OPERATOR> stic_b2n[(mb_msk <OPERATOR>&gt;&gt;</OPERATOR>  <NUMERIC>8</NUMERIC>) <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xFF</NUMERIC>];
                uint_32 mask_3 <OPERATOR>=</OPERATOR> stic_b2n[(mb_msk      ) <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xFF</NUMERIC>];

                uint_32 ximg_0 <OPERATOR>=</OPERATOR> (mobs_0 <OPERATOR>&amp;</OPERATOR> mask_0) <OPERATOR>|</OPERATOR> (btab_0 <OPERATOR>&amp;</OPERATOR> <OPERATOR>~</OPERATOR>mask_0);
                uint_32 ximg_1 <OPERATOR>=</OPERATOR> (mobs_1 <OPERATOR>&amp;</OPERATOR> mask_1) <OPERATOR>|</OPERATOR> (btab_1 <OPERATOR>&amp;</OPERATOR> <OPERATOR>~</OPERATOR>mask_1);
                uint_32 ximg_2 <OPERATOR>=</OPERATOR> (mobs_2 <OPERATOR>&amp;</OPERATOR> mask_2) <OPERATOR>|</OPERATOR> (btab_2 <OPERATOR>&amp;</OPERATOR> <OPERATOR>~</OPERATOR>mask_2);
                uint_32 ximg_3 <OPERATOR>=</OPERATOR> (mobs_3 <OPERATOR>&amp;</OPERATOR> mask_3) <OPERATOR>|</OPERATOR> (btab_3 <OPERATOR>&amp;</OPERATOR> <OPERATOR>~</OPERATOR>mask_3);

                uint_32 img_0  <OPERATOR>=</OPERATOR> (pimg_3 <OPERATOR>&lt;&lt;</OPERATOR> l_shf) <OPERATOR>|</OPERATOR> (ximg_0 <OPERATOR>&gt;&gt;</OPERATOR> r_shf);
                uint_32 img_1  <OPERATOR>=</OPERATOR> (ximg_0 <OPERATOR>&lt;&lt;</OPERATOR> l_shf) <OPERATOR>|</OPERATOR> (ximg_1 <OPERATOR>&gt;&gt;</OPERATOR> r_shf);
                uint_32 img_2  <OPERATOR>=</OPERATOR> (ximg_1 <OPERATOR>&lt;&lt;</OPERATOR> l_shf) <OPERATOR>|</OPERATOR> (ximg_2 <OPERATOR>&gt;&gt;</OPERATOR> r_shf);
                uint_32 img_3  <OPERATOR>=</OPERATOR> (ximg_2 <OPERATOR>&lt;&lt;</OPERATOR> l_shf) <OPERATOR>|</OPERATOR> (ximg_3 <OPERATOR>&gt;&gt;</OPERATOR> r_shf);

                image[img_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>0</NUMERIC> <OPERATOR>+</OPERATOR> img_ofs] <OPERATOR>=</OPERATOR> img_0;
                image[img_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC> <OPERATOR>+</OPERATOR> img_ofs] <OPERATOR>=</OPERATOR> img_1;
                image[img_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>2</NUMERIC> <OPERATOR>+</OPERATOR> img_ofs] <OPERATOR>=</OPERATOR> img_2;
                image[img_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>3</NUMERIC> <OPERATOR>+</OPERATOR> img_ofs] <OPERATOR>=</OPERATOR> img_3;

                pimg_3 <OPERATOR>=</OPERATOR> ximg_3;
            }
<PREPROCESSOR>#else</PREPROCESSOR>
            <KEYWORD>for</KEYWORD> (c <OPERATOR>=</OPERATOR> cc <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; c <OPERATOR>&lt;</OPERATOR> <NUMERIC>24</NUMERIC>; c <OPERATOR>+=</OPERATOR> <NUMERIC>4</NUMERIC>, cc<OPERATOR>++</OPERATOR>)
            {
                uint_32 bt_msk, btab_0, btab_1, btab_2, btab_3;
                uint_32 vs_msk, mobs_0, mobs_1, mobs_2, mobs_3;
                uint_32 pr_msk, mask_0, mask_1, mask_2, mask_3;
                uint_32 mb_msk, ximg_0, ximg_1, ximg_2, ximg_3;
                uint_32 img_0;
                uint_32 img_1;
                uint_32 img_2;
                uint_32 img_3;

                bt_msk <OPERATOR>=</OPERATOR> xbt_bmp[btb_idx <OPERATOR>+</OPERATOR> cc];
                vs_msk <OPERATOR>=</OPERATOR> mpl_vsb[bmp_idx <OPERATOR>+</OPERATOR> cc];
                pr_msk <OPERATOR>=</OPERATOR> mpl_pri[bmp_idx <OPERATOR>+</OPERATOR> cc];
                mb_msk <OPERATOR>=</OPERATOR> vs_msk <OPERATOR>&amp;</OPERATOR> <OPERATOR>~</OPERATOR>(pr_msk <OPERATOR>&amp;</OPERATOR> bt_msk);

                btab_0 <OPERATOR>=</OPERATOR> xbt_img[bti_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>0</NUMERIC>];
                mobs_0 <OPERATOR>=</OPERATOR> mpl_img[img_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>0</NUMERIC>];
                mask_0 <OPERATOR>=</OPERATOR> stic_b2n[(mb_msk <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>24</NUMERIC>)       ];
                ximg_0 <OPERATOR>=</OPERATOR> (mobs_0 <OPERATOR>&amp;</OPERATOR> mask_0) <OPERATOR>|</OPERATOR> (btab_0 <OPERATOR>&amp;</OPERATOR> <OPERATOR>~</OPERATOR>mask_0);
                img_0  <OPERATOR>=</OPERATOR> (pimg_3 <OPERATOR>&lt;&lt;</OPERATOR> l_shf) <OPERATOR>|</OPERATOR> (ximg_0 <OPERATOR>&gt;&gt;</OPERATOR> r_shf);
                image[img_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>0</NUMERIC> <OPERATOR>+</OPERATOR> img_ofs] <OPERATOR>=</OPERATOR> img_0;

                btab_1 <OPERATOR>=</OPERATOR> xbt_img[bti_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>];
                mobs_1 <OPERATOR>=</OPERATOR> mpl_img[img_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>];
                mask_1 <OPERATOR>=</OPERATOR> stic_b2n[(mb_msk <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>16</NUMERIC>) <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xFF</NUMERIC>];
                ximg_1 <OPERATOR>=</OPERATOR> (mobs_1 <OPERATOR>&amp;</OPERATOR> mask_1) <OPERATOR>|</OPERATOR> (btab_1 <OPERATOR>&amp;</OPERATOR> <OPERATOR>~</OPERATOR>mask_1);
                img_1  <OPERATOR>=</OPERATOR> (ximg_0 <OPERATOR>&lt;&lt;</OPERATOR> l_shf) <OPERATOR>|</OPERATOR> (ximg_1 <OPERATOR>&gt;&gt;</OPERATOR> r_shf);
                image[img_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC> <OPERATOR>+</OPERATOR> img_ofs] <OPERATOR>=</OPERATOR> img_1;

                btab_2 <OPERATOR>=</OPERATOR> xbt_img[bti_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>2</NUMERIC>];
                mobs_2 <OPERATOR>=</OPERATOR> mpl_img[img_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>2</NUMERIC>];
                mask_2 <OPERATOR>=</OPERATOR> stic_b2n[(mb_msk <OPERATOR>&gt;&gt;</OPERATOR>  <NUMERIC>8</NUMERIC>) <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xFF</NUMERIC>];
                ximg_2 <OPERATOR>=</OPERATOR> (mobs_2 <OPERATOR>&amp;</OPERATOR> mask_2) <OPERATOR>|</OPERATOR> (btab_2 <OPERATOR>&amp;</OPERATOR> <OPERATOR>~</OPERATOR>mask_2);
                img_2  <OPERATOR>=</OPERATOR> (ximg_1 <OPERATOR>&lt;&lt;</OPERATOR> l_shf) <OPERATOR>|</OPERATOR> (ximg_2 <OPERATOR>&gt;&gt;</OPERATOR> r_shf);
                image[img_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>2</NUMERIC> <OPERATOR>+</OPERATOR> img_ofs] <OPERATOR>=</OPERATOR> img_2;
                
                btab_3 <OPERATOR>=</OPERATOR> xbt_img[bti_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>3</NUMERIC>];
                mobs_3 <OPERATOR>=</OPERATOR> mpl_img[img_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>3</NUMERIC>];
                mask_3 <OPERATOR>=</OPERATOR> stic_b2n[(mb_msk      ) <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xFF</NUMERIC>];
                ximg_3 <OPERATOR>=</OPERATOR> (mobs_3 <OPERATOR>&amp;</OPERATOR> mask_3) <OPERATOR>|</OPERATOR> (btab_3 <OPERATOR>&amp;</OPERATOR> <OPERATOR>~</OPERATOR>mask_3);
                img_3  <OPERATOR>=</OPERATOR> (ximg_2 <OPERATOR>&lt;&lt;</OPERATOR> l_shf) <OPERATOR>|</OPERATOR> (ximg_3 <OPERATOR>&gt;&gt;</OPERATOR> r_shf);
                image[img_idx <OPERATOR>+</OPERATOR> c <OPERATOR>+</OPERATOR> <NUMERIC>3</NUMERIC> <OPERATOR>+</OPERATOR> img_ofs] <OPERATOR>=</OPERATOR> img_3;

                pimg_3 <OPERATOR>=</OPERATOR> ximg_3;
            }
<PREPROCESSOR>#endif</PREPROCESSOR>

            <KEYWORD>if</KEYWORD> (r <OPERATOR>&amp;</OPERATOR> <NUMERIC>1</NUMERIC>) { bti_idx <OPERATOR>+=</OPERATOR> <NUMERIC>24</NUMERIC>; btb_idx <OPERATOR>+=</OPERATOR> <NUMERIC>6</NUMERIC>; }
            <KEYWORD>else</KEYWORD>       { xbt_img[bti_idx] <OPERATOR>=</OPERATOR> xbt_img[bti_idx <OPERATOR>+</OPERATOR> <NUMERIC>24</NUMERIC>]; }
        }
    }

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Apply top and bottom borders.                                       */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    top <OPERATOR>=</OPERATOR> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[<NUMERIC>0x32</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>2</NUMERIC> <OPERATOR>?</OPERATOR> <NUMERIC>32</NUMERIC> <OPERATOR>:</OPERATOR> <NUMERIC>16</NUMERIC>);  <COMMENT>/* 32 or 16 rows. */</COMMENT>
    <FUNCTION>memset</FUNCTION>(image,          bord, top <OPERATOR>*</OPERATOR> <NUMERIC>192</NUMERIC> <OPERATOR>/</OPERATOR> <NUMERIC>2</NUMERIC>);
    <FUNCTION>memset</FUNCTION>(image <OPERATOR>+</OPERATOR> <NUMERIC>208</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>24</NUMERIC>, bord,  <NUMERIC>16</NUMERIC> <OPERATOR>*</OPERATOR> <NUMERIC>192</NUMERIC> <OPERATOR>/</OPERATOR> <NUMERIC>2</NUMERIC>);

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    <COMMENT>/*  Apply left and right borders.                                       */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT>
    lft <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[<NUMERIC>0x32</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>1</NUMERIC>;
    <KEYWORD>for</KEYWORD> (r <OPERATOR>=</OPERATOR> <NUMERIC>16</NUMERIC>, ri <OPERATOR>=</OPERATOR> <NUMERIC>16</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>24</NUMERIC>; r <OPERATOR>&lt;</OPERATOR> <NUMERIC>208</NUMERIC>; r<OPERATOR>++</OPERATOR>, ri <OPERATOR>+=</OPERATOR> <NUMERIC>24</NUMERIC>)
    {
        image[ri     ] <OPERATOR>=</OPERATOR> bord;
        image[ri <OPERATOR>+</OPERATOR> <NUMERIC>21</NUMERIC>] <OPERATOR>=</OPERATOR> bord;
        <KEYWORD>if</KEYWORD> (lft) image[ri <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>] <OPERATOR>=</OPERATOR> bord;
    }
}

<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC_PUSH_VID -- Temporary:  Unpack the 4-bpp image to 160x200 8bpp     */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
<CONSTANT>LOCAL</CONSTANT> <TYPE>void</TYPE> stic_push_vid(stic_t <OPERATOR>*</OPERATOR>stic)
{
    <TYPE>int</TYPE> y, x;
    uint_32 <OPERATOR>*</OPERATOR><CONSTANT>RESTRICT</CONSTANT> vid   <OPERATOR>=</OPERATOR> (uint_32<OPERATOR>*</OPERATOR>)<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>disp</OO>;
    uint_32 <OPERATOR>*</OPERATOR><CONSTANT>RESTRICT</CONSTANT> image <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>image</OO>;

    image <OPERATOR>+=</OPERATOR> <NUMERIC>12</NUMERIC><OPERATOR>*</OPERATOR><NUMERIC>24</NUMERIC> <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>;

    <KEYWORD>for</KEYWORD> (y <OPERATOR>=</OPERATOR> <NUMERIC>12</NUMERIC>; y <OPERATOR>&lt;</OPERATOR> <NUMERIC>212</NUMERIC>; y<OPERATOR>++</OPERATOR>)
    {
        <KEYWORD>for</KEYWORD> (x <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC>; x <OPERATOR>&lt;=</OPERATOR> <NUMERIC>20</NUMERIC>; x<OPERATOR>++</OPERATOR>)
        {
<PREPROCESSOR>#ifdef BYTE_LE</PREPROCESSOR>
            uint_32 pix <OPERATOR>=</OPERATOR> <OPERATOR>*</OPERATOR>image<OPERATOR>++</OPERATOR>;
            uint_32 p76 <OPERATOR>=</OPERATOR> stic_n2b[pix       <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xFF</NUMERIC>];
            uint_32 p54 <OPERATOR>=</OPERATOR> stic_n2b[pix <OPERATOR>&gt;&gt;</OPERATOR>  <NUMERIC>8</NUMERIC> <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xFF</NUMERIC>];
            uint_32 p7654 <OPERATOR>=</OPERATOR> (p76 <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>16</NUMERIC>) <OPERATOR>|</OPERATOR> p54;
            uint_32 p32 <OPERATOR>=</OPERATOR> stic_n2b[pix <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>16</NUMERIC> <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xFF</NUMERIC>];
            uint_32 p10 <OPERATOR>=</OPERATOR> stic_n2b[pix <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>24</NUMERIC>       ];
            uint_32 p3210 <OPERATOR>=</OPERATOR> (p32 <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>16</NUMERIC>) <OPERATOR>|</OPERATOR> p10;

            <OPERATOR>*</OPERATOR>vid<OPERATOR>++</OPERATOR> <OPERATOR>=</OPERATOR> p3210;
            <OPERATOR>*</OPERATOR>vid<OPERATOR>++</OPERATOR> <OPERATOR>=</OPERATOR> p7654;
<PREPROCESSOR>#else</PREPROCESSOR>
            uint_32 pix   <OPERATOR>=</OPERATOR> <OPERATOR>*</OPERATOR>image<OPERATOR>++</OPERATOR>;
            uint_32 p01   <OPERATOR>=</OPERATOR> stic_n2b[pix <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>24</NUMERIC>       ];
            uint_32 p23   <OPERATOR>=</OPERATOR> stic_n2b[pix <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>16</NUMERIC> <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xFF</NUMERIC>];
            uint_32 p0123 <OPERATOR>=</OPERATOR> (p01 <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>16</NUMERIC>) <OPERATOR>|</OPERATOR> p23;
            uint_32 p45   <OPERATOR>=</OPERATOR> stic_n2b[pix <OPERATOR>&gt;&gt;</OPERATOR>  <NUMERIC>8</NUMERIC> <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xFF</NUMERIC>];
            uint_32 p67   <OPERATOR>=</OPERATOR> stic_n2b[pix       <OPERATOR>&amp;</OPERATOR> <NUMERIC>0xFF</NUMERIC>];
            uint_32 p4567 <OPERATOR>=</OPERATOR> (p45 <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>16</NUMERIC>) <OPERATOR>|</OPERATOR> p67;

            <OPERATOR>*</OPERATOR>vid<OPERATOR>++</OPERATOR> <OPERATOR>=</OPERATOR> p0123;
            <OPERATOR>*</OPERATOR>vid<OPERATOR>++</OPERATOR> <OPERATOR>=</OPERATOR> p4567;
<PREPROCESSOR>#endif</PREPROCESSOR>
        }
        image <OPERATOR>+=</OPERATOR> <NUMERIC>4</NUMERIC>;
    }
}


<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC_MOB_COLLDET -- Do collision detection on all the MOBs.             */</COMMENT>
<COMMENT>/*                      <COMMENT_NOTE>XXX:</COMMENT_NOTE> h_dly and v_dly??                              */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
<CONSTANT>LOCAL</CONSTANT> <TYPE>void</TYPE> stic_mob_colldet(stic_t <OPERATOR>*</OPERATOR>stic)
{
    <TYPE>int</TYPE> mob0, mob1;
    <TYPE>int</TYPE> h_dly <OPERATOR>=</OPERATOR>  <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[<NUMERIC>0x30</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>7</NUMERIC>;
    <TYPE>int</TYPE> v_dly <OPERATOR>=</OPERATOR> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[<NUMERIC>0x31</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>7</NUMERIC>) <OPERATOR>*</OPERATOR> <NUMERIC>2</NUMERIC>;

    <KEYWORD>for</KEYWORD> (mob0 <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; mob0 <OPERATOR>&lt;</OPERATOR> <NUMERIC>8</NUMERIC>; mob0<OPERATOR>++</OPERATOR>)
    {
        <TYPE>int</TYPE> xl0, xh0;
        <TYPE>int</TYPE> yl0, yh0;
        <TYPE>int</TYPE> yhgt0 <OPERATOR>=</OPERATOR> stic_mob_hgt[(<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[mob0 <OPERATOR>+</OPERATOR> <NUMERIC>0x08</NUMERIC>] <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>7</NUMERIC>) <OPERATOR>&amp;</OPERATOR> <NUMERIC>7</NUMERIC>];
        <TYPE>int</TYPE> yshf0 <OPERATOR>=</OPERATOR> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[mob0 <OPERATOR>+</OPERATOR> <NUMERIC>0x08</NUMERIC>] <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>8</NUMERIC>) <OPERATOR>&amp;</OPERATOR> <NUMERIC>3</NUMERIC>;

        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  Decode the first MOB.  Reject it trivially if off screen or     */</COMMENT>
        <COMMENT>/*  non-interacting.                                                */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        xl0 <OPERATOR>=</OPERATOR> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[mob0 <OPERATOR>+</OPERATOR> <NUMERIC>0x00</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x1FF</NUMERIC>);     <COMMENT>/* X coord and INTR bit */</COMMENT>
        yl0 <OPERATOR>=</OPERATOR> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[mob0 <OPERATOR>+</OPERATOR> <NUMERIC>0x08</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x07F</NUMERIC>)<OPERATOR>&lt;&lt;</OPERATOR><NUMERIC>1</NUMERIC>;  <COMMENT>/* Y coord              */</COMMENT>

        xh0 <OPERATOR>=</OPERATOR> xl0 <OPERATOR>+</OPERATOR> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[mob0 <OPERATOR>+</OPERATOR> <NUMERIC>0x00</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x400</NUMERIC> <OPERATOR>?</OPERATOR> <NUMERIC>15</NUMERIC> <OPERATOR>:</OPERATOR> <NUMERIC>7</NUMERIC>);
        yh0 <OPERATOR>=</OPERATOR> yl0 <OPERATOR>+</OPERATOR> yhgt0 <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>;

        <KEYWORD>if</KEYWORD> (xl0 <OPERATOR>&lt;=</OPERATOR> <NUMERIC>0x100</NUMERIC> <OPERATOR>||</OPERATOR> xl0 <OPERATOR>&gt;=</OPERATOR> (<NUMERIC>0x1A8</NUMERIC><OPERATOR>-</OPERATOR>h_dly) <OPERATOR>||</OPERATOR> yl0 <OPERATOR>&gt;</OPERATOR> (<NUMERIC>0xD8</NUMERIC><OPERATOR>-</OPERATOR>v_dly))  
            <KEYWORD>continue</KEYWORD>;

        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  Generate 'edge mask' which discards pixels that are outside     */</COMMENT>
        <COMMENT>/*  the display area.                                               */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>

        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  Do MOB-to-MOB collision detection first.                        */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <KEYWORD>for</KEYWORD> (mob1 <OPERATOR>=</OPERATOR> mob0 <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>; mob1 <OPERATOR>&lt;</OPERATOR> <NUMERIC>8</NUMERIC>; mob1<OPERATOR>++</OPERATOR>)
        {
            <TYPE>int</TYPE> xl1, xh1;
            <TYPE>int</TYPE> yl1, yh1;
            <TYPE>int</TYPE> yhgt1 <OPERATOR>=</OPERATOR> stic_mob_hgt[(<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[mob1 <OPERATOR>+</OPERATOR> <NUMERIC>0x08</NUMERIC>] <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>7</NUMERIC>) <OPERATOR>&amp;</OPERATOR> <NUMERIC>7</NUMERIC>];
            <TYPE>int</TYPE> yshf1 <OPERATOR>=</OPERATOR> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[mob1 <OPERATOR>+</OPERATOR> <NUMERIC>0x08</NUMERIC>] <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>8</NUMERIC>) <OPERATOR>&amp;</OPERATOR> <NUMERIC>3</NUMERIC>;
            <TYPE>int</TYPE> ylo, yhi;
            <TYPE>int</TYPE> yy0, yy1, yy;
            <TYPE>int</TYPE> ls0, ls1;

            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            <COMMENT>/*  Super trivial reject:  If we already have a collision for   */</COMMENT>
            <COMMENT>/*  this MOB pair, we don't need to compute again -- it'd be    */</COMMENT>
            <COMMENT>/*  useless since we can only set bits to 1 and it's already 1. */</COMMENT>
            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            <KEYWORD>if</KEYWORD> (((<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[mob0 <OPERATOR>+</OPERATOR> <NUMERIC>0x18</NUMERIC>] <OPERATOR>&gt;&gt;</OPERATOR> mob1) <OPERATOR>&amp;</OPERATOR> <NUMERIC>1</NUMERIC>) <OPERATOR>&amp;&amp;</OPERATOR>
                ((<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[mob1 <OPERATOR>+</OPERATOR> <NUMERIC>0x18</NUMERIC>] <OPERATOR>&gt;&gt;</OPERATOR> mob0) <OPERATOR>&amp;</OPERATOR> <NUMERIC>1</NUMERIC>))
                <KEYWORD>continue</KEYWORD>;

            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            <COMMENT>/*  Decode second MOB.  Do same trivial reject.                 */</COMMENT>
            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            xl1 <OPERATOR>=</OPERATOR> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[mob1 <OPERATOR>+</OPERATOR> <NUMERIC>0x00</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x1FF</NUMERIC>);     
            yl1 <OPERATOR>=</OPERATOR> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[mob1 <OPERATOR>+</OPERATOR> <NUMERIC>0x08</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x07F</NUMERIC>)<OPERATOR>&lt;&lt;</OPERATOR><NUMERIC>1</NUMERIC>;  

            xh1 <OPERATOR>=</OPERATOR> xl1 <OPERATOR>+</OPERATOR> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[mob1 <OPERATOR>+</OPERATOR> <NUMERIC>0x00</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x400</NUMERIC> <OPERATOR>?</OPERATOR> <NUMERIC>15</NUMERIC> <OPERATOR>:</OPERATOR> <NUMERIC>7</NUMERIC>);
            yh1 <OPERATOR>=</OPERATOR> yl1 <OPERATOR>+</OPERATOR> yhgt1 <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>;

            <KEYWORD>if</KEYWORD> (xl1 <OPERATOR>&lt;=</OPERATOR> <NUMERIC>0x100</NUMERIC> <OPERATOR>||</OPERATOR> xl1 <OPERATOR>&gt;=</OPERATOR> (<NUMERIC>0x1A7</NUMERIC><OPERATOR>-</OPERATOR>h_dly) <OPERATOR>||</OPERATOR> yl1 <OPERATOR>&gt;</OPERATOR> (<NUMERIC>0xD8</NUMERIC><OPERATOR>-</OPERATOR>v_dly))  
                <KEYWORD>continue</KEYWORD>;

            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            <COMMENT>/*  Only slightly less trivial reject:  Bounding box compare    */</COMMENT>
            <COMMENT>/*  the two.  Basically, the left edge of one box must be       */</COMMENT>
            <COMMENT>/*  between left and right of the other.  Ditto for top edge    */</COMMENT>
            <COMMENT>/*  vs. top/bot for other.                                      */</COMMENT>
            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            <KEYWORD>if</KEYWORD> ((xl0 <OPERATOR>&lt;</OPERATOR> xl1 <OPERATOR>||</OPERATOR> xl0 <OPERATOR>&gt;</OPERATOR> xh1) <OPERATOR>&amp;&amp;</OPERATOR> (xl1 <OPERATOR>&lt;</OPERATOR> xl0 <OPERATOR>||</OPERATOR> xl1 <OPERATOR>&gt;</OPERATOR> xh0))
                <KEYWORD>continue</KEYWORD>;

            <KEYWORD>if</KEYWORD> ((yl0 <OPERATOR>&lt;</OPERATOR> yl1 <OPERATOR>||</OPERATOR> yl0 <OPERATOR>&gt;</OPERATOR> yh1) <OPERATOR>&amp;&amp;</OPERATOR> (yl1 <OPERATOR>&lt;</OPERATOR> yl0 <OPERATOR>||</OPERATOR> yl1 <OPERATOR>&gt;</OPERATOR> yh0))
                <KEYWORD>continue</KEYWORD>;

            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            <COMMENT>/*  Compute bitwise collision.                                  */</COMMENT>
            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            <KEYWORD>if</KEYWORD> (xl0 <OPERATOR>&lt;</OPERATOR> xl1) { ls0 <OPERATOR>=</OPERATOR> xl1 <OPERATOR>-</OPERATOR> xl0; ls1 <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; } 
            <KEYWORD>else</KEYWORD>           { ls1 <OPERATOR>=</OPERATOR> xl0 <OPERATOR>-</OPERATOR> xl1; ls0 <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>; }

            ylo <OPERATOR>=</OPERATOR> yl0 <OPERATOR>&gt;</OPERATOR> yl1 <OPERATOR>?</OPERATOR> yl0 <OPERATOR>:</OPERATOR> yl1;
            yhi <OPERATOR>=</OPERATOR> yh0 <OPERATOR>&lt;</OPERATOR> yh1 <OPERATOR>?</OPERATOR> yh0 <OPERATOR>:</OPERATOR> yh1;
            ylo <OPERATOR>=</OPERATOR> ylo <OPERATOR>&lt;</OPERATOR> <NUMERIC>15</NUMERIC>  <OPERATOR>-</OPERATOR> v_dly <OPERATOR>?</OPERATOR> <NUMERIC>15</NUMERIC>  <OPERATOR>-</OPERATOR> v_dly <OPERATOR>:</OPERATOR> 
                  ylo <OPERATOR>&gt;</OPERATOR> <NUMERIC>208</NUMERIC> <OPERATOR>-</OPERATOR> v_dly <OPERATOR>?</OPERATOR> <NUMERIC>208</NUMERIC> <OPERATOR>-</OPERATOR> v_dly <OPERATOR>:</OPERATOR> ylo;
            yhi <OPERATOR>=</OPERATOR> yhi <OPERATOR>&lt;</OPERATOR> <NUMERIC>15</NUMERIC>  <OPERATOR>-</OPERATOR> v_dly <OPERATOR>?</OPERATOR> <NUMERIC>15</NUMERIC>  <OPERATOR>-</OPERATOR> v_dly <OPERATOR>:</OPERATOR> 
                  yhi <OPERATOR>&gt;</OPERATOR> <NUMERIC>208</NUMERIC> <OPERATOR>-</OPERATOR> v_dly <OPERATOR>?</OPERATOR> <NUMERIC>208</NUMERIC> <OPERATOR>-</OPERATOR> v_dly <OPERATOR>:</OPERATOR> yhi;
            <KEYWORD>for</KEYWORD> (yy <OPERATOR>=</OPERATOR> ylo; yy <OPERATOR>&lt;=</OPERATOR> yhi; yy<OPERATOR>++</OPERATOR>)
            {
                uint_32 mb0, mb1;

                yy0 <OPERATOR>=</OPERATOR> (yy <OPERATOR>-</OPERATOR> yl0) <OPERATOR>&gt;&gt;</OPERATOR> yshf0;
                yy1 <OPERATOR>=</OPERATOR> (yy <OPERATOR>-</OPERATOR> yl1) <OPERATOR>&gt;&gt;</OPERATOR> yshf1;

                mb0 <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mob_bmp</OO>[mob0][yy0] <OPERATOR>&lt;&lt;</OPERATOR> ls0;
                mb1 <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mob_bmp</OO>[mob1][yy1] <OPERATOR>&lt;&lt;</OPERATOR> ls1;

                <KEYWORD>if</KEYWORD> (mb0 <OPERATOR>&amp;</OPERATOR> mb1) 
                    <KEYWORD>break</KEYWORD>;
            }

            <KEYWORD>if</KEYWORD> (yy <OPERATOR>&lt;=</OPERATOR> yhi)
            {
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[mob0 <OPERATOR>+</OPERATOR> <NUMERIC>0x18</NUMERIC>] <OPERATOR>|=</OPERATOR> <NUMERIC>1</NUMERIC> <OPERATOR>&lt;&lt;</OPERATOR> mob1;
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[mob1 <OPERATOR>+</OPERATOR> <NUMERIC>0x18</NUMERIC>] <OPERATOR>|=</OPERATOR> <NUMERIC>1</NUMERIC> <OPERATOR>&lt;&lt;</OPERATOR> mob0;
            }
        }

        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  Discard INTR bit from xl0, xh0.                                 */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        xl0 <OPERATOR>&amp;=</OPERATOR> <NUMERIC>0xFF</NUMERIC>;
        xh0 <OPERATOR>&amp;=</OPERATOR> <NUMERIC>0xFF</NUMERIC>;

        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  Do MOB-to-BACKTAB.  Skip this test if this bit is already 1.    */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <KEYWORD>if</KEYWORD> ((<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[mob0 <OPERATOR>+</OPERATOR> <NUMERIC>0x18</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x100</NUMERIC>) <OPERATOR>==</OPERATOR> <NUMERIC>0x000</NUMERIC>)
        {
            uint_32 bt;
            uint_32 bt_ls, bt_rs;
            <TYPE>int</TYPE> bt_idx, yy <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>, yy0;
            <TYPE>int</TYPE> ymax <OPERATOR>=</OPERATOR> yh0 <OPERATOR>&gt;</OPERATOR> (<NUMERIC>206</NUMERIC> <OPERATOR>-</OPERATOR> v_dly) <OPERATOR>?</OPERATOR> <NUMERIC>206</NUMERIC> <OPERATOR>-</OPERATOR> v_dly <OPERATOR>:</OPERATOR> yh0;

            bt_idx <OPERATOR>=</OPERATOR> yl0 <OPERATOR>*</OPERATOR> <NUMERIC>3</NUMERIC> <OPERATOR>+</OPERATOR> (xl0 <OPERATOR>&gt;&gt;</OPERATOR> <NUMERIC>5</NUMERIC>);
            bt_ls  <OPERATOR>=</OPERATOR> xl0 <OPERATOR>&amp;</OPERATOR> <NUMERIC>31</NUMERIC>;
            bt_rs  <OPERATOR>=</OPERATOR> <NUMERIC>32</NUMERIC> <OPERATOR>-</OPERATOR> bt_ls;

            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            <COMMENT>/*  Sadly, we need the 'if (bt_ls)' because &gt;&gt;32 is undefined.  */</COMMENT>
            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            <KEYWORD>if</KEYWORD> (bt_ls)
            {
                <KEYWORD>for</KEYWORD> (yy <OPERATOR>=</OPERATOR> yl0; yy <OPERATOR>&lt;=</OPERATOR> ymax; yy<OPERATOR>++</OPERATOR>)
                {
                    yy0 <OPERATOR>=</OPERATOR> (yy <OPERATOR>-</OPERATOR> yl0) <OPERATOR>&gt;&gt;</OPERATOR> yshf0;

                    bt <OPERATOR>=</OPERATOR> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>xbt_bmp</OO>[bt_idx    ] <OPERATOR>&lt;&lt;</OPERATOR> bt_ls) <OPERATOR>|</OPERATOR>
                         (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>xbt_bmp</OO>[bt_idx <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>] <OPERATOR>&gt;&gt;</OPERATOR> bt_rs);

                    <KEYWORD>if</KEYWORD> (bt <OPERATOR>&amp;</OPERATOR> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mob_bmp</OO>[mob0][yy0] <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>16</NUMERIC>))
                        <KEYWORD>break</KEYWORD>;
                    
                    <KEYWORD>if</KEYWORD> (yy <OPERATOR>&amp;</OPERATOR> <NUMERIC>1</NUMERIC>) bt_idx <OPERATOR>+=</OPERATOR> <NUMERIC>6</NUMERIC>;
                }
                <KEYWORD>if</KEYWORD> (yy <OPERATOR>&lt;=</OPERATOR> ymax)
                    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[mob0 <OPERATOR>+</OPERATOR> <NUMERIC>0x18</NUMERIC>] <OPERATOR>|=</OPERATOR> <NUMERIC>0x100</NUMERIC>;
            } <KEYWORD>else</KEYWORD>
            {
                <KEYWORD>for</KEYWORD> (yy <OPERATOR>=</OPERATOR> yl0; yy <OPERATOR>&lt;=</OPERATOR> ymax; yy<OPERATOR>++</OPERATOR>)
                {
                    yy0 <OPERATOR>=</OPERATOR> (yy <OPERATOR>-</OPERATOR> yl0) <OPERATOR>&gt;&gt;</OPERATOR> yshf0;

                    bt <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>xbt_bmp</OO>[bt_idx];

                    <KEYWORD>if</KEYWORD> (bt <OPERATOR>&amp;</OPERATOR> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mob_bmp</OO>[mob0][yy0] <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>16</NUMERIC>))
                        <KEYWORD>break</KEYWORD>;

                    <KEYWORD>if</KEYWORD> (yy <OPERATOR>&amp;</OPERATOR> <NUMERIC>1</NUMERIC>) bt_idx <OPERATOR>+=</OPERATOR> <NUMERIC>6</NUMERIC>;
                }
                <KEYWORD>if</KEYWORD> (yy <OPERATOR>&lt;=</OPERATOR> ymax)
                    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[mob0 <OPERATOR>+</OPERATOR> <NUMERIC>0x18</NUMERIC>] <OPERATOR>|=</OPERATOR> <NUMERIC>0x100</NUMERIC>;
            }
        }

        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <COMMENT>/*  Do MOB-to-Border.   Skip this test if this bit is already 1.    */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT>
        <KEYWORD>if</KEYWORD> ((<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[mob0 <OPERATOR>+</OPERATOR> <NUMERIC>0x18</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>0x200</NUMERIC>) <OPERATOR>==</OPERATOR> <NUMERIC>0x000</NUMERIC>)
        {
            uint_32 le_msk, re_msk, msk;
            <TYPE>int</TYPE> mx <OPERATOR>=</OPERATOR> xl0 <OPERATOR>+</OPERATOR> h_dly, my <OPERATOR>=</OPERATOR> yl0 <OPERATOR>+</OPERATOR> v_dly;
            <TYPE>int</TYPE> yy;
            <TYPE>int</TYPE> ymin;
            <TYPE>int</TYPE> ymax <OPERATOR>=</OPERATOR> (yh0 <OPERATOR>+</OPERATOR> v_dly) <OPERATOR>&lt;</OPERATOR> <NUMERIC>208</NUMERIC> <OPERATOR>?</OPERATOR> (yh0 <OPERATOR>+</OPERATOR> v_dly) <OPERATOR>:</OPERATOR> <NUMERIC>208</NUMERIC>;
            <TYPE>int</TYPE> ted  <OPERATOR>=</OPERATOR>       (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[<NUMERIC>0x32</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>2</NUMERIC>) <OPERATOR>?</OPERATOR> <NUMERIC>32</NUMERIC>    <OPERATOR>:</OPERATOR> <NUMERIC>16</NUMERIC>;
            uint_32 le_gen <OPERATOR>=</OPERATOR> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[<NUMERIC>0x32</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>1</NUMERIC>) <OPERATOR>?</OPERATOR> <NUMERIC>0x1FF</NUMERIC> <OPERATOR>:</OPERATOR> <NUMERIC>0x100</NUMERIC>;

            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            <COMMENT>/*  Compute left/right collisions by ANDing a bitmask with      */</COMMENT>
            <COMMENT>/*  each of the rows of the MOB bitmap that are inside the      */</COMMENT>
            <COMMENT>/*  visible field.  The "le_gen" takes into account edge ext.   */</COMMENT>
            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            le_msk <OPERATOR>=</OPERATOR> mx <OPERATOR>&lt;</OPERATOR> <NUMERIC>9</NUMERIC>   <OPERATOR>?</OPERATOR> le_gen <OPERATOR>&lt;&lt;</OPERATOR>  mx        <OPERATOR>:</OPERATOR> <NUMERIC>0</NUMERIC>;
            re_msk <OPERATOR>=</OPERATOR> mx <OPERATOR>&gt;</OPERATOR> <NUMERIC>150</NUMERIC> <OPERATOR>?</OPERATOR> <NUMERIC>0x8000</NUMERIC> <OPERATOR>&gt;&gt;</OPERATOR> (<NUMERIC>167</NUMERIC> <OPERATOR>-</OPERATOR> mx) <OPERATOR>:</OPERATOR> <NUMERIC>0</NUMERIC>;
            msk    <OPERATOR>=</OPERATOR> <NUMERIC>0xFFFF</NUMERIC> <OPERATOR>&amp;</OPERATOR> (le_msk <OPERATOR>|</OPERATOR> re_msk);

            <COMMENT>/* compute top/bottom rows that l/r edges might interact with */</COMMENT>
            ymax <OPERATOR>=</OPERATOR> (ymax <OPERATOR>-</OPERATOR> my) <OPERATOR>&gt;&gt;</OPERATOR> yshf0;
            ymin <OPERATOR>=</OPERATOR> my <OPERATOR>&lt;</OPERATOR> <NUMERIC>16</NUMERIC> <OPERATOR>?</OPERATOR> (<NUMERIC>15</NUMERIC> <OPERATOR>-</OPERATOR> my) <OPERATOR>&gt;&gt;</OPERATOR> yshf0 <OPERATOR>:</OPERATOR> <NUMERIC>0</NUMERIC>;
<COMMENT>//if (le_msk) jzp_printf("le_msk = %.8X mx = %-3d\n", le_msk, mx);</COMMENT>
<COMMENT>//if (re_msk) jzp_printf("re_msk = %.8X mx = %-3d\n", re_msk, mx);</COMMENT>

            <COMMENT>/* left, right edges */</COMMENT>
            <KEYWORD>for</KEYWORD> (yy <OPERATOR>=</OPERATOR> ymin; yy <OPERATOR>&lt;=</OPERATOR> ymax; yy<OPERATOR>++</OPERATOR>)
            {
                <KEYWORD>if</KEYWORD> (yy <OPERATOR>&lt;</OPERATOR> yhgt0 <OPERATOR>&amp;&amp;</OPERATOR>
                    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mob_bmp</OO>[mob0][yy] <OPERATOR>&amp;</OPERATOR> msk)
                    <KEYWORD>break</KEYWORD>;
            }
            <KEYWORD>if</KEYWORD> (yy <OPERATOR>&lt;=</OPERATOR> ymax)
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[mob0 <OPERATOR>+</OPERATOR> <NUMERIC>0x18</NUMERIC>] <OPERATOR>|=</OPERATOR> <NUMERIC>0x200</NUMERIC>;

            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            <COMMENT>/*  Compute top/bottom collisions by examining the row(s) that  */</COMMENT>
            <COMMENT>/*  might intersect with either edge.  We regenerate the left/  */</COMMENT>
            <COMMENT>/*  right masks ignoring border extension, so that we can use   */</COMMENT>
            <COMMENT>/*  them to mask away the pixels that aren't included in the    */</COMMENT>
            <COMMENT>/*  computation.                                                */</COMMENT>;
            <COMMENT>/* ------------------------------------------------------------ */</COMMENT>
            le_msk <OPERATOR>=</OPERATOR> mx <OPERATOR>&lt;</OPERATOR> <NUMERIC>8</NUMERIC> <OPERATOR>?</OPERATOR> <NUMERIC>0xFFFFFE00</NUMERIC> <OPERATOR>&lt;&lt;</OPERATOR> mx <OPERATOR>:</OPERATOR> <NUMERIC>0</NUMERIC>;      <COMMENT>/* extend lft mask */</COMMENT>
            re_msk <OPERATOR>=</OPERATOR> re_msk <OPERATOR>?</OPERATOR> (re_msk <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>1</NUMERIC>)<OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC> <OPERATOR>:</OPERATOR> <NUMERIC>0</NUMERIC>;      <COMMENT>/* extend rgt mask */</COMMENT>
            msk    <OPERATOR>=</OPERATOR> <OPERATOR>~</OPERATOR>(le_msk <OPERATOR>|</OPERATOR> re_msk);

            <COMMENT>/* top edge */</COMMENT>
            <KEYWORD>if</KEYWORD> (my <OPERATOR>&lt;=</OPERATOR> ted)
            {
<COMMENT>//jzp_printf("ted=%-2d my=%-2d:", ted, my);</COMMENT>
                <KEYWORD>for</KEYWORD> (yy <OPERATOR>=</OPERATOR> <NUMERIC>15</NUMERIC>; yy <OPERATOR>&lt;</OPERATOR> ted; yy <OPERATOR>+=</OPERATOR> (<NUMERIC>1</NUMERIC> <OPERATOR>&lt;&lt;</OPERATOR> yshf0))
                {
                    <KEYWORD>if</KEYWORD> (my <OPERATOR>&lt;=</OPERATOR> yy)
                    {
                        <TYPE>int</TYPE> row <OPERATOR>=</OPERATOR> (yy <OPERATOR>-</OPERATOR> my) <OPERATOR>&gt;&gt;</OPERATOR> yshf0;
                        <KEYWORD>if</KEYWORD> (row <OPERATOR>&lt;</OPERATOR> yhgt0 <OPERATOR>&amp;&amp;</OPERATOR>
                            <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mob_bmp</OO>[mob0][row] <OPERATOR>&amp;</OPERATOR> msk)
                        {
<COMMENT>//jzp_printf(" %2d,%-2d", yy, row);</COMMENT>
                                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[mob0 <OPERATOR>+</OPERATOR> <NUMERIC>0x18</NUMERIC>] <OPERATOR>|=</OPERATOR> <NUMERIC>0x200</NUMERIC>;
                        }
                    }
                }
<COMMENT>//putchar('\n');</COMMENT>
            }

            <COMMENT>/* bottom edge */</COMMENT>
            <KEYWORD>if</KEYWORD> (yh0 <OPERATOR>+</OPERATOR> v_dly <OPERATOR>&gt;=</OPERATOR> <NUMERIC>207</NUMERIC>)
            {
                <TYPE>int</TYPE> ybot <OPERATOR>=</OPERATOR> (<NUMERIC>208</NUMERIC> <OPERATOR>-</OPERATOR> my) <OPERATOR>&gt;&gt;</OPERATOR> yshf0;

                <KEYWORD>if</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>mob_bmp</OO>[mob0][ybot] <OPERATOR>&amp;</OPERATOR> msk)
                    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[mob0 <OPERATOR>+</OPERATOR> <NUMERIC>0x18</NUMERIC>] <OPERATOR>|=</OPERATOR> <NUMERIC>0x200</NUMERIC>;
            }
        }
    }
}

<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC_UPDATE -- wrapper around all the pieces above.                     */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
<PREPROCESSOR>#ifdef BENCHMARK_STIC</PREPROCESSOR>
<CONSTANT>LOCAL</CONSTANT> <TYPE>void</TYPE> stic_update(stic_t <OPERATOR>*</OPERATOR>stic)
{
    <TYPE>double</TYPE> a, b, c;
    <KEYWORD>static</KEYWORD> <TYPE>double</TYPE> ovhd <OPERATOR>=</OPERATOR> <NUMERIC>1e6</NUMERIC>;

    a <OPERATOR>=</OPERATOR> get_time();
    b <OPERATOR>=</OPERATOR> get_time();
    <KEYWORD>if</KEYWORD> (b <OPERATOR>-</OPERATOR> a <OPERATOR>&lt;</OPERATOR> ovhd) ovhd <OPERATOR>=</OPERATOR> b <OPERATOR>-</OPERATOR> a;
    a <OPERATOR>=</OPERATOR> b;

    <COMMENT>/* draw the backtab */</COMMENT>
    <KEYWORD>if</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>upd</OO>) <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>upd</OO>(stic);
    c <OPERATOR>=</OPERATOR> get_time(); <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>time</OO><OPERATOR>.</OPERATOR><OO>draw_btab</OO>    <OPERATOR>+=</OPERATOR> c <OPERATOR>-</OPERATOR> b <OPERATOR>-</OPERATOR> ovhd; b <OPERATOR>=</OPERATOR> c;

    stic_draw_mobs   (stic);
    c <OPERATOR>=</OPERATOR> get_time(); <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>time</OO><OPERATOR>.</OPERATOR><OO>draw_mobs</OO>    <OPERATOR>+=</OPERATOR> c <OPERATOR>-</OPERATOR> b <OPERATOR>-</OPERATOR> ovhd; b <OPERATOR>=</OPERATOR> c;
    stic_fix_bord    (stic);
    c <OPERATOR>=</OPERATOR> get_time(); <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>time</OO><OPERATOR>.</OPERATOR><OO>fix_bord</OO>     <OPERATOR>+=</OPERATOR> c <OPERATOR>-</OPERATOR> b <OPERATOR>-</OPERATOR> ovhd; b <OPERATOR>=</OPERATOR> c;
    stic_merge_planes(stic);
    c <OPERATOR>=</OPERATOR> get_time(); <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>time</OO><OPERATOR>.</OPERATOR><OO>merge_planes</OO> <OPERATOR>+=</OPERATOR> c <OPERATOR>-</OPERATOR> b <OPERATOR>-</OPERATOR> ovhd; b <OPERATOR>=</OPERATOR> c;

    <KEYWORD>if</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>drop_frame</OO> <OPERATOR>&lt;=</OPERATOR> <NUMERIC>0</NUMERIC>)
    {
        stic_push_vid    (stic);
        c <OPERATOR>=</OPERATOR> get_time(); <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>time</OO><OPERATOR>.</OPERATOR><OO>push_vid</OO>     <OPERATOR>+=</OPERATOR> c <OPERATOR>-</OPERATOR> b <OPERATOR>-</OPERATOR> ovhd; b <OPERATOR>=</OPERATOR> c;
    } <KEYWORD>else</KEYWORD>
        <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>drop_frame</OO><OPERATOR>--</OPERATOR>;

    stic_mob_colldet (stic);
    c <OPERATOR>=</OPERATOR> get_time(); <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>time</OO><OPERATOR>.</OPERATOR><OO>mob_colldet</OO>  <OPERATOR>+=</OPERATOR> c <OPERATOR>-</OPERATOR> b <OPERATOR>-</OPERATOR> ovhd; b <OPERATOR>=</OPERATOR> c;

<COMMENT>//    if (last_enable != stic-&gt;vid_enable)</COMMENT>
    c <OPERATOR>=</OPERATOR> get_time(); <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>time</OO><OPERATOR>.</OPERATOR><OO>gfx_vid_enable</OO> <OPERATOR>+=</OPERATOR> c <OPERATOR>-</OPERATOR> b <OPERATOR>-</OPERATOR> ovhd; 

    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>time</OO><OPERATOR>.</OPERATOR><OO>full_update</OO>  <OPERATOR>+=</OPERATOR> c <OPERATOR>-</OPERATOR> a <OPERATOR>-</OPERATOR> <NUMERIC>7</NUMERIC><OPERATOR>*</OPERATOR>ovhd;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>time</OO><OPERATOR>.</OPERATOR><OO>total_frames</OO><OPERATOR>++</OPERATOR>;

    <KEYWORD>if</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>time</OO><OPERATOR>.</OPERATOR><OO>total_frames</OO> <OPERATOR>&gt;=</OPERATOR> <NUMERIC>100</NUMERIC>)
    {
        <TYPE>double</TYPE> scale <OPERATOR>=</OPERATOR> <NUMERIC>1e6</NUMERIC> <OPERATOR>/</OPERATOR> (<TYPE>double</TYPE>)<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>time</OO><OPERATOR>.</OPERATOR><OO>total_frames</OO>;

        jzp_printf(<STRING>"stic performance update:<ESC>\n</ESC>"</STRING>);
        jzp_printf(<STRING>"  draw_btab    %9.4f usec<ESC>\n</ESC>"</STRING>, <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>time</OO><OPERATOR>.</OPERATOR><OO>draw_btab</OO>    <OPERATOR>*</OPERATOR> scale);
        jzp_printf(<STRING>"  draw_mobs    %9.4f usec<ESC>\n</ESC>"</STRING>, <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>time</OO><OPERATOR>.</OPERATOR><OO>draw_mobs</OO>    <OPERATOR>*</OPERATOR> scale);
        jzp_printf(<STRING>"  fix_bord     %9.4f usec<ESC>\n</ESC>"</STRING>, <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>time</OO><OPERATOR>.</OPERATOR><OO>fix_bord</OO>     <OPERATOR>*</OPERATOR> scale);
        jzp_printf(<STRING>"  merge_planes %9.4f usec<ESC>\n</ESC>"</STRING>, <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>time</OO><OPERATOR>.</OPERATOR><OO>merge_planes</OO> <OPERATOR>*</OPERATOR> scale);
        jzp_printf(<STRING>"  push_vid     %9.4f usec<ESC>\n</ESC>"</STRING>, <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>time</OO><OPERATOR>.</OPERATOR><OO>push_vid</OO>     <OPERATOR>*</OPERATOR> scale);
        jzp_printf(<STRING>"  mob_colldet  %9.4f usec<ESC>\n</ESC>"</STRING>, <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>time</OO><OPERATOR>.</OPERATOR><OO>mob_colldet</OO>  <OPERATOR>*</OPERATOR> scale);
        jzp_printf(<STRING>"  vid_enable   %9.4f usec<ESC>\n</ESC>"</STRING>, <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>time</OO><OPERATOR>.</OPERATOR><OO>gfx_vid_enable</OO><OPERATOR>*</OPERATOR>scale);
        jzp_printf(<STRING>"  TOTAL:       %9.4f usec<ESC>\n</ESC>"</STRING>, <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>time</OO><OPERATOR>.</OPERATOR><OO>full_update</OO>  <OPERATOR>*</OPERATOR> scale);

        jzp_flush();
            
        <FUNCTION>memset</FUNCTION>((<TYPE>void</TYPE><OPERATOR>*</OPERATOR>)<OPERATOR>&amp;</OPERATOR><OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>time</OO>, <NUMERIC>0</NUMERIC>, <KEYWORD>sizeof</KEYWORD>(<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>time</OO>));
    }
}
<PREPROCESSOR>#else</PREPROCESSOR>
<CONSTANT>LOCAL</CONSTANT> <TYPE>void</TYPE> stic_update(stic_t <OPERATOR>*</OPERATOR>stic)
{
    <COMMENT>/* draw the backtab */</COMMENT>
    <KEYWORD>if</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>upd</OO>) <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>upd</OO>(stic);

    stic_draw_mobs   (stic);
    stic_fix_bord    (stic);
    stic_merge_planes(stic);

    <KEYWORD>if</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>drop_frame</OO> <OPERATOR>&lt;=</OPERATOR> <NUMERIC>0</NUMERIC>)
        stic_push_vid    (stic);
    <KEYWORD>else</KEYWORD>
        <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>drop_frame</OO><OPERATOR>--</OPERATOR>;

    stic_mob_colldet (stic);

    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gfx</OO><OPERATOR>-&gt;</OPERATOR><OO>dirty</OO> <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC>;
<COMMENT>//    if (last_enable != stic-&gt;vid_enable)</COMMENT>
}
<PREPROCESSOR>#endif</PREPROCESSOR>

<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  STIC_TICK -- Ugh, this is where the action happens.  Whee.              */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
uint_32 stic_tick
(
    periph_p        per,
    uint_32         len
)
{
    stic_t <OPERATOR>*</OPERATOR>stic <OPERATOR>=</OPERATOR> (stic_t<OPERATOR>*</OPERATOR>)<OBJ>per</OBJ><OPERATOR>-&gt;</OPERATOR><OO>parent</OO>;
    uint_64 now <OPERATOR>=</OPERATOR> <OBJ>per</OBJ><OPERATOR>-&gt;</OPERATOR><OO>now</OO>, soon;
    uint_32 new_phase, phase_len;

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT> 
    <COMMENT>/*  See if we're being ticked for too little or too much time.  This    */</COMMENT>
    <COMMENT>/*  shouldn't happen, in theory, but it might.                          */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT> 
    <KEYWORD>if</KEYWORD> (now <OPERATOR>+</OPERATOR> len <OPERATOR>&lt;</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>next_phase</OO>)
    {
        <COMMENT>//jzp_printf("short tick = %d\n", len);</COMMENT>
        <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>stic_cr</OO><OPERATOR>.</OPERATOR><OO>max_tick</OO> <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>next_phase</OO> <OPERATOR>-</OPERATOR> now;
        <KEYWORD>return</KEYWORD> len;
    }
    <KEYWORD>if</KEYWORD> (now <OPERATOR>+</OPERATOR> len <OPERATOR>&gt;</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>next_phase</OO>)
    {
        len <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>next_phase</OO> <OPERATOR>-</OPERATOR> now;
    }

<COMMENT>//jzp_printf("stic-&gt;phase = %d now = %d len = %d\n", stic-&gt;phase, (int)now, (int)len);</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT> 
    <COMMENT>/*  Toggle the phases and get out of here.                              */</COMMENT>
    <COMMENT>/*                                                                      */</COMMENT>
    <COMMENT>/*  PHASE  Length             Action                                    */</COMMENT>
    <COMMENT>/*    0    STIC_ACCESSIBLE    Start VBlank.  STIC &amp; GMEM accessible     */</COMMENT>
    <COMMENT>/*                                                                      */</COMMENT>
    <COMMENT>/*    1    GMEM_ACCESSIBLE    STIC registers unavailable.  INTRQ goes   */</COMMENT>
    <COMMENT>/*         - STIC_ACCESSIBLE  away if not INTAK'd.                      */</COMMENT>
    <COMMENT>/*                                                                      */</COMMENT>
    <COMMENT>/*    2    114*v_dly + h_dly  GRAM/GROM unavailable.  Short initial     */</COMMENT>
    <COMMENT>/*         + 143              BUSRQ (kicks System RAM into isolation).  */</COMMENT>
    <COMMENT>/*                                                                      */</COMMENT>
    <COMMENT>/*  3..13  912                BUSRQ for row 0..11.  Copy cards for the  */</COMMENT>
    <COMMENT>/*                            previous row in states 4 .. 14.           */</COMMENT>
    <COMMENT>/*                                                                      */</COMMENT>
    <COMMENT>/*   14    912 - 114*v_dly    BUSRQ for row 0..11.  Copy cards for the  */</COMMENT>
    <COMMENT>/*         - h_dly            previous row in states 4 .. 14.           */</COMMENT>
    <COMMENT>/*                                                                      */</COMMENT>
    <COMMENT>/*   15    57.                Extra BUSRQ if v_dly == 0.   Copy cards   */</COMMENT>
    <COMMENT>/*                            for last row.                             */</COMMENT>
    <COMMENT>/*                                                                      */</COMMENT>
    <COMMENT>/*   16    STIC_FRAMCLKS      If video is blanked, leave everything     */</COMMENT>  
    <COMMENT>/*         - STIC_ACCESSIBLE  accessible.  Replaces phases 2..15.       */</COMMENT>
    <COMMENT>/*                                                                      */</COMMENT>
    <COMMENT>/*                                                                      */</COMMENT>
    <COMMENT>/*  This gets complicated, though.  Time delays and anything from       */</COMMENT>
    <COMMENT>/*  CPU-&gt;STIC has to happen with the current phase.  Anything going     */</COMMENT>
    <COMMENT>/*  from STIC-&gt;CPU has to happen with the next phase.                   */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT> 

    new_phase <OPERATOR>=</OPERATOR> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>phase</OO> <OPERATOR>+</OPERATOR> <NUMERIC>1</NUMERIC>) <OPERATOR>&amp;</OPERATOR> <NUMERIC>15</NUMERIC>;
    soon <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>next_phase</OO>;

    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT> 
    <COMMENT>/*  CPU-&gt;STIC and phase timing happens with current phase.              */</COMMENT>
    <COMMENT>/* -------------------------------------------------------------------- */</COMMENT> 
    <KEYWORD>switch</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>phase</OO>)
    {
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT> 
        <COMMENT>/*  PHASE 0:  Start of vertical blanking interval.                  */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT> 
        <KEYWORD>case</KEYWORD> <NUMERIC>0</NUMERIC><OPERATOR>:</OPERATOR>
        {
            <KEYWORD>if</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>vid_enable</OO>)
                stic_update(stic);
            <KEYWORD>else</KEYWORD>
                <KEYWORD>if</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>drop_frame</OO> <OPERATOR>&gt;</OPERATOR> <NUMERIC>0</NUMERIC>)
                    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>drop_frame</OO><OPERATOR>--</OPERATOR>;

            <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gfx</OO><OPERATOR>-&gt;</OPERATOR><OO>dirty</OO> <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC>;
            gfx_vid_enable(<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gfx</OO>, <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>vid_enable</OO>);

            <KEYWORD>if</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO>)
            {
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>intrq</OO>       <OPERATOR>=</OPERATOR> <CONSTANT>ASSERT_INTRQ</CONSTANT>;
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>intrq_until</OO> <OPERATOR>=</OPERATOR> soon <OPERATOR>+</OPERATOR> <CONSTANT>STIC_INTRQ_HOLD</CONSTANT>;
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>next_intrq</OO>  <OPERATOR>=</OPERATOR> soon <OPERATOR>+</OPERATOR> <CONSTANT>STIC_FRAMCLKS</CONSTANT> <OPERATOR>-</OPERATOR> <NUMERIC>1</NUMERIC>;

                <COMMENT>/* Require INTAK if previous frame enabled. */</COMMENT>
                <KEYWORD>if</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>vid_enable</OO>)
                    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>intak</OO> <OPERATOR>=</OPERATOR> <OPERATOR>~</OPERATOR><NUMERIC>0ULL</NUMERIC>;

<COMMENT>//jzp_printf("asserted INTRQ(1), now = %d, soon = %d, len = %d, until = %d\n", (int)now, (int)soon, (int)len, (int)stic-&gt;req_bus-&gt;intrq_until);</COMMENT>
            }
            <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>vid_enable</OO>       <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
            <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>ve_post</OO>          <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
            <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>bt_dirty</OO>         <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
            <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gr_dirty</OO>         <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
            <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>ob_dirty</OO>         <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
            <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>stic_accessible</OO>  <OPERATOR>=</OPERATOR> soon <OPERATOR>+</OPERATOR> <CONSTANT>STIC_STIC_ACCESSIBLE</CONSTANT>;
            <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gmem_accessible</OO>  <OPERATOR>=</OPERATOR> soon <OPERATOR>+</OPERATOR> <CONSTANT>STIC_GMEM_ACCESSIBLE</CONSTANT>;
            phase_len              <OPERATOR>=</OPERATOR> <CONSTANT>STIC_STIC_ACCESSIBLE</CONSTANT>;

            <COMMENT>/* ------------------------------------------------------------ */</COMMENT> 
            <COMMENT>/*  Update the demo recorder, if one's active.                  */</COMMENT>
            <COMMENT>/* ------------------------------------------------------------ */</COMMENT> 
            <KEYWORD>if</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>demo</OO>)
                demo_tick(<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>demo</OO>, stic);

            <KEYWORD>break</KEYWORD>;
        }

        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT> 
        <COMMENT>/*  PHASE 1:  Make STIC registers inaccessible if disp enabled.     */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT> 
        <KEYWORD>case</KEYWORD> <NUMERIC>1</NUMERIC><OPERATOR>:</OPERATOR>
        {
            phase_len <OPERATOR>=</OPERATOR> <CONSTANT>STIC_GMEM_ACCESSIBLE</CONSTANT> <OPERATOR>-</OPERATOR> <CONSTANT>STIC_STIC_ACCESSIBLE</CONSTANT>;

            <COMMENT>/* ------------------------------------------------------------ */</COMMENT> 
            <COMMENT>/*  Enable/disable video.                                       */</COMMENT>
            <COMMENT>/* ------------------------------------------------------------ */</COMMENT> 
            <KEYWORD>if</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>vid_enable</OO> <OPERATOR>!=</OPERATOR> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>ve_post</OO><OPERATOR>!=</OPERATOR><NUMERIC>0</NUMERIC>))
            {
<COMMENT>//              extern int last_dis, first_dis;</COMMENT>
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>bt_dirty</OO> <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC>;
<COMMENT>//              if ((stic-&gt;ve_post &amp; 1) == 0) </COMMENT>
<COMMENT>//                  jzp_printf("DIS addrs: $%.4X $%.4X\n", </COMMENT>
<COMMENT>//                         0xFFFF&amp;first_dis,  0xFFFF&amp;last_dis);</COMMENT>
            }
<COMMENT>//jzp_printf("ve_post = %d\n", stic-&gt;ve_post);</COMMENT>
            <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>vid_enable</OO> <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>ve_post</OO> <OPERATOR>&amp;</OPERATOR> <NUMERIC>1</NUMERIC>;
            <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>ve_post</OO>    <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>vid_enable</OO> <OPERATOR>&lt;&lt;</OPERATOR> <NUMERIC>1</NUMERIC>;

            <COMMENT>/* ------------------------------------------------------------ */</COMMENT> 
            <COMMENT>/*  If video isn't enabled, let CPU access STIC resources for   */</COMMENT>
            <COMMENT>/*  as long as it likes.                                        */</COMMENT>
            <COMMENT>/* ------------------------------------------------------------ */</COMMENT> 
            <KEYWORD>if</KEYWORD> (<OPERATOR>!</OPERATOR><OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>vid_enable</OO>) 
            {
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>stic_accessible</OO> <OPERATOR>=</OPERATOR> <OPERATOR>~</OPERATOR><NUMERIC>0ULL</NUMERIC>;
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>gmem_accessible</OO> <OPERATOR>=</OPERATOR> <OPERATOR>~</OPERATOR><NUMERIC>0ULL</NUMERIC>;
            } <KEYWORD>else</KEYWORD>
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>next_busrq</OO> <OPERATOR>=</OPERATOR> soon <OPERATOR>+</OPERATOR> phase_len;
            <KEYWORD>break</KEYWORD>;
        }

        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT> 
        <COMMENT>/*  PHASE 2:  Do the short BUSRQ.                                   */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT> 
        <KEYWORD>case</KEYWORD> <NUMERIC>2</NUMERIC><OPERATOR>:</OPERATOR>
        {
            <TYPE>int</TYPE> v_dly, h_dly;
            h_dly <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[<NUMERIC>0x30</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>7</NUMERIC>;
            v_dly <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[<NUMERIC>0x31</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>7</NUMERIC>;
            phase_len <OPERATOR>=</OPERATOR> <NUMERIC>120</NUMERIC> <OPERATOR>+</OPERATOR> <NUMERIC>114</NUMERIC><OPERATOR>*</OPERATOR>v_dly <OPERATOR>+</OPERATOR> h_dly;

            <KEYWORD>if</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>vid_enable</OO> <OPERATOR>&amp;&amp;</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO>)
            {
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>intrq</OO>       <OPERATOR>=</OPERATOR> <CONSTANT>ASSERT_BUSRQ</CONSTANT>;
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>busrq_until</OO> <OPERATOR>=</OPERATOR> soon <OPERATOR>+</OPERATOR> <CONSTANT>STIC_BUSRQ_HOLD_FIRST</CONSTANT>;
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>next_busrq</OO>  <OPERATOR>=</OPERATOR> soon <OPERATOR>+</OPERATOR> phase_len;
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>busak</OO>       <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
<COMMENT>//jzp_printf("asserted BUSRQ(1), now = %d, soon = %d, len = %d, until = %d\n", (int)now, (int)soon, (int)len, (int)stic-&gt;req_bus-&gt;busrq_until);</COMMENT>
            }
            <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>fifo_ptr</OO> <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
            
            <KEYWORD>break</KEYWORD>;
        }

        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT> 
        <COMMENT>/*  PHASE 3..13:  Do full-length BUSRQs, and copy cards from BTAB.  */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT> 
        <KEYWORD>case</KEYWORD>  <NUMERIC>3</NUMERIC><OPERATOR>:</OPERATOR> <KEYWORD>case</KEYWORD>  <NUMERIC>4</NUMERIC><OPERATOR>:</OPERATOR> <KEYWORD>case</KEYWORD>  <NUMERIC>5</NUMERIC><OPERATOR>:</OPERATOR> <KEYWORD>case</KEYWORD>  <NUMERIC>6</NUMERIC><OPERATOR>:</OPERATOR> <KEYWORD>case</KEYWORD> <NUMERIC>7</NUMERIC><OPERATOR>:</OPERATOR> <KEYWORD>case</KEYWORD> <NUMERIC>8</NUMERIC><OPERATOR>:</OPERATOR> <KEYWORD>case</KEYWORD> <NUMERIC>9</NUMERIC><OPERATOR>:</OPERATOR> 
        <KEYWORD>case</KEYWORD> <NUMERIC>10</NUMERIC><OPERATOR>:</OPERATOR> <KEYWORD>case</KEYWORD> <NUMERIC>11</NUMERIC><OPERATOR>:</OPERATOR> <KEYWORD>case</KEYWORD> <NUMERIC>12</NUMERIC><OPERATOR>:</OPERATOR> <KEYWORD>case</KEYWORD> <NUMERIC>13</NUMERIC><OPERATOR>:</OPERATOR>
        {
            phase_len <OPERATOR>=</OPERATOR> <NUMERIC>912</NUMERIC>;

            <KEYWORD>if</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>phase</OO> <OPERATOR>&gt;</OPERATOR> <NUMERIC>3</NUMERIC> <OPERATOR>&amp;&amp;</OPERATOR> 
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>busak</OO> <OPERATOR>&lt;=</OPERATOR> 
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>busrq_until</OO> <OPERATOR>-</OPERATOR> <CONSTANT>STIC_BUSRQ_MARGIN</CONSTANT>)
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>fifo_ptr</OO> <OPERATOR>+=</OPERATOR> <NUMERIC>20</NUMERIC>;

            <FUNCTION>memcpy</FUNCTION>(<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>btab</OO> <OPERATOR>+</OPERATOR> <NUMERIC>20</NUMERIC><OPERATOR>*</OPERATOR>(<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>phase</OO><OPERATOR>-</OPERATOR><NUMERIC>3</NUMERIC>), 
                   <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>btab_sr</OO> <OPERATOR>+</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>fifo_ptr</OO>, <NUMERIC>20</NUMERIC><OPERATOR>*</OPERATOR><KEYWORD>sizeof</KEYWORD>(uint_16));
            
            <KEYWORD>if</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>vid_enable</OO> <OPERATOR>&amp;&amp;</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO>)
            {
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>intrq</OO>       <OPERATOR>=</OPERATOR> <CONSTANT>ASSERT_BUSRQ</CONSTANT>;
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>busrq_until</OO> <OPERATOR>=</OPERATOR> soon <OPERATOR>+</OPERATOR> <CONSTANT>STIC_BUSRQ_HOLD_NORMAL</CONSTANT>;
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>next_busrq</OO>  <OPERATOR>=</OPERATOR> soon <OPERATOR>+</OPERATOR> phase_len;
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>busak</OO>       <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
<COMMENT>//jzp_printf("asserted BUSRQ(n), now = %d, soon = %d, len = %d, until = %d\n", (int)now, (int)soon, (int)len, (int)stic-&gt;req_bus-&gt;busrq_until);</COMMENT>
            }

            <KEYWORD>break</KEYWORD>;
        }

        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT> 
        <COMMENT>/*  PHASE 14:  Do last full BUSRQ.  This phase differs from phases  */</COMMENT>
        <COMMENT>/*             3..13 only by its cycle length.                      */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT> 
        <KEYWORD>case</KEYWORD> <NUMERIC>14</NUMERIC><OPERATOR>:</OPERATOR>
        {
            <TYPE>int</TYPE> v_dly, h_dly;
            h_dly <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[<NUMERIC>0x30</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>7</NUMERIC>;
            v_dly <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[<NUMERIC>0x31</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>7</NUMERIC>;
            phase_len <OPERATOR>=</OPERATOR> <NUMERIC>912</NUMERIC> <OPERATOR>-</OPERATOR> <NUMERIC>114</NUMERIC><OPERATOR>*</OPERATOR>v_dly <OPERATOR>-</OPERATOR> h_dly;
            
            <KEYWORD>if</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>busak</OO> <OPERATOR>&lt;=</OPERATOR> 
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>busrq_until</OO> <OPERATOR>-</OPERATOR> <CONSTANT>STIC_BUSRQ_MARGIN</CONSTANT>)
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>fifo_ptr</OO> <OPERATOR>+=</OPERATOR> <NUMERIC>20</NUMERIC>;

            <FUNCTION>memcpy</FUNCTION>(<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>btab</OO> <OPERATOR>+</OPERATOR> <NUMERIC>20</NUMERIC><OPERATOR>*</OPERATOR>(<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>phase</OO><OPERATOR>-</OPERATOR><NUMERIC>3</NUMERIC>), 
                   <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>btab_sr</OO> <OPERATOR>+</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>fifo_ptr</OO>, <NUMERIC>20</NUMERIC><OPERATOR>*</OPERATOR><KEYWORD>sizeof</KEYWORD>(uint_16));
        
            <KEYWORD>if</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>vid_enable</OO> <OPERATOR>&amp;&amp;</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO>)
            {
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>intrq</OO>       <OPERATOR>=</OPERATOR> <CONSTANT>ASSERT_BUSRQ</CONSTANT>;
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>busrq_until</OO> <OPERATOR>=</OPERATOR> soon <OPERATOR>+</OPERATOR> <CONSTANT>STIC_BUSRQ_HOLD_NORMAL</CONSTANT>;
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>next_busrq</OO>  <OPERATOR>=</OPERATOR> soon <OPERATOR>+</OPERATOR> phase_len;
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>busak</OO>       <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
<COMMENT>//jzp_printf("asserted BUSRQ(13), now = %d, soon = %d, len = %d, until = %d\n", (int)now, (int)soon, (int)len, (int)stic-&gt;req_bus-&gt;busrq_until);</COMMENT>
            }

            <KEYWORD>break</KEYWORD>;
        }

        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT> 
        <COMMENT>/*  PHASE 15:  Do partial BUSRQ.  This BUSRQ happens only if the    */</COMMENT>
        <COMMENT>/*             vertical delay is zero.                              */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT> 
        <KEYWORD>case</KEYWORD> <NUMERIC>15</NUMERIC><OPERATOR>:</OPERATOR>
        {
            <TYPE>int</TYPE> v_dly <OPERATOR>=</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>raw</OO>[<NUMERIC>0x31</NUMERIC>] <OPERATOR>&amp;</OPERATOR> <NUMERIC>7</NUMERIC>;

            <KEYWORD>if</KEYWORD> (<OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>vid_enable</OO> <OPERATOR>&amp;&amp;</OPERATOR> (v_dly <OPERATOR>==</OPERATOR> <NUMERIC>0</NUMERIC>) <OPERATOR>&amp;&amp;</OPERATOR> <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO>)
            {
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>intrq</OO>       <OPERATOR>=</OPERATOR> <CONSTANT>ASSERT_BUSRQ</CONSTANT>;
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>busrq_until</OO> <OPERATOR>=</OPERATOR> soon <OPERATOR>+</OPERATOR> <CONSTANT>STIC_BUSRQ_HOLD_EXTRA</CONSTANT>;
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>next_busrq</OO>  <OPERATOR>=</OPERATOR> <OPERATOR>~</OPERATOR><NUMERIC>0ULL</NUMERIC>;
                <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>req_bus</OO><OPERATOR>-&gt;</OPERATOR><OO>busak</OO>       <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
<COMMENT>//jzp_printf("asserted BUSRQ(14), now = %d, soon = %d, len = %d, until = %d\n", (int)now, (int)soon, (int)len, (int)stic-&gt;req_bus-&gt;busrq_until);</COMMENT>
            }
            phase_len <OPERATOR>=</OPERATOR> <NUMERIC>57</NUMERIC> <OPERATOR>+</OPERATOR> <NUMERIC>17</NUMERIC>;
            new_phase <OPERATOR>=</OPERATOR> <NUMERIC>0</NUMERIC>;
            <KEYWORD>break</KEYWORD>;
        }


        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT> 
        <COMMENT>/*  Not supposed to happen.                                         */</COMMENT>
        <COMMENT>/* ---------------------------------------------------------------- */</COMMENT> 
        <KEYWORD>default</KEYWORD><OPERATOR>:</OPERATOR>
        {
            <FUNCTION>fprintf</FUNCTION>(stderr, <STRING>"FATAL ERROR in STIC, phase = %d<ESC>\n</ESC>"</STRING>, <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>phase</OO>);
            <FUNCTION>exit</FUNCTION>(<NUMERIC>1</NUMERIC>);
            <KEYWORD>break</KEYWORD>;
        }
    }


    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>stic_cr</OO><OPERATOR>.</OPERATOR><OO>min_tick</OO> <OPERATOR>=</OPERATOR> <NUMERIC>1</NUMERIC>;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>stic_cr</OO><OPERATOR>.</OPERATOR><OO>max_tick</OO> <OPERATOR>=</OPERATOR> phase_len;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>next_phase</OO>      <OPERATOR>+=</OPERATOR> phase_len;
    <OBJ>stic</OBJ><OPERATOR>-&gt;</OPERATOR><OO>phase</OO>            <OPERATOR>=</OPERATOR> new_phase;

<COMMENT>//jzp_printf("new_phase = %d, len = %d stic-&gt;next_phase = %Ld\n", new_phase, phase_len, stic-&gt;next_phase);</COMMENT>


    <KEYWORD>return</KEYWORD> len;
}


<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*  This program is free software; you can redistribute it and/or modify    */</COMMENT>
<COMMENT>/*  it under the terms of the GNU General Public License as published by    */</COMMENT>
<COMMENT>/*  the Free Software Foundation; either version 2 of the License, or       */</COMMENT>
<COMMENT>/*  (at your option) any later version.                                     */</COMMENT>
<COMMENT>/*                                                                          */</COMMENT>
<COMMENT>/*  This program is distributed in the hope that it will be useful,         */</COMMENT>
<COMMENT>/*  but WITHOUT ANY WARRANTY; without even the implied warranty of          */</COMMENT>
<COMMENT>/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU       */</COMMENT>
<COMMENT>/*  General Public License for more details.                                */</COMMENT>
<COMMENT>/*                                                                          */</COMMENT>
<COMMENT>/*  You should have received a copy of the GNU General Public License       */</COMMENT>
<COMMENT>/*  along with this program; if not, write to the Free Software             */</COMMENT>
<COMMENT>/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.               */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>
<COMMENT>/*                  Copyright (c) 2003, Joseph Zbiciak                      */</COMMENT>
<COMMENT>/* ======================================================================== */</COMMENT>